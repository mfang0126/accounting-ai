import { tsConfigPaths, esbuild } from './chunk-AMZJCH64.js';
import { pathToFileURL } from 'url';
import { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';
import commonjs from '@rollup/plugin-commonjs';
import json from '@rollup/plugin-json';
import { rollup } from 'rollup';
import * as babel from '@babel/core';
import babel__default from '@babel/core';

function removeAllOptionsFromMastraExcept(result, option, logger) {
  const t = babel__default.types;
  return {
    name: "remove-all-except-" + option + "-config",
    visitor: {
      ExportNamedDeclaration: {
        // remove all exports
        exit(path) {
          path.remove();
        }
      },
      NewExpression(path, state) {
        const varDeclaratorPath = path.findParent((path2) => t.isVariableDeclarator(path2.node));
        if (!varDeclaratorPath) {
          return;
        }
        const parentNode = path.parentPath.node;
        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== "mastra") {
          return;
        }
        let mastraArgs = t.objectExpression([]);
        if (t.isObjectExpression(path.node.arguments[0])) {
          mastraArgs = path.node.arguments[0];
        }
        let configProperty = mastraArgs.properties.find(
          (prop) => t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === option
        );
        let configValue = t.objectExpression([]);
        const programPath = path.scope.getProgramParent().path;
        if (!programPath) {
          return;
        }
        if (configProperty && t.isObjectProperty(configProperty) && t.isExpression(configProperty.value)) {
          result.hasCustomConfig = true;
          configValue = configProperty.value;
          if (t.isIdentifier(configProperty.value) && configProperty.value.name === option) {
            const configBinding = state.file.scope.getBinding(option);
            if (configBinding && t.isVariableDeclarator(configBinding.path.node)) {
              const id = path.scope.generateUidIdentifier(option);
              configBinding.path.replaceWith(t.variableDeclarator(id, configBinding.path.node.init));
              configValue = id;
            }
          }
        }
        const exportDeclaration = t.exportNamedDeclaration(
          t.variableDeclaration("const", [t.variableDeclarator(t.identifier(option), configValue)]),
          []
        );
        programPath.node.body.push(exportDeclaration);
      },
      Program: {
        exit(path) {
          const hasExport = path.node.body.some(
            (node) => node.type === "ExportNamedDeclaration" || node.type === "ExportDefaultDeclaration"
          );
          if (!hasExport) {
            if (logger) {
              logger.warn(`Mastra ${option} config could not be extracted. Please make sure your entry file looks like this:
export const mastra = new Mastra({
  ${option}: <value>
})

`);
            }
            const fallbackExportDeclaration = t.exportNamedDeclaration(
              t.variableDeclaration("const", [t.variableDeclarator(t.identifier(option), t.objectExpression([]))]),
              []
            );
            path.node.body.push(fallbackExportDeclaration);
          }
        }
      }
    }
  };
}

// src/build/plugins/remove-all-except.ts
function removeAllOptionsFromMastraExceptPlugin(mastraEntry, name, result, options) {
  return {
    name: `remove-${name}`,
    transform(code, id) {
      if (id !== mastraEntry) {
        return;
      }
      return new Promise((resolve, reject) => {
        babel.transform(
          code,
          {
            babelrc: false,
            configFile: false,
            filename: id,
            plugins: [removeAllOptionsFromMastraExcept(result, name, options?.logger)],
            sourceMaps: options?.sourcemap
          },
          (err, result2) => {
            if (err) {
              return reject(err);
            }
            resolve({
              code: result2.code,
              map: result2.map
            });
          }
        );
      });
    }
  };
}
function removeNonReferencedNodes() {
  const t = babel__default.types;
  return {
    name: "remove-non-referenced-nodes",
    visitor: {
      Program(path) {
        const scope = path.scope;
        const currentBody = path.get("body");
        const filteredBody = currentBody.filter((childPath) => {
          if (childPath.isExportDeclaration()) {
            return true;
          }
          if (childPath.isVariableDeclaration()) {
            return childPath.node.declarations.some((decl) => {
              if (!t.isIdentifier(decl.id)) {
                return false;
              }
              const name = decl.id.name;
              const binding = scope.getBinding(name);
              return binding && (binding.referenced || binding.referencePaths.length > 0);
            });
          }
          if (childPath.isFunctionDeclaration() || childPath.isClassDeclaration()) {
            if (!t.isIdentifier(childPath.node.id)) {
              return false;
            }
            const name = childPath.node.id.name;
            const binding = scope.getBinding(name);
            return binding && (binding.referenced || binding.referencePaths.length > 0);
          }
          if (childPath.isImportDeclaration()) {
            return childPath.node.specifiers.some((specifier) => {
              const importedName = specifier.local.name;
              const binding = scope.getBinding(importedName);
              return binding && (binding.referenced || binding.referencePaths.length > 0);
            });
          }
          return false;
        });
        path.set(
          "body",
          filteredBody.map((p) => p.node)
        );
      }
    }
  };
}

// src/build/plugins/remove-unused-references.ts
function recursiveRemoveNonReferencedNodes(code) {
  return new Promise(async (resolve, reject) => {
    babel.transform(
      code,
      {
        babelrc: false,
        configFile: false,
        plugins: [removeNonReferencedNodes()]
      },
      (err, result) => {
        if (err) {
          return reject(err);
        }
        if (result && result.code !== code) {
          return recursiveRemoveNonReferencedNodes(result.code).then(resolve, reject);
        }
        resolve({
          code: result.code,
          map: result.map
        });
      }
    );
  });
}

// src/build/shared/extract-mastra-option.ts
function extractMastraOptionBundler(name, entryFile, result, logger) {
  return rollup({
    logLevel: "silent",
    input: {
      [`${name}-config`]: entryFile
    },
    treeshake: "smallest",
    plugins: [
      tsConfigPaths(),
      // transpile typescript to something we understand
      esbuild(),
      optimizeLodashImports({
        include: "**/*.{js,ts,mjs,cjs}"
      }),
      commonjs({
        extensions: [".js", ".ts"],
        strictRequires: "strict",
        transformMixedEsModules: true,
        ignoreTryCatch: false
      }),
      json(),
      removeAllOptionsFromMastraExceptPlugin(entryFile, name, result, { logger }),
      // let esbuild remove all unused imports
      esbuild(),
      {
        name: "cleanup",
        transform(code, id) {
          if (id !== entryFile) {
            return;
          }
          return recursiveRemoveNonReferencedNodes(code);
        }
      },
      // let esbuild remove it once more
      esbuild()
    ]
  });
}
async function extractMastraOption(name, entryFile, outputDir, logger) {
  const result = {
    hasCustomConfig: false
  };
  const bundler = await extractMastraOptionBundler(name, entryFile, result, logger);
  const output = await bundler.write({
    dir: outputDir,
    format: "es",
    entryFileNames: "[name].mjs"
  });
  if (result.hasCustomConfig) {
    const configPath = `${outputDir}/${name}-config.mjs`;
    return {
      bundleOutput: output,
      getConfig: () => import(pathToFileURL(configPath).href).then((m) => m[name])
    };
  }
  return null;
}

// src/build/bundlerOptions.ts
async function getBundlerOptions(entryFile, outputDir, logger) {
  const result = await extractMastraOption("bundler", entryFile, outputDir, logger);
  if (!result) {
    return null;
  }
  return result.getConfig();
}

export { extractMastraOption, getBundlerOptions };
//# sourceMappingURL=chunk-3WL6HPU3.js.map
//# sourceMappingURL=chunk-3WL6HPU3.js.map