import { isDependencyPartOfPackage } from './chunk-UKA2IZKF.js';
import { pathToFileURL } from 'url';
import { getPackageInfo } from 'local-pkg';
import originalEsbuild from 'rollup-plugin-esbuild';
import * as babel from '@babel/core';
import babel__default from '@babel/core';
import fs from 'fs';
import path, { normalize } from 'path';
import stripJsonComments from 'strip-json-comments';
import { createHandler } from 'typescript-paths';
import originalEsmShim from '@rollup/plugin-esm-shim';

async function getPackageRootPath(packageName, parentPath) {
  let rootPath;
  try {
    let options = void 0;
    if (parentPath) {
      if (!parentPath.startsWith("file://")) {
        parentPath = pathToFileURL(parentPath).href;
      }
      options = {
        paths: [parentPath]
      };
    }
    const pkg = await getPackageInfo(packageName, options);
    rootPath = pkg?.rootPath ?? null;
  } catch {
    rootPath = null;
  }
  return rootPath;
}
function esbuild(options = {}) {
  return originalEsbuild({
    target: "node20",
    platform: "node",
    minify: false,
    ...options
  });
}
function removeDeployer() {
  const t = babel__default.types;
  function removeDeployerFromObject(objectExpr, scope) {
    const deployerProp = objectExpr.properties.find(
      (prop) => t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === "deployer"
    );
    if (deployerProp) {
      objectExpr.properties = objectExpr.properties.filter((prop) => prop !== deployerProp);
      if (t.isIdentifier(deployerProp.value)) {
        const deployerBinding = scope.getBinding(deployerProp.value.name);
        if (deployerBinding) {
          deployerBinding.path?.parentPath?.remove();
        }
      }
    }
    return deployerProp;
  }
  return {
    name: "remove-deployer",
    visitor: {
      NewExpression(path2, state) {
        const varDeclaratorPath = path2.findParent((path3) => t.isVariableDeclarator(path3.node));
        if (!varDeclaratorPath) {
          return;
        }
        const parentNode = path2.parentPath.node;
        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== "mastra") {
          return;
        }
        if (!state.hasReplaced) {
          state.hasReplaced = true;
          const newMastraObj = t.cloneNode(path2.node);
          if (t.isObjectExpression(newMastraObj.arguments[0]) && newMastraObj.arguments[0].properties?.length) {
            const objectArg = newMastraObj.arguments[0];
            let foundDeployer = false;
            const directDeployer = removeDeployerFromObject(objectArg, state.file.scope);
            if (directDeployer) {
              foundDeployer = true;
            }
            for (const prop of objectArg.properties) {
              if (t.isSpreadElement(prop) && t.isIdentifier(prop.argument)) {
                const spreadBinding = state.file.scope.getBinding(prop.argument.name);
                if (spreadBinding?.path && t.isVariableDeclarator(spreadBinding.path.node)) {
                  const init = spreadBinding.path.node.init;
                  if (t.isObjectExpression(init)) {
                    const spreadDeployer = removeDeployerFromObject(init, state.file.scope);
                    if (spreadDeployer) {
                      foundDeployer = true;
                    }
                  }
                }
              }
            }
            if (foundDeployer) {
              path2.replaceWith(newMastraObj);
            }
          }
        }
      }
    }
  };
}

// src/build/plugins/remove-deployer.ts
function removeDeployer2(mastraEntry, options) {
  return {
    name: "remove-deployer",
    transform(code, id) {
      if (id !== mastraEntry) {
        return;
      }
      return new Promise((resolve, reject) => {
        babel.transform(
          code,
          {
            babelrc: false,
            configFile: false,
            filename: id,
            plugins: [removeDeployer],
            sourceMaps: options?.sourcemap
          },
          (err, result) => {
            if (err) {
              return reject(err);
            }
            resolve({
              code: result.code,
              map: result.map
            });
          }
        );
      });
    }
  };
}
var PLUGIN_NAME = "tsconfig-paths";
function hasPaths(tsConfigPath) {
  try {
    const content = fs.readFileSync(tsConfigPath, "utf8");
    const config = JSON.parse(stripJsonComments(content));
    return !!(config.compilerOptions?.paths && Object.keys(config.compilerOptions.paths).length > 0 || typeof config.extends === "string" && config.extends.length > 0 || Array.isArray(config.extends) && config.extends.length > 0);
  } catch {
    return false;
  }
}
function tsConfigPaths({ tsConfigPath, respectCoreModule, localResolve } = {}) {
  const handlerCache = /* @__PURE__ */ new Map();
  function findTsConfigForFile(filePath) {
    let currentDir = path.dirname(filePath);
    const root = path.parse(currentDir).root;
    while (currentDir !== root) {
      const tsConfigPath2 = path.join(currentDir, "tsconfig.json");
      if (fs.existsSync(tsConfigPath2)) {
        if (hasPaths(tsConfigPath2)) {
          return tsConfigPath2;
        }
      }
      const tsConfigBasePath = path.join(currentDir, "tsconfig.base.json");
      if (fs.existsSync(tsConfigBasePath)) {
        if (hasPaths(tsConfigBasePath)) {
          return tsConfigBasePath;
        }
      }
      currentDir = path.dirname(currentDir);
    }
    return null;
  }
  function getHandlerForFile(filePath) {
    if (tsConfigPath && typeof tsConfigPath === "string") {
      if (!handlerCache.has(tsConfigPath)) {
        handlerCache.set(
          tsConfigPath,
          createHandler({
            log: () => {
            },
            tsConfigPath,
            respectCoreModule,
            falllback: (moduleName) => fs.existsSync(moduleName)
          })
        );
      }
      return handlerCache.get(tsConfigPath);
    }
    const configPath = findTsConfigForFile(filePath);
    if (!configPath) {
      return null;
    }
    if (!handlerCache.has(configPath)) {
      handlerCache.set(
        configPath,
        createHandler({
          log: () => {
          },
          tsConfigPath: configPath,
          respectCoreModule,
          falllback: (moduleName) => fs.existsSync(moduleName)
        })
      );
    }
    return handlerCache.get(configPath);
  }
  function resolveAlias(request, importer) {
    const dynamicHandler = getHandlerForFile(importer);
    if (!dynamicHandler) {
      return null;
    }
    const resolved = dynamicHandler(request, normalize(importer));
    return resolved;
  }
  return {
    name: PLUGIN_NAME,
    resolveId: {
      order: "pre",
      async handler(request, importer, options) {
        if (!importer || request.startsWith("\0") || importer.charCodeAt(0) === 0) {
          return null;
        }
        if (!path.isAbsolute(importer)) {
          importer = path.resolve(process.cwd(), importer);
        }
        const moduleName = resolveAlias(request, importer);
        if (!moduleName) {
          const resolved2 = await this.resolve(request, importer, { skipSelf: true, ...options });
          if (!resolved2) {
            return null;
          }
          if (localResolve) {
            const importerInfo = this.getModuleInfo(importer);
            const importerPluginMeta = importerInfo?.meta?.[PLUGIN_NAME];
            if (!request.startsWith("./") && !request.startsWith("../") && importerPluginMeta?.resolved) {
              return {
                ...resolved2,
                external: !request.startsWith("hono/") && request !== "hono"
              };
            }
          }
          return {
            ...resolved2,
            meta: {
              ...resolved2.meta || {}
            }
          };
        }
        if (!path.extname(moduleName)) {
          const resolved2 = await this.resolve(moduleName, importer, { skipSelf: true, ...options });
          if (!resolved2) {
            return null;
          }
          return {
            ...resolved2,
            meta: {
              ...resolved2.meta,
              [PLUGIN_NAME]: {
                resolved: true
              }
            }
          };
        }
        const resolved = await this.resolve(moduleName, importer, { skipSelf: true, ...options });
        if (!resolved) {
          return null;
        }
        return {
          ...resolved,
          meta: {
            ...resolved.meta,
            [PLUGIN_NAME]: {
              resolved: true
            }
          }
        };
      }
    }
  };
}
var FilenameDeclarationRegex = /(?:const|let|var)\s+__filename/;
var DirnameDeclarationRegex = /(?:const|let|var)\s+__dirname/;
function esmShim() {
  const original = originalEsmShim();
  return {
    name: "esm-shim",
    renderChunk(code, chunk, opts, meta) {
      const hasFilename = code.includes("__filename");
      const hasDirname = code.includes("__dirname");
      const userDeclaredFilename = hasFilename && FilenameDeclarationRegex.test(code);
      const userDeclaredDirname = hasDirname && DirnameDeclarationRegex.test(code);
      if (userDeclaredFilename || userDeclaredDirname) {
        return null;
      }
      if (typeof original.renderChunk === "function") {
        return original.renderChunk.call(this, code, chunk, opts, meta);
      }
      return null;
    }
  };
}

// src/build/plugins/subpath-externals-resolver.ts
function subpathExternalsResolver(externals) {
  return {
    name: "subpath-externals-resolver",
    resolveId(id) {
      if (id.startsWith(".") || id.startsWith("/")) {
        return null;
      }
      const isPartOfExternals = externals.some((external) => isDependencyPartOfPackage(id, external));
      if (isPartOfExternals) {
        return {
          id,
          external: true
        };
      }
    }
  };
}

export { esbuild, esmShim, getPackageRootPath, removeDeployer2 as removeDeployer, subpathExternalsResolver, tsConfigPaths };
//# sourceMappingURL=chunk-AMZJCH64.js.map
//# sourceMappingURL=chunk-AMZJCH64.js.map