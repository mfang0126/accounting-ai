import { tsConfigPaths, esbuild, removeDeployer, getPackageRootPath, subpathExternalsResolver, esmShim } from './chunk-AMZJCH64.js';
import { slash, isDependencyPartOfPackage, getPackageName, isBuiltinModule, getCompiledDepCachePath, rollupSafeName } from './chunk-UKA2IZKF.js';
import { existsSync } from 'fs';
import { readFile, writeFile } from 'fs/promises';
import * as path from 'path';
import { dirname, join, relative, basename as basename$1 } from 'path';
import * as babel from '@babel/core';
import babel__default from '@babel/core';
import { MastraBaseError, ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';
import * as pkg from 'empathic/package';
import { createWorkspacesCache, findWorkspaces, findWorkspacesRoot } from 'find-workspaces';
import { spawn as spawn$1 } from 'child_process';
import { fileURLToPath, pathToFileURL } from 'url';
import { noopLogger } from '@mastra/core/logger';
import commonjs from '@rollup/plugin-commonjs';
import json from '@rollup/plugin-json';
import virtual from '@rollup/plugin-virtual';
import { readJSON } from 'fs-extra/esm';
import { resolveModule, getPackageInfo } from 'local-pkg';
import { rollup } from 'rollup';
import { builtinModules } from 'module';
import { basename } from 'path/posix';
import { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';
import nodeResolve from '@rollup/plugin-node-resolve';
import * as resolve from 'resolve.exports';

// ../../node_modules/.pnpm/stacktrace-parser@0.1.11/node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js
var UNKNOWN_FUNCTION = "<unknown>";
function parse(stackString) {
  var lines = stackString.split("\n");
  return lines.reduce(function(stack, line) {
    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
    if (parseResult) {
      stack.push(parseResult);
    }
    return stack;
  }, []);
}
var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
var chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
function parseChrome(line) {
  var parts = chromeRe.exec(line);
  if (!parts) {
    return null;
  }
  var isNative = parts[2] && parts[2].indexOf("native") === 0;
  var isEval = parts[2] && parts[2].indexOf("eval") === 0;
  var submatch = chromeEvalRe.exec(parts[2]);
  if (isEval && submatch != null) {
    parts[2] = submatch[1];
    parts[3] = submatch[2];
    parts[4] = submatch[3];
  }
  return {
    file: !isNative ? parts[2] : null,
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: isNative ? [parts[2]] : [],
    lineNumber: parts[3] ? +parts[3] : null,
    column: parts[4] ? +parts[4] : null
  };
}
var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseWinjs(line) {
  var parts = winjsRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}
var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i;
var geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
function parseGecko(line) {
  var parts = geckoRe.exec(line);
  if (!parts) {
    return null;
  }
  var isEval = parts[3] && parts[3].indexOf(" > eval") > -1;
  var submatch = geckoEvalRe.exec(parts[3]);
  if (isEval && submatch != null) {
    parts[3] = submatch[1];
    parts[4] = submatch[2];
    parts[5] = null;
  }
  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: parts[2] ? parts[2].split(",") : [],
    lineNumber: parts[4] ? +parts[4] : null,
    column: parts[5] ? +parts[5] : null
  };
}
var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
function parseJSC(line) {
  var parts = javaScriptCoreRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[3],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[4],
    column: parts[5] ? +parts[5] : null
  };
}
var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
function parseNode(line) {
  var parts = nodeRe.exec(line);
  if (!parts) {
    return null;
  }
  return {
    file: parts[2],
    methodName: parts[1] || UNKNOWN_FUNCTION,
    arguments: [],
    lineNumber: +parts[3],
    column: parts[4] ? +parts[4] : null
  };
}
var workspacesCache = createWorkspacesCache();
async function getWorkspaceInformation({
  dir = process.cwd(),
  mastraEntryFile
}) {
  const closestPkgJson = pkg.up({ cwd: dirname(mastraEntryFile) });
  const location = closestPkgJson ? dirname(slash(closestPkgJson)) : slash(process.cwd());
  const workspaces = await findWorkspaces(dir, { cache: workspacesCache });
  const _workspaceMap = new Map(
    workspaces?.map((workspace) => [
      workspace.package.name,
      {
        location: workspace.location,
        dependencies: workspace.package.dependencies,
        version: workspace.package.version
      }
    ]) ?? []
  );
  const isWorkspacePackage = (workspaces ?? []).some((ws) => ws.location === location);
  const workspaceRoot = isWorkspacePackage ? findWorkspacesRoot(dir, { cache: workspacesCache })?.location : void 0;
  return {
    // If the current package is not part of the workspace, the bundling down the line shouldn't look at any workspace packages
    workspaceMap: isWorkspacePackage ? _workspaceMap : /* @__PURE__ */ new Map(),
    workspaceRoot,
    isWorkspacePackage
  };
}
var ValidationError = class extends Error {
  type;
  stack;
  constructor(args) {
    super(args.message);
    this.type = args.type;
    this.stack = args.stack;
  }
};
function spawn(command, args = [], options = {}) {
  return new Promise((resolve2, reject) => {
    let validationError = null;
    const childProcess = spawn$1(command, args, {
      // stdio: 'inherit',
      ...options
    });
    childProcess.on("error", (error) => {
      reject(error);
    });
    let stderr = "";
    childProcess.stderr?.on("data", (message) => {
      try {
        validationError = JSON.parse(message.toString());
      } catch {
        stderr += message;
      }
    });
    childProcess.on("close", (code) => {
      if (code === 0) {
        resolve2();
      } else {
        if (validationError) {
          reject(new ValidationError(validationError));
        } else {
          reject(new Error(stderr));
        }
      }
    });
  });
}
function validate(file, { injectESMShim = false, moduleResolveMapLocation }) {
  let prefixCode = "";
  if (injectESMShim) {
    prefixCode = `import { fileURLToPath } from 'url';
import { dirname } from 'path';

globalThis.__filename = fileURLToPath(import.meta.url);
globalThis.__dirname = dirname(__filename);
    `;
  }
  function errorHandler(err) {
    console.error(
      JSON.stringify({
        type: err.name,
        message: err.message,
        stack: err.stack
      })
    );
    process.exit(1);
  }
  return spawn(
    process.execPath,
    [
      "--import",
      import.meta.resolve("@mastra/deployer/loader"),
      "--input-type=module",
      "--enable-source-maps",
      "-e",
      `${prefixCode};import('${pathToFileURL(file).href}').catch(err => {
        ${errorHandler.toString()}
        errorHandler(err);
      })`.replaceAll(/\n/g, "")
    ],
    {
      env: {
        ...process.env,
        MODULE_MAP: `${moduleResolveMapLocation}`
      },
      cwd: dirname(file)
    }
  );
}
function isNodeBuiltin(dep) {
  const [pkg2] = dep.split("/");
  return dep.startsWith("node:") || builtinModules.includes(dep) || builtinModules.includes(pkg2);
}

// src/build/analyze/constants.ts
var DEPS_TO_IGNORE = ["#tools"];
var GLOBAL_EXTERNALS = [
  "pino",
  "pino-pretty",
  "@libsql/client",
  "pg",
  "libsql",
  "#tools",
  "typescript",
  "undici",
  "readable-stream"
];
var DEPRECATED_EXTERNALS = ["fastembed", "nodemailer", "jsdom", "sqlite3"];

// src/build/analyze/analyzeEntry.ts
function getInputPlugins({ entry, isVirtualFile }, mastraEntry, { sourcemapEnabled }) {
  const normalizedMastraEntry = slash(mastraEntry);
  let virtualPlugin = null;
  if (isVirtualFile) {
    virtualPlugin = virtual({
      "#entry": entry
    });
    entry = "#entry";
  }
  const plugins = [];
  if (virtualPlugin) {
    plugins.push(virtualPlugin);
  }
  plugins.push(
    ...[
      tsConfigPaths(),
      {
        name: "custom-alias-resolver",
        resolveId(id) {
          if (id === "#server") {
            return slash(fileURLToPath(import.meta.resolve("@mastra/deployer/server")));
          }
          if (id === "#mastra") {
            return normalizedMastraEntry;
          }
          if (id.startsWith("@mastra/server")) {
            return fileURLToPath(import.meta.resolve(id));
          }
        }
      },
      json(),
      esbuild(),
      commonjs({
        strictRequires: "debug",
        ignoreTryCatch: false,
        transformMixedEsModules: true,
        extensions: [".js", ".ts"]
      }),
      removeDeployer(mastraEntry, {
        sourcemap: sourcemapEnabled
      }),
      esbuild()
    ]
  );
  return plugins;
}
async function captureDependenciesToOptimize(output, workspaceMap, projectRoot, initialDepsToOptimize, {
  logger,
  shouldCheckTransitiveDependencies
}) {
  const depsToOptimize = /* @__PURE__ */ new Map();
  if (!output.facadeModuleId) {
    throw new Error(
      "Something went wrong, we could not find the package name of the entry file. Please open an issue."
    );
  }
  let entryRootPath = projectRoot;
  if (!output.facadeModuleId.startsWith("\0virtual:")) {
    entryRootPath = await getPackageRootPath(output.facadeModuleId) || projectRoot;
  }
  for (const [dependency, bindings] of Object.entries(output.importedBindings)) {
    if (isNodeBuiltin(dependency) || dependency.startsWith("#")) {
      continue;
    }
    const pkgName = getPackageName(dependency);
    let rootPath = null;
    let isWorkspace = false;
    let version;
    if (pkgName) {
      rootPath = await getPackageRootPath(dependency, entryRootPath);
      isWorkspace = workspaceMap.has(pkgName);
      if (rootPath) {
        try {
          const pkgJson = await readJSON(`${rootPath}/package.json`);
          version = pkgJson.version;
        } catch {
        }
      }
    }
    const normalizedRootPath = rootPath ? slash(rootPath) : null;
    depsToOptimize.set(dependency, {
      exports: bindings,
      rootPath: normalizedRootPath,
      isWorkspace,
      version
    });
  }
  async function checkTransitiveDependencies(internalMap, maxDepth = 10, currentDepth = 0) {
    if (currentDepth >= maxDepth) {
      logger.warn("Maximum dependency depth reached while checking transitive dependencies.");
      return;
    }
    const depsSnapshot = new Map(depsToOptimize);
    let hasAddedDeps = false;
    for (const [dep, meta] of depsSnapshot) {
      if (!meta.isWorkspace || internalMap.has(dep)) {
        continue;
      }
      try {
        const importerPath = output.facadeModuleId ? pathToFileURL(output.facadeModuleId).href : pathToFileURL(projectRoot).href;
        const resolvedPath = resolveModule(dep, {
          paths: [importerPath]
        });
        if (!resolvedPath) {
          logger.warn(`Could not resolve path for workspace dependency ${dep}`);
          continue;
        }
        const analysis = await analyzeEntry({ entry: resolvedPath, isVirtualFile: false }, "", {
          workspaceMap,
          projectRoot,
          logger: noopLogger,
          sourcemapEnabled: false,
          initialDepsToOptimize: depsToOptimize
        });
        if (!analysis?.dependencies) {
          continue;
        }
        for (const [innerDep, innerMeta] of analysis.dependencies) {
          if (innerMeta.isWorkspace && !internalMap.has(innerDep) && !depsToOptimize.has(innerDep)) {
            depsToOptimize.set(innerDep, innerMeta);
            internalMap.set(innerDep, innerMeta);
            hasAddedDeps = true;
          }
        }
      } catch (err) {
        logger.error(`Failed to resolve or analyze dependency ${dep}: ${err.message}`);
      }
    }
    if (hasAddedDeps) {
      await checkTransitiveDependencies(internalMap, maxDepth, currentDepth + 1);
    }
  }
  if (shouldCheckTransitiveDependencies) {
    await checkTransitiveDependencies(initialDepsToOptimize);
  }
  const dynamicImports = output.dynamicImports.filter((d) => !DEPS_TO_IGNORE.includes(d));
  if (dynamicImports.length) {
    for (const dynamicImport of dynamicImports) {
      if (!depsToOptimize.has(dynamicImport) && !isNodeBuiltin(dynamicImport)) {
        const pkgName = getPackageName(dynamicImport);
        let version;
        let rootPath = null;
        if (pkgName) {
          rootPath = await getPackageRootPath(dynamicImport, entryRootPath);
          if (rootPath) {
            try {
              const pkgJson = await readJSON(`${rootPath}/package.json`);
              version = pkgJson.version;
            } catch {
            }
          }
        }
        depsToOptimize.set(dynamicImport, {
          exports: ["*"],
          rootPath: rootPath ? slash(rootPath) : null,
          isWorkspace: false,
          version
        });
      }
    }
  }
  return depsToOptimize;
}
async function analyzeEntry({
  entry,
  isVirtualFile
}, mastraEntry, {
  logger,
  sourcemapEnabled,
  workspaceMap,
  projectRoot,
  initialDepsToOptimize = /* @__PURE__ */ new Map(),
  // used to avoid infinite recursion
  shouldCheckTransitiveDependencies = false
}) {
  const optimizerBundler = await rollup({
    logLevel: process.env.MASTRA_BUNDLER_DEBUG === "true" ? "debug" : "silent",
    input: isVirtualFile ? "#entry" : entry,
    treeshake: false,
    preserveSymlinks: true,
    plugins: getInputPlugins({ entry, isVirtualFile }, mastraEntry, { sourcemapEnabled }),
    external: DEPS_TO_IGNORE
  });
  const { output } = await optimizerBundler.generate({
    format: "esm",
    inlineDynamicImports: true
  });
  await optimizerBundler.close();
  const depsToOptimize = await captureDependenciesToOptimize(
    output[0],
    workspaceMap,
    projectRoot,
    initialDepsToOptimize,
    {
      logger,
      shouldCheckTransitiveDependencies
    }
  );
  return {
    dependencies: depsToOptimize,
    output: {
      code: output[0].code,
      map: output[0].map
    }
  };
}
function aliasHono() {
  return {
    name: "hono-alias",
    resolveId(id) {
      if (!id.startsWith("@hono/") && !id.startsWith("hono/") && id !== "hono" && id !== "hono-openapi") {
        return;
      }
      const path2 = import.meta.resolve(id);
      return fileURLToPath(path2);
    }
  };
}
function moduleResolveMap(externals, projectRoot) {
  const importMap = /* @__PURE__ */ new Map();
  return {
    name: "module-resolve-map",
    moduleParsed(info) {
      if (info.importedIds.length === 0 || !info.id) {
        return;
      }
      for (const importedId of info.importedIds) {
        for (const external of externals) {
          if (isDependencyPartOfPackage(importedId, external)) {
            importMap.set(external, info.id);
          }
        }
      }
    },
    async generateBundle(options, bundle) {
      const resolveMap = /* @__PURE__ */ new Map();
      for (const [fileName, chunk] of Object.entries(bundle)) {
        if (chunk.type === "chunk") {
          for (const [external, resolvedFrom] of importMap) {
            if (chunk.moduleIds.includes(resolvedFrom)) {
              const fullPath = pathToFileURL(slash(join(projectRoot, fileName))).toString();
              const innerMap = resolveMap.get(fullPath) || /* @__PURE__ */ new Map();
              innerMap.set(external, pathToFileURL(slash(resolvedFrom)).toString());
              resolveMap.set(fullPath, innerMap);
            }
          }
        }
      }
      const resolveMapJson = Object.fromEntries(
        Array.from(resolveMap.entries()).map(([key, value]) => [key, Object.fromEntries(value.entries())])
      );
      this.emitFile({
        type: "asset",
        name: "module-resolve-map.json",
        source: `${JSON.stringify(resolveMapJson, null, 2)}`
      });
    }
  };
}
function nodeGypDetector() {
  const modulesToTrack = /* @__PURE__ */ new Set();
  const modulesToTrackPackageInfo = /* @__PURE__ */ new Map();
  return {
    name: "node-gyp-build-detector",
    moduleParsed(info) {
      if (!info.meta?.commonjs?.requires?.length) {
        return;
      }
      const hasNodeGypBuild = info.meta.commonjs.requires.some(
        (m) => m?.resolved?.id.endsWith("node-gyp-build/index.js")
      );
      if (!hasNodeGypBuild) {
        return;
      }
      modulesToTrack.add(info.id);
      modulesToTrackPackageInfo.set(info.id, getPackageInfo(info.id));
    },
    async generateBundle(options, bundle) {
      const binaryMapByChunk = /* @__PURE__ */ new Map();
      for (const [fileName, chunk] of Object.entries(bundle)) {
        if (chunk.type === "chunk") {
          for (const moduleId of chunk.moduleIds) {
            if (modulesToTrackPackageInfo.has(moduleId)) {
              const pkgInfo = await modulesToTrackPackageInfo.get(moduleId);
              if (!binaryMapByChunk.has(fileName)) {
                binaryMapByChunk.set(fileName, /* @__PURE__ */ new Set());
              }
              if (pkgInfo?.packageJson?.name) {
                binaryMapByChunk.get(fileName).add(pkgInfo.packageJson.name);
              }
            }
          }
        }
      }
      const binaryMapJson = Object.fromEntries(
        Array.from(binaryMapByChunk.entries()).map(([key, value]) => [key, Array.from(value)])
      );
      this.emitFile({
        type: "asset",
        name: "binary-map.json",
        source: `${JSON.stringify(binaryMapJson, null, 2)}`
      });
    }
  };
}

// src/build/analyze/bundleExternals.ts
function prepareEntryFileName(name, rootDir) {
  return rollupSafeName(name, rootDir);
}
function createVirtualDependencies(depsToOptimize, {
  projectRoot,
  workspaceRoot,
  outputDir,
  bundlerOptions
}) {
  const { isDev = false, externalsPreset = false } = bundlerOptions || {};
  const fileNameToDependencyMap = /* @__PURE__ */ new Map();
  const optimizedDependencyEntries = /* @__PURE__ */ new Map();
  const rootDir = workspaceRoot || projectRoot;
  for (const [dep, { exports: exports2 }] of depsToOptimize.entries()) {
    const fileName = dep.replaceAll("/", "__");
    const virtualFile = [];
    const exportStringBuilder = [];
    for (const local of exports2) {
      if (local === "*") {
        virtualFile.push(`export * from '${dep}';`);
        continue;
      } else if (local === "default") {
        exportStringBuilder.push("default");
      } else {
        exportStringBuilder.push(local);
      }
    }
    const chunks = [];
    if (exportStringBuilder.length) {
      chunks.push(`{ ${exportStringBuilder.join(", ")} }`);
    }
    if (chunks.length) {
      virtualFile.push(`export ${chunks.join(", ")} from '${dep}';`);
    }
    let entryName = prepareEntryFileName(path.join(outputDir, fileName), rootDir);
    fileNameToDependencyMap.set(entryName, dep);
    optimizedDependencyEntries.set(dep, {
      name: entryName,
      virtual: virtualFile.join("\n")
    });
  }
  if (isDev || externalsPreset) {
    for (const [dep, { isWorkspace, rootPath }] of depsToOptimize.entries()) {
      if (!isWorkspace || !rootPath || !workspaceRoot) {
        continue;
      }
      const currentDepPath = optimizedDependencyEntries.get(dep);
      if (!currentDepPath) {
        continue;
      }
      const fileName = basename(currentDepPath.name);
      const entryName = prepareEntryFileName(getCompiledDepCachePath(rootPath, fileName), rootDir);
      fileNameToDependencyMap.set(entryName, dep);
      optimizedDependencyEntries.set(dep, {
        ...currentDepPath,
        name: entryName
      });
    }
  }
  return { optimizedDependencyEntries, fileNameToDependencyMap };
}
async function getInputPlugins2(virtualDependencies, {
  transpilePackages,
  workspaceMap,
  bundlerOptions,
  rootDir,
  externals
}) {
  const transpilePackagesMap = /* @__PURE__ */ new Map();
  for (const pkg2 of transpilePackages) {
    const dir = await getPackageRootPath(pkg2);
    if (dir) {
      transpilePackagesMap.set(pkg2, slash(dir));
    } else {
      transpilePackagesMap.set(pkg2, workspaceMap.get(pkg2)?.location ?? pkg2);
    }
  }
  return [
    virtual(
      Array.from(virtualDependencies.entries()).reduce(
        (acc, [dep, virtualDep]) => {
          acc[`#virtual-${dep}`] = virtualDep.virtual;
          return acc;
        },
        {}
      )
    ),
    tsConfigPaths(),
    subpathExternalsResolver(externals),
    transpilePackagesMap.size ? esbuild({
      format: "esm",
      include: [
        // Match files from transpilePackages by their actual directory paths
        // but exclude any nested node_modules
        ...[...transpilePackagesMap.values()].map((p) => {
          if (path.isAbsolute(p)) {
            return new RegExp(`^${p.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}/(?!.*node_modules).*$`);
          } else {
            return new RegExp(`/${p.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}/(?!.*node_modules).*$`);
          }
        }),
        // Also match workspace packages resolved through node_modules symlinks
        // (common in pnpm workspaces). Match by package name in node_modules path.
        ...[...transpilePackagesMap.keys()].map((pkgName) => {
          const escapedPkgName = pkgName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          return new RegExp(`/node_modules/${escapedPkgName}/(?!.*node_modules).*$`);
        })
      ],
      // Disable the default /node_modules/ exclusion from rollup-plugin-esbuild.
      // In pnpm workspaces, nodeResolve resolves workspace packages through node_modules
      // symlinks, so the resolved paths contain "node_modules". Without this, workspace
      // package .ts files won't be transpiled even if they match the include patterns.
      exclude: []
    }) : null,
    bundlerOptions.noBundling ? {
      name: "alias-optimized-deps",
      async resolveId(id, importer, options) {
        if (!virtualDependencies.has(id)) {
          return null;
        }
        const info = virtualDependencies.get(id);
        const packageRootPath = path.join(rootDir, path.dirname(path.dirname(path.dirname(info.name))));
        const pkgJsonBuffer = await readFile(path.join(packageRootPath, "package.json"), "utf-8");
        const pkgJson = JSON.parse(pkgJsonBuffer);
        if (!pkgJson) {
          return null;
        }
        const pkgName = pkgJson.name || "";
        let resolvedPath = resolve.exports(pkgJson, id.replace(pkgName, "."))?.[0];
        if (!resolvedPath) {
          resolvedPath = pkgJson.main ?? "index.js";
        }
        const resolved = await this.resolve(path.posix.join(packageRootPath, resolvedPath), importer, options);
        return resolved;
      }
    } : null,
    optimizeLodashImports({
      include: "**/*.{js,ts,mjs,cjs}"
    }),
    commonjs({
      strictRequires: "strict",
      transformMixedEsModules: true,
      ignoreTryCatch: false
    }),
    bundlerOptions.noBundling ? null : nodeResolve({
      preferBuiltins: true,
      exportConditions: ["node"]
    }),
    bundlerOptions.noBundling ? esmShim() : null,
    // hono is imported from deployer, so we need to resolve from here instead of the project root
    aliasHono(),
    json(),
    nodeGypDetector(),
    moduleResolveMap(externals, rootDir),
    {
      name: "not-found-resolver",
      resolveId: {
        order: "post",
        async handler(id, importer) {
          if (!importer) {
            return null;
          }
          if (!id.endsWith(".node")) {
            return null;
          }
          const pkgInfo = await getPackageInfo(importer);
          const packageName = pkgInfo?.packageJson?.name || id;
          throw new MastraBaseError({
            id: "DEPLOYER_BUNDLE_EXTERNALS_MISSING_NATIVE_BUILD",
            domain: ErrorDomain.DEPLOYER,
            category: ErrorCategory.USER,
            details: {
              importFile: importer,
              packageName
            },
            text: `We found a possible binary dependency in your bundle. ${id} was not found when imported at ${importer}.

Please consider adding \`${packageName}\` to your externals, or updating this import to not end with ".node".

export const mastra = new Mastra({
  bundler: {
    externals: ["${packageName}"],
  }
})`
          });
        }
      }
    }
  ].filter(Boolean);
}
async function buildExternalDependencies(virtualDependencies, {
  externals,
  packagesToTranspile,
  workspaceMap,
  rootDir,
  outputDir,
  bundlerOptions
}) {
  if (virtualDependencies.size === 0) {
    return [];
  }
  const noBundling = bundlerOptions.isDev || bundlerOptions.externalsPreset;
  const plugins = await getInputPlugins2(virtualDependencies, {
    transpilePackages: packagesToTranspile,
    workspaceMap,
    bundlerOptions: {
      noBundling
    },
    rootDir,
    externals
  });
  const bundler = await rollup({
    logLevel: process.env.MASTRA_BUNDLER_DEBUG === "true" ? "debug" : "silent",
    input: Array.from(virtualDependencies.entries()).reduce(
      (acc, [dep, virtualDep]) => {
        acc[virtualDep.name] = `#virtual-${dep}`;
        return acc;
      },
      {}
    ),
    external: externals,
    treeshake: noBundling ? false : "safest",
    plugins
  });
  const outputDirRelative = prepareEntryFileName(outputDir, rootDir);
  const { output } = await bundler.write({
    format: "esm",
    dir: rootDir,
    entryFileNames: "[name].mjs",
    // used to get the filename of the actual error
    sourcemap: true,
    /**
     * Rollup creates chunks for common dependencies, but these chunks are by default written to the root directory instead of respecting the entryFileNames structure.
     * So we want to write them to the `.mastra/output` folder as well.
     */
    chunkFileNames: (chunkInfo) => {
      if (noBundling) {
        const importedFromPackages = /* @__PURE__ */ new Set();
        for (const moduleId of chunkInfo.moduleIds) {
          const normalized = slash(moduleId);
          for (const [pkgName, pkgInfo] of workspaceMap.entries()) {
            const location = slash(pkgInfo.location);
            if (normalized.startsWith(location)) {
              importedFromPackages.add(pkgName);
              break;
            }
          }
        }
        if (importedFromPackages.size > 1) {
          throw new MastraBaseError({
            id: "DEPLOYER_BUNDLE_EXTERNALS_SHARED_CHUNK",
            domain: ErrorDomain.DEPLOYER,
            category: ErrorCategory.USER,
            details: {
              chunkName: chunkInfo.name,
              packages: JSON.stringify(Array.from(importedFromPackages))
            },
            text: `Please open an issue. We found a shared chunk "${chunkInfo.name}" used by multiple workspace packages: ${Array.from(importedFromPackages).join(", ")}.`
          });
        }
        if (importedFromPackages.size === 1) {
          const [pkgName] = importedFromPackages;
          const workspaceLocation = workspaceMap.get(pkgName).location;
          return prepareEntryFileName(getCompiledDepCachePath(workspaceLocation, "[name].mjs"), rootDir);
        }
      }
      return `${outputDirRelative}/[name].mjs`;
    },
    assetFileNames: `${outputDirRelative}/[name][extname]`,
    hoistTransitiveImports: false
  });
  await bundler.close();
  return output;
}
function findExternalImporter(module, external, allOutputs) {
  const capturedFiles = /* @__PURE__ */ new Set();
  for (const id of module.imports) {
    if (isDependencyPartOfPackage(id, external)) {
      return module;
    } else {
      if (id.endsWith(".mjs")) {
        capturedFiles.add(id);
      }
    }
  }
  for (const file of capturedFiles) {
    const nextModule = allOutputs.find((o) => o.fileName === file);
    if (nextModule) {
      const importer = findExternalImporter(nextModule, external, allOutputs);
      if (importer) {
        return importer;
      }
    }
  }
  return null;
}
async function bundleExternals(depsToOptimize, outputDir, options) {
  const { workspaceRoot = null, workspaceMap = /* @__PURE__ */ new Map(), projectRoot = outputDir, bundlerOptions = {} } = options;
  const { externals: customExternals = [], transpilePackages = [], isDev = false } = bundlerOptions || {};
  let externalsPreset = false;
  if (customExternals === true) {
    externalsPreset = true;
  }
  const externalsList = Array.isArray(customExternals) ? customExternals : [];
  const allExternals = [...GLOBAL_EXTERNALS, ...DEPRECATED_EXTERNALS, ...externalsList];
  const workspacePackagesNames = Array.from(workspaceMap.keys());
  const packagesToTranspile = /* @__PURE__ */ new Set([...transpilePackages, ...workspacePackagesNames]);
  const extractedExternals = /* @__PURE__ */ new Map();
  if (externalsPreset) {
    for (const [dep, metadata] of depsToOptimize.entries()) {
      if (!metadata.isWorkspace) {
        extractedExternals.set(dep, metadata.rootPath ?? dep);
        depsToOptimize.delete(dep);
      }
    }
  }
  const { optimizedDependencyEntries, fileNameToDependencyMap } = createVirtualDependencies(depsToOptimize, {
    workspaceRoot,
    outputDir,
    projectRoot,
    bundlerOptions: {
      isDev,
      externalsPreset
    }
  });
  const output = await buildExternalDependencies(optimizedDependencyEntries, {
    externals: allExternals,
    packagesToTranspile,
    workspaceMap,
    rootDir: workspaceRoot || projectRoot,
    outputDir,
    bundlerOptions: {
      isDev,
      externalsPreset
    }
  });
  const moduleResolveMap2 = /* @__PURE__ */ new Map();
  const filteredChunks = output.filter((o) => o.type === "chunk");
  for (const o of filteredChunks.filter((o2) => o2.isEntry || o2.isDynamicEntry)) {
    for (const external of allExternals) {
      if (DEPS_TO_IGNORE.includes(external)) {
        continue;
      }
      const importer = findExternalImporter(o, external, filteredChunks);
      if (importer) {
        const fullPath = path.join(workspaceRoot || projectRoot, importer.fileName);
        let innerMap = moduleResolveMap2.get(fullPath);
        if (!innerMap) {
          innerMap = /* @__PURE__ */ new Map();
          moduleResolveMap2.set(fullPath, innerMap);
        }
        if (importer.moduleIds.length) {
          innerMap.set(
            external,
            importer.moduleIds[importer.moduleIds.length - 1]?.startsWith("\0virtual:#virtual") ? importer.moduleIds[importer.moduleIds.length - 2] : importer.moduleIds[importer.moduleIds.length - 1]
          );
        }
      }
    }
  }
  const usedExternals = /* @__PURE__ */ Object.create(null);
  for (const [fullPath, innerMap] of moduleResolveMap2) {
    const innerObj = /* @__PURE__ */ Object.create(null);
    for (const [external, value] of innerMap) {
      innerObj[external] = value;
    }
    usedExternals[fullPath] = innerObj;
  }
  if (extractedExternals.size > 0) {
    const syntheticPath = path.join(workspaceRoot || projectRoot, "__externals__");
    const externalsObj = /* @__PURE__ */ Object.create(null);
    for (const [dep, rootPath] of extractedExternals) {
      externalsObj[dep] = rootPath;
    }
    usedExternals[syntheticPath] = externalsObj;
  }
  return { output, fileNameToDependencyMap, usedExternals };
}
function checkConfigExport(result) {
  const t = babel__default.types;
  const mastraVars = /* @__PURE__ */ new Set();
  return {
    visitor: {
      ExportNamedDeclaration(path2) {
        const decl = path2.node.declaration;
        if (t.isVariableDeclaration(decl)) {
          const varDecl = decl.declarations[0];
          if (t.isIdentifier(varDecl?.id, { name: "mastra" }) && t.isNewExpression(varDecl.init) && t.isIdentifier(varDecl.init.callee, { name: "Mastra" })) {
            result.hasValidConfig = true;
          }
        }
        if (Array.isArray(path2.node.specifiers)) {
          for (const spec of path2.node.specifiers) {
            if (t.isExportSpecifier(spec) && t.isIdentifier(spec.exported, { name: "mastra" }) && t.isIdentifier(spec.local) && mastraVars.has(spec.local.name)) {
              result.hasValidConfig = true;
            }
          }
        }
      },
      // For cases 2-4 we need to track whether those variables are assigned to `new Mastra()`
      VariableDeclaration(path2) {
        for (const decl of path2.node.declarations) {
          if (t.isIdentifier(decl.id) && t.isNewExpression(decl.init) && t.isIdentifier(decl.init.callee, { name: "Mastra" })) {
            mastraVars.add(decl.id.name);
          }
        }
      }
    }
  };
}

// src/build/analyze.ts
function throwExternalDependencyError({
  errorId,
  moduleName,
  packageName,
  messagePrefix
}) {
  throw new MastraError({
    id: errorId,
    domain: ErrorDomain.DEPLOYER,
    category: ErrorCategory.USER,
    details: {
      importFile: moduleName,
      packageName
    },
    text: `${messagePrefix} \`${packageName}\` to your externals.

export const mastra = new Mastra({
  bundler: {
    externals: ["${packageName}"],
  }
})`
  });
}
function getPackageNameFromBundledModuleName(moduleName) {
  if (moduleName.includes("__")) {
    return moduleName.replaceAll("__", "/");
  }
  const chunks = moduleName.split("-");
  if (!chunks.length) {
    return moduleName;
  }
  if (chunks[0]?.startsWith("@")) {
    return chunks.slice(0, 2).join("/");
  }
  return chunks[0];
}
function validateError(err, file, {
  binaryMapData,
  workspaceMap
}) {
  let moduleName = null;
  let errorConfig = null;
  if (err instanceof ValidationError) {
    const parsedStack = parse(err.stack);
    if (err.type === "TypeError") {
      const pkgNameRegex = /.*node_modules\/([^\/]+)\//;
      const stacktraceFrame = parsedStack.find((frame) => frame.file && pkgNameRegex.test(frame.file));
      if (stacktraceFrame) {
        const match = stacktraceFrame.file.match(pkgNameRegex);
        moduleName = match?.[1] ?? getPackageNameFromBundledModuleName(basename$1(file.name));
      } else {
        moduleName = getPackageNameFromBundledModuleName(basename$1(file.name));
      }
      errorConfig = {
        id: "DEPLOYER_ANALYZE_TYPE_ERROR",
        messagePrefix: `Mastra wasn't able to bundle "${moduleName}", might be an older commonJS module. Please add`
      };
    } else if (err.stack?.includes?.("[ERR_MODULE_NOT_FOUND]")) {
      moduleName = err.message.match(/Cannot find package '([^']+)'/)?.[1];
      const parentModuleName = getPackageNameFromBundledModuleName(basename$1(file.name));
      errorConfig = {
        id: "DEPLOYER_ANALYZE_MODULE_NOT_FOUND",
        messagePrefix: `Mastra wasn't able to build your project, We couldn't load "${moduleName}" from "${parentModuleName}". Make sure "${moduleName}" is installed or add`
      };
      if (moduleName === parentModuleName) {
        return;
      }
    }
  }
  if (err.message.includes("No native build was found")) {
    const pkgName = getPackageNameFromBundledModuleName(basename$1(file.name));
    moduleName = binaryMapData[file.fileName]?.[0] ?? pkgName;
    errorConfig = {
      id: "DEPLOYER_ANALYZE_MISSING_NATIVE_BUILD",
      messagePrefix: "We found a binary dependency in your bundle but we cannot bundle it yet. Please add"
    };
  }
  if (moduleName && workspaceMap.has(moduleName)) {
    throw new MastraError({
      id: "DEPLOYER_ANALYZE_ERROR_IN_WORKSPACE",
      domain: ErrorDomain.DEPLOYER,
      category: ErrorCategory.USER,
      details: {
        // importFile: moduleName,
        packageName: moduleName
      },
      text: `We found an error in the ${moduleName} workspace package. Please find the offending package and fix the error.
  Error: ${err.stack}`
    });
  }
  if (errorConfig && moduleName) {
    throwExternalDependencyError({
      errorId: errorConfig.id,
      moduleName,
      packageName: moduleName,
      messagePrefix: errorConfig.messagePrefix
    });
  }
}
async function validateFile(root, file, {
  binaryMapData,
  moduleResolveMapLocation,
  logger,
  workspaceMap
}) {
  try {
    if (!file.isDynamicEntry && file.isEntry) {
      await validate(join(root, file.fileName), {
        moduleResolveMapLocation,
        injectESMShim: false
      });
    }
  } catch (err) {
    let errorToHandle = err;
    if (err instanceof ValidationError && err.type === "ReferenceError" && (err.message.startsWith("__dirname") || err.message.startsWith("__filename"))) {
      try {
        await validate(join(root, file.fileName), {
          moduleResolveMapLocation,
          injectESMShim: true
        });
        errorToHandle = null;
      } catch (err2) {
        errorToHandle = err2;
      }
    }
    if (errorToHandle instanceof Error) {
      validateError(errorToHandle, file, { binaryMapData, workspaceMap });
    }
  }
}
async function validateOutput({
  output,
  reverseVirtualReferenceMap,
  usedExternals,
  outputDir,
  projectRoot,
  workspaceMap,
  depsVersionInfo
}, logger) {
  const result = {
    dependencies: /* @__PURE__ */ new Map(),
    externalDependencies: /* @__PURE__ */ new Map(),
    workspaceMap
  };
  for (const deps of Object.values(usedExternals)) {
    for (const dep of Object.keys(deps)) {
      const pkgName = getPackageName(dep);
      if (pkgName) {
        const versionInfo = depsVersionInfo.get(dep) || depsVersionInfo.get(pkgName) || {};
        result.externalDependencies.set(pkgName, versionInfo);
      }
    }
  }
  let binaryMapData = {};
  if (existsSync(join(outputDir, "binary-map.json"))) {
    const binaryMap = await readFile(join(outputDir, "binary-map.json"), "utf-8");
    binaryMapData = JSON.parse(binaryMap);
  }
  for (const file of output) {
    if (file.type === "asset") {
      continue;
    }
    logger.debug(`Validating if ${file.fileName} is a valid module.`);
    if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {
      result.dependencies.set(reverseVirtualReferenceMap.get(file.name), file.fileName);
    }
    await validateFile(projectRoot, file, {
      binaryMapData,
      moduleResolveMapLocation: join(outputDir, "module-resolve-map.json"),
      logger,
      workspaceMap
    });
  }
  return result;
}
async function analyzeBundle(entries, mastraEntry, {
  outputDir,
  projectRoot,
  isDev = false,
  bundlerOptions
}, logger) {
  const mastraConfig = await readFile(mastraEntry, "utf-8");
  const mastraConfigResult = {
    hasValidConfig: false
  };
  await babel.transformAsync(mastraConfig, {
    filename: mastraEntry,
    presets: [import.meta.resolve("@babel/preset-typescript")],
    plugins: [checkConfigExport(mastraConfigResult)]
  });
  if (!mastraConfigResult.hasValidConfig) {
    logger.warn(`Invalid Mastra config. Please make sure that your entry file looks like this:
export const mastra = new Mastra({
  // your options
})

If you think your configuration is valid, please open an issue.`);
  }
  const { workspaceMap, workspaceRoot } = await getWorkspaceInformation({ mastraEntryFile: mastraEntry });
  let externalsPreset = false;
  const userExternals = Array.isArray(bundlerOptions?.externals) ? bundlerOptions?.externals : [];
  if (bundlerOptions?.externals === true) {
    externalsPreset = true;
  }
  let index = 0;
  const depsToOptimize = /* @__PURE__ */ new Map();
  const allExternals = [...GLOBAL_EXTERNALS, ...userExternals].filter(Boolean);
  logger.info("Analyzing dependencies...");
  const allUsedExternals = /* @__PURE__ */ new Map();
  for (const entry of entries) {
    const isVirtualFile = entry.includes("\n") || !existsSync(entry);
    const analyzeResult = await analyzeEntry({ entry, isVirtualFile }, mastraEntry, {
      logger,
      sourcemapEnabled: bundlerOptions?.enableSourcemap ?? false,
      workspaceMap,
      projectRoot,
      shouldCheckTransitiveDependencies: isDev || externalsPreset
    });
    await writeFile(join(outputDir, `entry-${index++}.mjs`), analyzeResult.output.code);
    for (const [dep, metadata] of analyzeResult.dependencies.entries()) {
      const isPartOfExternals = allExternals.some((external) => isDependencyPartOfPackage(dep, external));
      if (isPartOfExternals || externalsPreset && !metadata.isWorkspace) {
        const pkgName = getPackageName(dep);
        if (pkgName && !allUsedExternals.has(pkgName)) {
          allUsedExternals.set(pkgName, {
            version: metadata.version
          });
        }
        continue;
      }
      if (depsToOptimize.has(dep)) {
        const existingEntry = depsToOptimize.get(dep);
        depsToOptimize.set(dep, {
          ...existingEntry,
          exports: [.../* @__PURE__ */ new Set([...existingEntry.exports, ...metadata.exports])]
        });
      } else {
        depsToOptimize.set(dep, metadata);
      }
    }
  }
  if (isDev || externalsPreset) {
    for (const [dep, metadata] of depsToOptimize.entries()) {
      if (!metadata.isWorkspace) {
        depsToOptimize.delete(dep);
      }
    }
  }
  const sortedDeps = Array.from(depsToOptimize.keys()).sort();
  logger.info("Optimizing dependencies...");
  logger.debug(`${sortedDeps.map((key) => `- ${key}`).join("\n")}`);
  const { output, fileNameToDependencyMap, usedExternals } = await bundleExternals(depsToOptimize, outputDir, {
    bundlerOptions: {
      ...bundlerOptions,
      externals: bundlerOptions?.externals ?? allExternals,
      isDev
    },
    projectRoot,
    workspaceRoot,
    workspaceMap
  });
  const relativeWorkspaceFolderPaths = Array.from(workspaceMap.values()).map(
    (pkgInfo) => slash(relative(workspaceRoot || projectRoot, pkgInfo.location))
  );
  const depsVersionInfo = /* @__PURE__ */ new Map();
  for (const [dep, metadata] of depsToOptimize.entries()) {
    const pkgName = getPackageName(dep);
    if (pkgName && metadata.version) {
      depsVersionInfo.set(pkgName, {
        version: metadata.version
      });
    }
    if (metadata.version) {
      depsVersionInfo.set(dep, {
        version: metadata.version
      });
    }
  }
  for (const o of output) {
    if (o.type === "asset") {
      continue;
    }
    for (const i of o.imports) {
      if (isBuiltinModule(i)) {
        continue;
      }
      if (i.startsWith(".") || i.startsWith("/")) {
        continue;
      }
      if (relativeWorkspaceFolderPaths.some((workspacePath) => i.startsWith(workspacePath))) {
        continue;
      }
      const pkgName = getPackageName(i);
      if (pkgName && !allUsedExternals.has(pkgName)) {
        const versionInfo = depsVersionInfo.get(i) || depsVersionInfo.get(pkgName) || {};
        allUsedExternals.set(pkgName, versionInfo);
      }
    }
  }
  const result = await validateOutput(
    {
      output,
      reverseVirtualReferenceMap: fileNameToDependencyMap,
      usedExternals,
      outputDir,
      projectRoot: workspaceRoot || projectRoot,
      workspaceMap,
      depsVersionInfo
    },
    logger
  );
  const mergedExternalDeps = new Map(result.externalDependencies);
  for (const [dep, info] of allUsedExternals) {
    const existing = mergedExternalDeps.get(dep);
    if (!existing || !existing.version && info.version) {
      mergedExternalDeps.set(dep, info);
    }
  }
  return {
    ...result,
    externalDependencies: mergedExternalDeps
  };
}

export { aliasHono, analyzeBundle, getWorkspaceInformation };
//# sourceMappingURL=chunk-CAHLKF47.js.map
//# sourceMappingURL=chunk-CAHLKF47.js.map