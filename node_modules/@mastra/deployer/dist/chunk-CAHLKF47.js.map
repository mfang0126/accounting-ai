{"version":3,"sources":["../../../node_modules/.pnpm/stacktrace-parser@0.1.11/node_modules/stacktrace-parser/dist/stack-trace-parser.esm.js","../src/bundler/workspaceDependencies.ts","../src/validator/validate.ts","../src/build/isNodeBuiltin.ts","../src/build/analyze/constants.ts","../src/build/analyze/analyzeEntry.ts","../src/build/plugins/hono-alias.ts","../src/build/plugins/module-resolve-map.ts","../src/build/plugins/node-gyp-detector.ts","../src/build/analyze/bundleExternals.ts","../src/build/babel/check-config-export.ts","../src/build/analyze.ts"],"names":["resolve","nodeSpawn","dirname","pkg","pathToFileURL","path","fileURLToPath","join","exports","getInputPlugins","virtual","commonjs","json","getPackageInfo","rollup","moduleResolveMap","o","babel","ErrorDomain","ErrorCategory","basename","err","readFile","babel2"],"mappings":"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","file":"chunk-CAHLKF47.js","sourcesContent":["var UNKNOWN_FUNCTION = '<unknown>';\n/**\n * This parses the different stack traces and puts them into one format\n * This borrows heavily from TraceKit (https://github.com/csnover/TraceKit)\n */\n\nfunction parse(stackString) {\n  var lines = stackString.split('\\n');\n  return lines.reduce(function (stack, line) {\n    var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);\n\n    if (parseResult) {\n      stack.push(parseResult);\n    }\n\n    return stack;\n  }, []);\n}\nvar chromeRe = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\\/|[a-z]:\\\\|\\\\\\\\).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nvar chromeEvalRe = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n\nfunction parseChrome(line) {\n  var parts = chromeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n\n  var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n  var submatch = chromeEvalRe.exec(parts[2]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line/column number\n    parts[2] = submatch[1]; // url\n\n    parts[3] = submatch[2]; // line\n\n    parts[4] = submatch[3]; // column\n  }\n\n  return {\n    file: !isNative ? parts[2] : null,\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: isNative ? [parts[2]] : [],\n    lineNumber: parts[3] ? +parts[3] : null,\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar winjsRe = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseWinjs(line) {\n  var parts = winjsRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nvar geckoRe = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\\[native).*?|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nvar geckoEvalRe = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n\nfunction parseGecko(line) {\n  var parts = geckoRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n  var submatch = geckoEvalRe.exec(parts[3]);\n\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line number\n    parts[3] = submatch[1];\n    parts[4] = submatch[2];\n    parts[5] = null; // no column when eval\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: parts[2] ? parts[2].split(',') : [],\n    lineNumber: parts[4] ? +parts[4] : null,\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar javaScriptCoreRe = /^\\s*(?:([^@]*)(?:\\((.*?)\\))?@)?(\\S.*?):(\\d+)(?::(\\d+))?\\s*$/i;\n\nfunction parseJSC(line) {\n  var parts = javaScriptCoreRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[3],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[4],\n    column: parts[5] ? +parts[5] : null\n  };\n}\n\nvar nodeRe = /^\\s*at (?:((?:\\[object object\\])?[^\\\\/]+(?: \\[as \\S+\\])?) )?\\(?(.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n\nfunction parseNode(line) {\n  var parts = nodeRe.exec(line);\n\n  if (!parts) {\n    return null;\n  }\n\n  return {\n    file: parts[2],\n    methodName: parts[1] || UNKNOWN_FUNCTION,\n    arguments: [],\n    lineNumber: +parts[3],\n    column: parts[4] ? +parts[4] : null\n  };\n}\n\nexport { parse };\n","import { join, dirname } from 'node:path';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport slugify from '@sindresorhus/slugify';\nimport * as pkg from 'empathic/package';\nimport { findWorkspaces, findWorkspacesRoot, createWorkspacesCache } from 'find-workspaces';\nimport { ensureDir } from 'fs-extra';\nimport { slash } from '../build/utils';\nimport { DepsService } from '../services';\n\nexport type WorkspacePackageInfo = {\n  location: string;\n  dependencies: Record<string, string> | undefined;\n  version: string | undefined;\n};\n\ntype TransitiveDependencyResult = {\n  resolutions: Record<string, string>;\n  usedWorkspacePackages: Set<string>;\n};\n\n/**\n * Create a shared cache for find-workspaces\n */\nconst workspacesCache = createWorkspacesCache();\n\n/**\n * A utility function around find-workspaces to get information about:\n * - Which workspace packages are available in the project\n * - What is the workspace root location\n * - Is the current package a workspace package\n *\n * Because `findWorkspacesRoot` only traverses up until it finds workspace information, but doesn't check if the current package is even part of the workspace. We rather want to return `null` for these cases because in other code paths we use `workspaceRoot || projectRoot` to determine the root of the project.\n *\n * @params dir - The directory to start searching from (default: `process.cwd()`)\n * @params location - The location of the current package (usually the directory containing the package.json)\n */\nexport async function getWorkspaceInformation({\n  dir = process.cwd(),\n  mastraEntryFile,\n}: {\n  dir?: string;\n  mastraEntryFile: string;\n}) {\n  // 1) Get the location of the current package and its package.json\n  const closestPkgJson = pkg.up({ cwd: dirname(mastraEntryFile) });\n  const location = closestPkgJson ? dirname(slash(closestPkgJson)) : slash(process.cwd());\n\n  // 2) Get all workspaces\n  const workspaces = await findWorkspaces(dir, { cache: workspacesCache });\n  const _workspaceMap = new Map(\n    workspaces?.map(workspace => [\n      workspace.package.name,\n      {\n        location: workspace.location,\n        dependencies: workspace.package.dependencies,\n        version: workspace.package.version,\n      },\n    ]) ?? [],\n  );\n\n  // 3) Check if the current package is part of the workspace\n  const isWorkspacePackage = (workspaces ?? []).some(ws => ws.location === location);\n\n  // 4) Get the workspace root only if the current package is part of the workspace\n  const workspaceRoot = isWorkspacePackage ? findWorkspacesRoot(dir, { cache: workspacesCache })?.location : undefined;\n\n  return {\n    // If the current package is not part of the workspace, the bundling down the line shouldn't look at any workspace packages\n    workspaceMap: isWorkspacePackage ? _workspaceMap : new Map<string, WorkspacePackageInfo>(),\n    workspaceRoot,\n    isWorkspacePackage,\n  };\n}\n\n/**\n * Collects all transitive workspace dependencies and their TGZ paths\n */\nexport const collectTransitiveWorkspaceDependencies = ({\n  workspaceMap,\n  initialDependencies,\n  logger,\n}: {\n  workspaceMap: Map<string, WorkspacePackageInfo>;\n  initialDependencies: Set<string>;\n  logger: IMastraLogger;\n}): TransitiveDependencyResult => {\n  const usedWorkspacePackages = new Set<string>();\n  const queue: string[] = Array.from(initialDependencies);\n  const resolutions: Record<string, string> = {};\n\n  while (queue.length > 0) {\n    const len = queue.length;\n    for (let i = 0; i < len; i += 1) {\n      const pkgName = queue.shift();\n      if (!pkgName || usedWorkspacePackages.has(pkgName)) {\n        continue;\n      }\n\n      const dep = workspaceMap.get(pkgName);\n      if (!dep) continue;\n\n      const root = findWorkspacesRoot();\n      if (!root) {\n        throw new Error('Could not find workspace root');\n      }\n\n      const depsService = new DepsService(root.location);\n      depsService.__setLogger(logger);\n      const sanitizedName = slugify(pkgName);\n\n      const tgzPath = depsService.getWorkspaceDependencyPath({\n        pkgName: sanitizedName,\n        version: dep.version!,\n      });\n      resolutions[pkgName] = tgzPath;\n      usedWorkspacePackages.add(pkgName);\n\n      for (const [depName, _depVersion] of Object.entries(dep?.dependencies ?? {})) {\n        if (!usedWorkspacePackages.has(depName) && workspaceMap.has(depName)) {\n          queue.push(depName);\n        }\n      }\n    }\n  }\n\n  return { resolutions, usedWorkspacePackages };\n};\n\n/**\n * Creates TGZ packages for workspace dependencies in the workspace-module directory\n */\nexport const packWorkspaceDependencies = async ({\n  workspaceMap,\n  usedWorkspacePackages,\n  bundleOutputDir,\n  logger,\n}: {\n  workspaceMap: Map<string, WorkspacePackageInfo>;\n  bundleOutputDir: string;\n  logger: IMastraLogger;\n  usedWorkspacePackages: Set<string>;\n}): Promise<void> => {\n  const root = findWorkspacesRoot();\n  if (!root) {\n    throw new Error('Could not find workspace root');\n  }\n\n  const depsService = new DepsService(root.location);\n  depsService.__setLogger(logger);\n\n  // package all workspace dependencies\n  if (usedWorkspacePackages.size > 0) {\n    const workspaceDirPath = join(bundleOutputDir, 'workspace-module');\n    await ensureDir(workspaceDirPath);\n\n    logger.info(`Packaging ${usedWorkspacePackages.size} workspace dependencies...`);\n\n    const batchSize = 5;\n    const packages = Array.from(usedWorkspacePackages.values());\n\n    for (let i = 0; i < packages.length; i += batchSize) {\n      const batch = packages.slice(i, i + batchSize);\n      logger.info(\n        `Packaging batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(packages.length / batchSize)}: ${batch.join(', ')}`,\n      );\n      await Promise.all(\n        batch.map(async pkgName => {\n          const dep = workspaceMap.get(pkgName);\n          const sanitizedName = slugify(pkgName);\n          if (!dep) return;\n\n          await depsService.pack({ dir: dep.location, destination: workspaceDirPath, sanitizedName: sanitizedName });\n        }),\n      );\n    }\n\n    logger.info(`Successfully packaged ${usedWorkspacePackages.size} workspace dependencies`);\n  }\n};\n","import { spawn as nodeSpawn } from 'node:child_process';\nimport type { SpawnOptions } from 'node:child_process';\nimport { dirname } from 'node:path';\nimport { pathToFileURL } from 'node:url';\n\ntype ValidationArgs = {\n  message: string;\n  type: string;\n  stack: string;\n};\n\nexport class ValidationError extends Error {\n  public readonly type: string;\n  public readonly stack: string;\n  constructor(args: ValidationArgs) {\n    super(args.message);\n    this.type = args.type;\n    this.stack = args.stack;\n  }\n}\n\n/**\n * Promisified version of Node.js spawn function\n *\n * @param command - The command to run\n * @param args - List of string arguments\n * @param options - Spawn options\n * @returns Promise that resolves with the exit code when the process completes\n */\nfunction spawn(command: string, args: string[] = [], options: SpawnOptions = {}): Promise<void> {\n  return new Promise((resolve, reject) => {\n    let validationError: ValidationArgs | null = null;\n    const childProcess = nodeSpawn(command, args, {\n      // stdio: 'inherit',\n      ...options,\n    });\n\n    childProcess.on('error', error => {\n      reject(error);\n    });\n\n    let stderr = '';\n    childProcess.stderr?.on('data', message => {\n      try {\n        validationError = JSON.parse(message.toString());\n      } catch {\n        stderr += message;\n      }\n    });\n\n    childProcess.on('close', code => {\n      if (code === 0) {\n        resolve();\n      } else {\n        if (validationError) {\n          reject(new ValidationError(validationError));\n        } else {\n          reject(new Error(stderr));\n        }\n      }\n    });\n  });\n}\n\nexport function validate(\n  file: string,\n  { injectESMShim = false, moduleResolveMapLocation }: { injectESMShim?: boolean; moduleResolveMapLocation: string },\n) {\n  let prefixCode = '';\n  if (injectESMShim) {\n    prefixCode = `import { fileURLToPath } from 'url';\nimport { dirname } from 'path';\n\nglobalThis.__filename = fileURLToPath(import.meta.url);\nglobalThis.__dirname = dirname(__filename);\n    `;\n  }\n\n  // Used to log a proper error we can parse instead of trying to do some fancy string grepping\n  function errorHandler(err: Error) {\n    console.error(\n      JSON.stringify({\n        type: err.name,\n        message: err.message,\n        stack: err.stack,\n      }),\n    );\n    process.exit(1);\n  }\n\n  return spawn(\n    process.execPath,\n    [\n      '--import',\n      import.meta.resolve('@mastra/deployer/loader'),\n      '--input-type=module',\n      '--enable-source-maps',\n      '-e',\n      `${prefixCode};import('${pathToFileURL(file).href}').catch(err => {\n        ${errorHandler.toString()}\n        errorHandler(err);\n      })`.replaceAll(/\\n/g, ''),\n    ],\n    {\n      env: {\n        ...process.env,\n        MODULE_MAP: `${moduleResolveMapLocation}`,\n      },\n      cwd: dirname(file),\n    },\n  );\n}\n","import { builtinModules } from 'node:module';\n\nexport function isNodeBuiltin(dep: string): boolean {\n  const [pkg] = dep.split('/');\n\n  return dep.startsWith('node:') || builtinModules.includes(dep) || builtinModules.includes(pkg!);\n}\n","export const DEPS_TO_IGNORE = ['#tools'];\n\nexport const GLOBAL_EXTERNALS = [\n  'pino',\n  'pino-pretty',\n  '@libsql/client',\n  'pg',\n  'libsql',\n  '#tools',\n  'typescript',\n  'undici',\n  'readable-stream',\n];\nexport const DEPRECATED_EXTERNALS = ['fastembed', 'nodemailer', 'jsdom', 'sqlite3'];\n","import { fileURLToPath, pathToFileURL } from 'node:url';\nimport { noopLogger } from '@mastra/core/logger';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport commonjs from '@rollup/plugin-commonjs';\nimport json from '@rollup/plugin-json';\nimport virtual from '@rollup/plugin-virtual';\nimport { readJSON } from 'fs-extra/esm';\nimport { resolveModule } from 'local-pkg';\nimport { rollup } from 'rollup';\nimport type { OutputChunk, Plugin, SourceMap } from 'rollup';\nimport type { WorkspacePackageInfo } from '../../bundler/workspaceDependencies';\nimport { isNodeBuiltin } from '../isNodeBuiltin';\nimport { getPackageRootPath } from '../package-info';\nimport { esbuild } from '../plugins/esbuild';\nimport { removeDeployer } from '../plugins/remove-deployer';\nimport { tsConfigPaths } from '../plugins/tsconfig-paths';\nimport type { DependencyMetadata } from '../types';\nimport { getPackageName, slash } from '../utils';\nimport { DEPS_TO_IGNORE } from './constants';\n\n/**\n * Configures and returns the Rollup plugins needed for analyzing entry files.\n * Sets up module resolution, transpilation, and custom alias handling for Mastra-specific imports.\n */\nfunction getInputPlugins(\n  { entry, isVirtualFile }: { entry: string; isVirtualFile: boolean },\n  mastraEntry: string,\n  { sourcemapEnabled }: { sourcemapEnabled: boolean },\n): Plugin[] {\n  const normalizedMastraEntry = slash(mastraEntry);\n  let virtualPlugin = null;\n  if (isVirtualFile) {\n    virtualPlugin = virtual({\n      '#entry': entry,\n    });\n    entry = '#entry';\n  }\n\n  const plugins = [];\n  if (virtualPlugin) {\n    plugins.push(virtualPlugin);\n  }\n\n  plugins.push(\n    ...[\n      tsConfigPaths(),\n      {\n        name: 'custom-alias-resolver',\n        resolveId(id: string) {\n          if (id === '#server') {\n            return slash(fileURLToPath(import.meta.resolve('@mastra/deployer/server')));\n          }\n          if (id === '#mastra') {\n            return normalizedMastraEntry;\n          }\n          if (id.startsWith('@mastra/server')) {\n            return fileURLToPath(import.meta.resolve(id));\n          }\n        },\n      } satisfies Plugin,\n      json(),\n      esbuild(),\n      commonjs({\n        strictRequires: 'debug',\n        ignoreTryCatch: false,\n        transformMixedEsModules: true,\n        extensions: ['.js', '.ts'],\n      }),\n      removeDeployer(mastraEntry, {\n        sourcemap: sourcemapEnabled,\n      }),\n      esbuild(),\n    ],\n  );\n\n  return plugins;\n}\n\n/**\n * Extracts and categorizes dependencies from Rollup output to determine which ones need optimization.\n * Analyzes both static imports and dynamic imports while filtering out Node.js built-ins and ignored dependencies.\n * Identifies workspace packages and resolves package root paths for proper bundling optimization.\n */\nasync function captureDependenciesToOptimize(\n  output: OutputChunk,\n  workspaceMap: Map<string, WorkspacePackageInfo>,\n  projectRoot: string,\n  initialDepsToOptimize: Map<string, DependencyMetadata>,\n  {\n    logger,\n    shouldCheckTransitiveDependencies,\n  }: {\n    logger: IMastraLogger;\n    shouldCheckTransitiveDependencies: boolean;\n  },\n): Promise<Map<string, DependencyMetadata>> {\n  const depsToOptimize = new Map<string, DependencyMetadata>();\n\n  if (!output.facadeModuleId) {\n    throw new Error(\n      'Something went wrong, we could not find the package name of the entry file. Please open an issue.',\n    );\n  }\n\n  let entryRootPath = projectRoot;\n  if (!output.facadeModuleId.startsWith('\\x00virtual:')) {\n    entryRootPath = (await getPackageRootPath(output.facadeModuleId)) || projectRoot;\n  }\n\n  for (const [dependency, bindings] of Object.entries(output.importedBindings)) {\n    if (isNodeBuiltin(dependency) || dependency.startsWith('#')) {\n      continue;\n    }\n\n    // The `getPackageName` helper also handles subpaths so we only get the proper package name\n    const pkgName = getPackageName(dependency);\n    let rootPath: string | null = null;\n    let isWorkspace = false;\n    let version: string | undefined;\n\n    if (pkgName) {\n      rootPath = await getPackageRootPath(dependency, entryRootPath);\n      isWorkspace = workspaceMap.has(pkgName);\n\n      // Read version from package.json when we have a valid rootPath\n      if (rootPath) {\n        try {\n          const pkgJson = await readJSON(`${rootPath}/package.json`);\n          version = pkgJson.version;\n        } catch {\n          // Failed to read package.json, version will remain undefined\n        }\n      }\n    }\n\n    const normalizedRootPath = rootPath ? slash(rootPath) : null;\n\n    depsToOptimize.set(dependency, {\n      exports: bindings,\n      rootPath: normalizedRootPath,\n      isWorkspace,\n      version,\n    });\n  }\n\n  /**\n   * Recursively discovers and analyzes transitive workspace dependencies\n   */\n  async function checkTransitiveDependencies(\n    internalMap: Map<string, DependencyMetadata>,\n    maxDepth = 10,\n    currentDepth = 0,\n  ) {\n    // Could be a circular dependency...\n    if (currentDepth >= maxDepth) {\n      logger.warn('Maximum dependency depth reached while checking transitive dependencies.');\n      return;\n    }\n\n    // Make a copy so that we can safely iterate over it\n    const depsSnapshot = new Map(depsToOptimize);\n    let hasAddedDeps = false;\n\n    for (const [dep, meta] of depsSnapshot) {\n      // We only care about workspace deps that we haven't already processed\n      if (!meta.isWorkspace || internalMap.has(dep)) {\n        continue;\n      }\n\n      try {\n        const importerPath = output.facadeModuleId\n          ? pathToFileURL(output.facadeModuleId).href\n          : pathToFileURL(projectRoot).href;\n        // Absolute path to the dependency using ESM-compatible resolution\n        const resolvedPath = resolveModule(dep, {\n          paths: [importerPath],\n        });\n        if (!resolvedPath) {\n          logger.warn(`Could not resolve path for workspace dependency ${dep}`);\n          continue;\n        }\n\n        const analysis = await analyzeEntry({ entry: resolvedPath, isVirtualFile: false }, '', {\n          workspaceMap,\n          projectRoot,\n          logger: noopLogger,\n          sourcemapEnabled: false,\n          initialDepsToOptimize: depsToOptimize,\n        });\n\n        if (!analysis?.dependencies) {\n          continue;\n        }\n\n        for (const [innerDep, innerMeta] of analysis.dependencies) {\n          /**\n           * Only add to depsToOptimize if:\n           * - It's a workspace package\n           * - We haven't already processed it\n           * - We haven't already discovered it at the beginning\n           */\n          if (innerMeta.isWorkspace && !internalMap.has(innerDep) && !depsToOptimize.has(innerDep)) {\n            depsToOptimize.set(innerDep, innerMeta);\n            internalMap.set(innerDep, innerMeta);\n            hasAddedDeps = true;\n          }\n        }\n      } catch (err) {\n        logger.error(`Failed to resolve or analyze dependency ${dep}: ${(err as Error).message}`);\n      }\n    }\n\n    // Continue until no new deps are found\n    if (hasAddedDeps) {\n      await checkTransitiveDependencies(internalMap, maxDepth, currentDepth + 1);\n    }\n  }\n\n  if (shouldCheckTransitiveDependencies) {\n    await checkTransitiveDependencies(initialDepsToOptimize);\n  }\n\n  // #tools is a generated dependency, we don't want our analyzer to handle it\n  const dynamicImports = output.dynamicImports.filter(d => !DEPS_TO_IGNORE.includes(d));\n  if (dynamicImports.length) {\n    for (const dynamicImport of dynamicImports) {\n      if (!depsToOptimize.has(dynamicImport) && !isNodeBuiltin(dynamicImport)) {\n        // Try to resolve version for dynamic imports as well\n        const pkgName = getPackageName(dynamicImport);\n        let version: string | undefined;\n        let rootPath: string | null = null;\n\n        if (pkgName) {\n          rootPath = await getPackageRootPath(dynamicImport, entryRootPath);\n          if (rootPath) {\n            try {\n              const pkgJson = await readJSON(`${rootPath}/package.json`);\n              version = pkgJson.version;\n            } catch {\n              // Failed to read package.json\n            }\n          }\n        }\n\n        depsToOptimize.set(dynamicImport, {\n          exports: ['*'],\n          rootPath: rootPath ? slash(rootPath) : null,\n          isWorkspace: false,\n          version,\n        });\n      }\n    }\n  }\n\n  return depsToOptimize;\n}\n\n/**\n * Analyzes the entry file to identify external dependencies and their imports. This allows us to treeshake all code that is not used.\n *\n * @param entryConfig - Configuration object for the entry file\n * @param entryConfig.entry - The entry file path or content\n * @param entryConfig.isVirtualFile - Whether the entry is a virtual file (content string) or a file path\n * @param mastraEntry - The mastra entry point\n * @param options - Configuration options for the analysis\n * @param options.logger - Logger instance for debugging\n * @param options.sourcemapEnabled - Whether sourcemaps are enabled\n * @param options.workspaceMap - Map of workspace packages\n * @param options.shouldCheckTransitiveDependencies - Whether to recursively analyze transitive workspace dependencies (default: false)\n * @returns A promise that resolves to an object containing the analyzed dependencies and generated output\n */\nexport async function analyzeEntry(\n  {\n    entry,\n    isVirtualFile,\n  }: {\n    entry: string;\n    isVirtualFile: boolean;\n  },\n  mastraEntry: string,\n  {\n    logger,\n    sourcemapEnabled,\n    workspaceMap,\n    projectRoot,\n    initialDepsToOptimize = new Map(), // used to avoid infinite recursion\n    shouldCheckTransitiveDependencies = false,\n  }: {\n    logger: IMastraLogger;\n    sourcemapEnabled: boolean;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n    projectRoot: string;\n    initialDepsToOptimize?: Map<string, DependencyMetadata>;\n    shouldCheckTransitiveDependencies?: boolean;\n  },\n): Promise<{\n  dependencies: Map<string, DependencyMetadata>;\n  output: {\n    code: string;\n    map: SourceMap | null;\n  };\n}> {\n  const optimizerBundler = await rollup({\n    logLevel: process.env.MASTRA_BUNDLER_DEBUG === 'true' ? 'debug' : 'silent',\n    input: isVirtualFile ? '#entry' : entry,\n    treeshake: false,\n    preserveSymlinks: true,\n    plugins: getInputPlugins({ entry, isVirtualFile }, mastraEntry, { sourcemapEnabled }),\n    external: DEPS_TO_IGNORE,\n  });\n\n  const { output } = await optimizerBundler.generate({\n    format: 'esm',\n    inlineDynamicImports: true,\n  });\n\n  await optimizerBundler.close();\n\n  const depsToOptimize = await captureDependenciesToOptimize(\n    output[0] as OutputChunk,\n    workspaceMap,\n    projectRoot,\n    initialDepsToOptimize,\n    {\n      logger,\n      shouldCheckTransitiveDependencies,\n    },\n  );\n\n  return {\n    dependencies: depsToOptimize,\n    output: {\n      code: output[0].code,\n      map: output[0].map as SourceMap,\n    },\n  };\n}\n","import { fileURLToPath } from 'node:url';\nimport type { Plugin } from 'rollup';\n\n// hono is imported from deployer, so we need to resolve from here instead of the project root\nexport function aliasHono(): Plugin {\n  return {\n    name: 'hono-alias',\n    resolveId(id: string) {\n      if (!id.startsWith('@hono/') && !id.startsWith('hono/') && id !== 'hono' && id !== 'hono-openapi') {\n        return;\n      }\n\n      const path = import.meta.resolve(id);\n      return fileURLToPath(path);\n    },\n  } satisfies Plugin;\n}\n","import { join } from 'node:path';\nimport { pathToFileURL } from 'node:url';\nimport type { Plugin } from 'rollup';\nimport { isDependencyPartOfPackage, slash } from '../utils';\n\nexport function moduleResolveMap(externals: string[], projectRoot: string): Plugin {\n  const importMap = new Map<string, string>();\n  return {\n    name: 'module-resolve-map',\n    moduleParsed(info) {\n      if (info.importedIds.length === 0 || !info.id) {\n        return;\n      }\n\n      for (const importedId of info.importedIds) {\n        for (const external of externals) {\n          if (isDependencyPartOfPackage(importedId, external)) {\n            // TODO add multi version support\n            importMap.set(external, info.id);\n          }\n        }\n      }\n    },\n\n    async generateBundle(options, bundle) {\n      const resolveMap = new Map<string, Map<string, string>>();\n\n      // Iterate through all output chunks\n      for (const [fileName, chunk] of Object.entries(bundle)) {\n        // Only chunks have modules, assets don't\n        if (chunk.type === 'chunk') {\n          for (const [external, resolvedFrom] of importMap) {\n            if (chunk.moduleIds.includes(resolvedFrom)) {\n              const fullPath = pathToFileURL(slash(join(projectRoot, fileName))).toString();\n              const innerMap = resolveMap.get(fullPath) || new Map<string, string>();\n              innerMap.set(external, pathToFileURL(slash(resolvedFrom)).toString());\n              resolveMap.set(fullPath, innerMap);\n            }\n          }\n        }\n      }\n\n      // store all binaries used by a module to show in the error message\n      const resolveMapJson = Object.fromEntries(\n        Array.from(resolveMap.entries()).map(([key, value]) => [key, Object.fromEntries(value.entries())]),\n      );\n\n      this.emitFile({\n        type: 'asset',\n        name: 'module-resolve-map.json',\n        source: `${JSON.stringify(resolveMapJson, null, 2)}`,\n      });\n    },\n  } satisfies Plugin;\n}\n","import { getPackageInfo } from 'local-pkg';\nimport type { Plugin } from 'rollup';\n\nexport function nodeGypDetector(): Plugin {\n  const modulesToTrack = new Set<string>();\n  const modulesToTrackPackageInfo = new Map<string, ReturnType<typeof getPackageInfo>>();\n\n  return {\n    name: 'node-gyp-build-detector',\n    moduleParsed(info) {\n      if (!info.meta?.commonjs?.requires?.length) {\n        return;\n      }\n\n      const hasNodeGypBuild = info.meta.commonjs.requires.some((m: { resolved?: { id: string } }) =>\n        m?.resolved?.id.endsWith('node-gyp-build/index.js'),\n      );\n      if (!hasNodeGypBuild) {\n        return;\n      }\n\n      modulesToTrack.add(info.id);\n      modulesToTrackPackageInfo.set(info.id, getPackageInfo(info.id));\n    },\n\n    async generateBundle(options, bundle) {\n      const binaryMapByChunk = new Map<string, Set<string>>();\n      // Iterate through all output chunks\n      for (const [fileName, chunk] of Object.entries(bundle)) {\n        // Only chunks have modules, assets don't\n        if (chunk.type === 'chunk') {\n          for (const moduleId of chunk.moduleIds) {\n            if (modulesToTrackPackageInfo.has(moduleId)) {\n              const pkgInfo = await modulesToTrackPackageInfo.get(moduleId)!;\n\n              if (!binaryMapByChunk.has(fileName)) {\n                binaryMapByChunk.set(fileName, new Set());\n              }\n\n              if (pkgInfo?.packageJson?.name) {\n                binaryMapByChunk.get(fileName)!.add(pkgInfo.packageJson.name);\n              }\n            }\n          }\n        }\n      }\n\n      const binaryMapJson = Object.fromEntries(\n        Array.from(binaryMapByChunk.entries()).map(([key, value]) => [key, Array.from(value)]),\n      );\n\n      // store all binaries used by a module to show in the error message\n      this.emitFile({\n        type: 'asset',\n        name: 'binary-map.json',\n        source: `${JSON.stringify(binaryMapJson, null, 2)}`,\n      });\n    },\n  } satisfies Plugin;\n}\n","import { readFile } from 'node:fs/promises';\nimport * as path from 'node:path';\nimport { basename } from 'node:path/posix';\nimport { ErrorCategory, ErrorDomain, MastraBaseError } from '@mastra/core/error';\nimport type { Config } from '@mastra/core/mastra';\nimport { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';\nimport commonjs from '@rollup/plugin-commonjs';\nimport json from '@rollup/plugin-json';\nimport nodeResolve from '@rollup/plugin-node-resolve';\nimport virtual from '@rollup/plugin-virtual';\nimport { getPackageInfo } from 'local-pkg';\nimport * as resolve from 'resolve.exports';\nimport { rollup } from 'rollup';\nimport type { OutputChunk, OutputAsset, Plugin } from 'rollup';\nimport type { WorkspacePackageInfo } from '../../bundler/workspaceDependencies';\nimport { getPackageRootPath } from '../package-info';\nimport { esbuild } from '../plugins/esbuild';\nimport { esmShim } from '../plugins/esm-shim';\nimport { aliasHono } from '../plugins/hono-alias';\nimport { moduleResolveMap } from '../plugins/module-resolve-map';\nimport { nodeGypDetector } from '../plugins/node-gyp-detector';\nimport { subpathExternalsResolver } from '../plugins/subpath-externals-resolver';\nimport { tsConfigPaths } from '../plugins/tsconfig-paths';\nimport type { DependencyMetadata } from '../types';\nimport { getCompiledDepCachePath, isDependencyPartOfPackage, rollupSafeName, slash } from '../utils';\nimport { DEPS_TO_IGNORE, GLOBAL_EXTERNALS, DEPRECATED_EXTERNALS } from './constants';\n\ntype VirtualDependency = {\n  name: string;\n  virtual: string;\n};\n\nfunction prepareEntryFileName(name: string, rootDir: string) {\n  return rollupSafeName(name, rootDir);\n}\n\n/**\n * Creates virtual dependency modules for optimized bundling by generating virtual entry points for each dependency with their specific exports and handling workspace package path resolution.\n */\nexport function createVirtualDependencies(\n  depsToOptimize: Map<string, DependencyMetadata>,\n  {\n    projectRoot,\n    workspaceRoot,\n    outputDir,\n    bundlerOptions,\n  }: {\n    workspaceRoot: string | null;\n    projectRoot: string;\n    outputDir: string;\n    bundlerOptions?: { isDev?: boolean; externalsPreset?: boolean };\n  },\n): {\n  optimizedDependencyEntries: Map<string, VirtualDependency>;\n  fileNameToDependencyMap: Map<string, string>;\n} {\n  const { isDev = false, externalsPreset = false } = bundlerOptions || {};\n  const fileNameToDependencyMap = new Map<string, string>();\n  const optimizedDependencyEntries = new Map<string, VirtualDependency>();\n  const rootDir = workspaceRoot || projectRoot;\n\n  for (const [dep, { exports }] of depsToOptimize.entries()) {\n    // Use __ as separator to avoid conflicts with hyphens in package names\n    // e.g., @inner/inner-tools -> @inner__inner-tools (preserves the hyphen)\n    const fileName = dep.replaceAll('/', '__');\n    const virtualFile: string[] = [];\n    const exportStringBuilder = [];\n\n    for (const local of exports) {\n      if (local === '*') {\n        virtualFile.push(`export * from '${dep}';`);\n        continue;\n      } else if (local === 'default') {\n        exportStringBuilder.push('default');\n      } else {\n        exportStringBuilder.push(local);\n      }\n    }\n\n    const chunks = [];\n    if (exportStringBuilder.length) {\n      chunks.push(`{ ${exportStringBuilder.join(', ')} }`);\n    }\n    if (chunks.length) {\n      virtualFile.push(`export ${chunks.join(', ')} from '${dep}';`);\n    }\n\n    // Determine the entry name based on the complexity of exports\n    let entryName = prepareEntryFileName(path.join(outputDir, fileName), rootDir);\n\n    fileNameToDependencyMap.set(entryName, dep);\n    optimizedDependencyEntries.set(dep, {\n      name: entryName,\n      virtual: virtualFile.join('\\n'),\n    });\n  }\n\n  // For workspace packages, we still want the dependencies to be imported from the original path\n  // We rewrite the path to the original folder inside node_modules/.cache\n  if (isDev || externalsPreset) {\n    for (const [dep, { isWorkspace, rootPath }] of depsToOptimize.entries()) {\n      if (!isWorkspace || !rootPath || !workspaceRoot) {\n        continue;\n      }\n\n      const currentDepPath = optimizedDependencyEntries.get(dep);\n      if (!currentDepPath) {\n        continue;\n      }\n\n      const fileName = basename(currentDepPath.name);\n      const entryName = prepareEntryFileName(getCompiledDepCachePath(rootPath, fileName), rootDir);\n\n      fileNameToDependencyMap.set(entryName, dep);\n      optimizedDependencyEntries.set(dep, {\n        ...currentDepPath,\n        name: entryName,\n      });\n    }\n  }\n\n  return { optimizedDependencyEntries, fileNameToDependencyMap };\n}\n\n/**\n * Configures and returns Rollup plugins for bundling external dependencies.\n * Sets up virtual modules, TypeScript compilation, CommonJS transformation, and workspace resolution.\n */\nasync function getInputPlugins(\n  virtualDependencies: Map<string, { name: string; virtual: string }>,\n  {\n    transpilePackages,\n    workspaceMap,\n    bundlerOptions,\n    rootDir,\n    externals,\n  }: {\n    transpilePackages: Set<string>;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n    bundlerOptions: { noBundling: boolean };\n    rootDir: string;\n    externals: string[];\n  },\n) {\n  const transpilePackagesMap = new Map<string, string>();\n  for (const pkg of transpilePackages) {\n    const dir = await getPackageRootPath(pkg);\n\n    if (dir) {\n      transpilePackagesMap.set(pkg, slash(dir));\n    } else {\n      transpilePackagesMap.set(pkg, workspaceMap.get(pkg)?.location ?? pkg);\n    }\n  }\n\n  return [\n    virtual(\n      Array.from(virtualDependencies.entries()).reduce(\n        (acc, [dep, virtualDep]) => {\n          acc[`#virtual-${dep}`] = virtualDep.virtual;\n          return acc;\n        },\n        {} as Record<string, string>,\n      ),\n    ),\n    tsConfigPaths(),\n    subpathExternalsResolver(externals),\n    transpilePackagesMap.size\n      ? esbuild({\n          format: 'esm',\n          include: [\n            // Match files from transpilePackages by their actual directory paths\n            // but exclude any nested node_modules\n            ...[...transpilePackagesMap.values()].map(p => {\n              if (path.isAbsolute(p)) {\n                return new RegExp(`^${p.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}/(?!.*node_modules).*$`);\n              } else {\n                return new RegExp(`\\/${p.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}/(?!.*node_modules).*$`);\n              }\n            }),\n            // Also match workspace packages resolved through node_modules symlinks\n            // (common in pnpm workspaces). Match by package name in node_modules path.\n            ...[...transpilePackagesMap.keys()].map(pkgName => {\n              const escapedPkgName = pkgName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n              return new RegExp(`/node_modules/${escapedPkgName}/(?!.*node_modules).*$`);\n            }),\n          ],\n          // Disable the default /node_modules/ exclusion from rollup-plugin-esbuild.\n          // In pnpm workspaces, nodeResolve resolves workspace packages through node_modules\n          // symlinks, so the resolved paths contain \"node_modules\". Without this, workspace\n          // package .ts files won't be transpiled even if they match the include patterns.\n          exclude: [],\n        })\n      : null,\n    bundlerOptions.noBundling\n      ? ({\n          name: 'alias-optimized-deps',\n          async resolveId(id, importer, options) {\n            if (!virtualDependencies.has(id)) {\n              return null;\n            }\n\n            const info = virtualDependencies.get(id)!;\n            // go from ./node_modules/.cache/index.js to ./pkg\n            const packageRootPath = path.join(rootDir, path.dirname(path.dirname(path.dirname(info.name))));\n            const pkgJsonBuffer = await readFile(path.join(packageRootPath, 'package.json'), 'utf-8');\n            const pkgJson = JSON.parse(pkgJsonBuffer);\n            if (!pkgJson) {\n              return null;\n            }\n\n            const pkgName = pkgJson.name || '';\n            let resolvedPath: string | undefined = resolve.exports(pkgJson, id.replace(pkgName, '.'))?.[0];\n            if (!resolvedPath) {\n              resolvedPath = pkgJson!.main ?? 'index.js';\n            }\n\n            const resolved = await this.resolve(path.posix.join(packageRootPath, resolvedPath!), importer, options);\n            return resolved;\n          },\n        } satisfies Plugin)\n      : null,\n    optimizeLodashImports({\n      include: '**/*.{js,ts,mjs,cjs}',\n    }),\n    commonjs({\n      strictRequires: 'strict',\n      transformMixedEsModules: true,\n      ignoreTryCatch: false,\n    }),\n    bundlerOptions.noBundling\n      ? null\n      : nodeResolve({\n          preferBuiltins: true,\n          exportConditions: ['node'],\n        }),\n    bundlerOptions.noBundling ? esmShim() : null,\n    // hono is imported from deployer, so we need to resolve from here instead of the project root\n    aliasHono(),\n    json(),\n    nodeGypDetector(),\n    moduleResolveMap(externals, rootDir),\n    {\n      name: 'not-found-resolver',\n      resolveId: {\n        order: 'post',\n        async handler(id, importer) {\n          if (!importer) {\n            return null;\n          }\n\n          if (!id.endsWith('.node')) {\n            return null;\n          }\n\n          const pkgInfo = await getPackageInfo(importer);\n          const packageName = pkgInfo?.packageJson?.name || id;\n          throw new MastraBaseError({\n            id: 'DEPLOYER_BUNDLE_EXTERNALS_MISSING_NATIVE_BUILD',\n            domain: ErrorDomain.DEPLOYER,\n            category: ErrorCategory.USER,\n            details: {\n              importFile: importer,\n              packageName,\n            },\n            text: `We found a possible binary dependency in your bundle. ${id} was not found when imported at ${importer}.\n\nPlease consider adding \\`${packageName}\\` to your externals, or updating this import to not end with \".node\".\n\nexport const mastra = new Mastra({\n  bundler: {\n    externals: [\"${packageName}\"],\n  }\n})`,\n          });\n        },\n      },\n    } satisfies Plugin,\n  ].filter(Boolean);\n}\n\n/**\n * Executes the Rollup build process for virtual dependencies using configured plugins.\n * Bundles all virtual dependency modules into optimized ESM files with proper external handling.\n */\nasync function buildExternalDependencies(\n  virtualDependencies: Map<string, VirtualDependency>,\n  {\n    externals,\n    packagesToTranspile,\n    workspaceMap,\n    rootDir,\n    outputDir,\n    bundlerOptions,\n  }: {\n    externals: string[];\n    packagesToTranspile: Set<string>;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n    rootDir: string;\n    outputDir: string;\n    bundlerOptions: {\n      isDev: boolean;\n      externalsPreset: boolean;\n    };\n  },\n) {\n  /**\n   * If there are no virtual dependencies to bundle, return an empty array to avoid Rollup errors.\n   */\n  if (virtualDependencies.size === 0) {\n    return [] as unknown as [OutputChunk, ...(OutputAsset | OutputChunk)[]];\n  }\n\n  const noBundling = bundlerOptions.isDev || bundlerOptions.externalsPreset;\n\n  const plugins = await getInputPlugins(virtualDependencies, {\n    transpilePackages: packagesToTranspile,\n    workspaceMap,\n    bundlerOptions: {\n      noBundling,\n    },\n    rootDir,\n    externals,\n  });\n\n  const bundler = await rollup({\n    logLevel: process.env.MASTRA_BUNDLER_DEBUG === 'true' ? 'debug' : 'silent',\n    input: Array.from(virtualDependencies.entries()).reduce(\n      (acc, [dep, virtualDep]) => {\n        acc[virtualDep.name] = `#virtual-${dep}`;\n        return acc;\n      },\n      {} as Record<string, string>,\n    ),\n    external: externals,\n    treeshake: noBundling ? false : 'safest',\n    plugins,\n  });\n\n  const outputDirRelative = prepareEntryFileName(outputDir, rootDir);\n\n  const { output } = await bundler.write({\n    format: 'esm',\n    dir: rootDir,\n    entryFileNames: '[name].mjs',\n    // used to get the filename of the actual error\n    sourcemap: true,\n    /**\n     * Rollup creates chunks for common dependencies, but these chunks are by default written to the root directory instead of respecting the entryFileNames structure.\n     * So we want to write them to the `.mastra/output` folder as well.\n     */\n    chunkFileNames: chunkInfo => {\n      /**\n       * This whole bunch of logic directly below is for the edge case shown in the e2e-tests/monorepo with \"tinyrainbow\" package. It's used in multiple places in the package and as such Rollup creates a shared chunk for it. During 'mastra dev' / with externals: true, we don't want that chunk to show up in the '.mastra/output' folder (outputDirRelative) but inside <pkg>/node_modules/.cache instead.\n       * We only care about this for the \"noBundling\" case!\n       */\n      if (noBundling) {\n        const importedFromPackages = new Set<string>();\n\n        for (const moduleId of chunkInfo.moduleIds) {\n          const normalized = slash(moduleId);\n          for (const [pkgName, pkgInfo] of workspaceMap.entries()) {\n            const location = slash(pkgInfo.location);\n            if (normalized.startsWith(location)) {\n              importedFromPackages.add(pkgName);\n              break;\n            }\n          }\n        }\n\n        if (importedFromPackages.size > 1) {\n          throw new MastraBaseError({\n            id: 'DEPLOYER_BUNDLE_EXTERNALS_SHARED_CHUNK',\n            domain: ErrorDomain.DEPLOYER,\n            category: ErrorCategory.USER,\n            details: {\n              chunkName: chunkInfo.name,\n              packages: JSON.stringify(Array.from(importedFromPackages)),\n            },\n            text: `Please open an issue. We found a shared chunk \"${\n              chunkInfo.name\n            }\" used by multiple workspace packages: ${Array.from(importedFromPackages).join(', ')}.`,\n          });\n        }\n\n        if (importedFromPackages.size === 1) {\n          const [pkgName] = importedFromPackages;\n          const workspaceLocation = workspaceMap.get(pkgName!)!.location;\n          return prepareEntryFileName(getCompiledDepCachePath(workspaceLocation, '[name].mjs'), rootDir);\n        }\n      }\n\n      return `${outputDirRelative}/[name].mjs`;\n    },\n    assetFileNames: `${outputDirRelative}/[name][extname]`,\n    hoistTransitiveImports: false,\n  });\n\n  await bundler.close();\n\n  return output;\n}\n\n/**\n * Recursively searches through Rollup output chunks to find which module imports a specific external dependency.\n * Used to build the module resolution map for proper external dependency tracking.\n */\nfunction findExternalImporter(module: OutputChunk, external: string, allOutputs: OutputChunk[]): OutputChunk | null {\n  const capturedFiles = new Set();\n\n  for (const id of module.imports) {\n    if (isDependencyPartOfPackage(id, external)) {\n      return module;\n    } else {\n      if (id.endsWith('.mjs')) {\n        capturedFiles.add(id);\n      }\n    }\n  }\n\n  for (const file of capturedFiles) {\n    const nextModule = allOutputs.find(o => o.fileName === file);\n    if (nextModule) {\n      const importer = findExternalImporter(nextModule, external, allOutputs);\n\n      if (importer) {\n        return importer;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Bundles vendor dependencies identified in the analysis step.\n * Creates virtual modules for each dependency and bundles them using rollup.\n *\n * @param depsToOptimize - Map of dependencies to optimize with their metadata (exported bindings, rootPath, isWorkspace)\n * @param outputDir - Directory where bundled files will be written\n * @param logger - Logger instance for debugging\n * @returns Object containing bundle output and reference map for validation\n */\nexport async function bundleExternals(\n  depsToOptimize: Map<string, DependencyMetadata>,\n  outputDir: string,\n  options: {\n    bundlerOptions?:\n      | ({\n          isDev?: boolean;\n        } & Config['bundler'])\n      | null;\n    projectRoot?: string;\n    workspaceRoot?: string;\n    workspaceMap?: Map<string, WorkspacePackageInfo>;\n  },\n) {\n  const { workspaceRoot = null, workspaceMap = new Map(), projectRoot = outputDir, bundlerOptions = {} } = options;\n  const { externals: customExternals = [], transpilePackages = [], isDev = false } = bundlerOptions || {};\n  /**\n   * A user can set `externals: true` to indicate they want to externalize all dependencies. In this case, we set `externalsPreset` to true to skip bundling any externals.\n   */\n  let externalsPreset = false;\n\n  if (customExternals === true) {\n    externalsPreset = true;\n  }\n\n  // If `externals` is an array (and not `true`), we proceed as normal\n  const externalsList = Array.isArray(customExternals) ? customExternals : [];\n  const allExternals = [...GLOBAL_EXTERNALS, ...DEPRECATED_EXTERNALS, ...externalsList];\n\n  const workspacePackagesNames = Array.from(workspaceMap.keys());\n  const packagesToTranspile = new Set([...transpilePackages, ...workspacePackagesNames]);\n\n  /**\n   * When externals: true, we need to extract non-workspace deps from depsToOptimize\n   * and add them directly to usedExternals instead of bundling them.\n   */\n  const extractedExternals = new Map<string, string>();\n  if (externalsPreset) {\n    for (const [dep, metadata] of depsToOptimize.entries()) {\n      if (!metadata.isWorkspace) {\n        // Add to extracted externals - use rootPath or fallback to package name\n        extractedExternals.set(dep, metadata.rootPath ?? dep);\n        // Remove from depsToOptimize so it won't be bundled\n        depsToOptimize.delete(dep);\n      }\n    }\n  }\n\n  const { optimizedDependencyEntries, fileNameToDependencyMap } = createVirtualDependencies(depsToOptimize, {\n    workspaceRoot,\n    outputDir,\n    projectRoot,\n    bundlerOptions: {\n      isDev,\n      externalsPreset,\n    },\n  });\n\n  const output = await buildExternalDependencies(optimizedDependencyEntries, {\n    externals: allExternals,\n    packagesToTranspile,\n    workspaceMap,\n    rootDir: workspaceRoot || projectRoot,\n    outputDir,\n    bundlerOptions: {\n      isDev,\n      externalsPreset,\n    },\n  });\n\n  const moduleResolveMap = new Map<string, Map<string, string>>();\n  const filteredChunks = output.filter(o => o.type === 'chunk');\n\n  for (const o of filteredChunks.filter(o => o.isEntry || o.isDynamicEntry)) {\n    for (const external of allExternals) {\n      if (DEPS_TO_IGNORE.includes(external)) {\n        continue;\n      }\n\n      const importer = findExternalImporter(o, external, filteredChunks);\n\n      if (importer) {\n        const fullPath = path.join(workspaceRoot || projectRoot, importer.fileName);\n        let innerMap = moduleResolveMap.get(fullPath);\n\n        if (!innerMap) {\n          innerMap = new Map<string, string>();\n          moduleResolveMap.set(fullPath, innerMap);\n        }\n\n        if (importer.moduleIds.length) {\n          innerMap.set(\n            external,\n            importer.moduleIds[importer.moduleIds.length - 1]?.startsWith('\\x00virtual:#virtual')\n              ? importer.moduleIds[importer.moduleIds.length - 2]!\n              : importer.moduleIds[importer.moduleIds.length - 1]!,\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Convert moduleResolveMap to a plain object with prototype-less objects\n   */\n  const usedExternals = Object.create(null) as Record<string, Record<string, string>>;\n  for (const [fullPath, innerMap] of moduleResolveMap) {\n    const innerObj = Object.create(null) as Record<string, string>;\n    for (const [external, value] of innerMap) {\n      innerObj[external] = value;\n    }\n    usedExternals[fullPath] = innerObj;\n  }\n\n  /**\n   * When externals: true, add the extracted non-workspace deps to usedExternals\n   * using a synthetic entry path to track them.\n   */\n  if (extractedExternals.size > 0) {\n    const syntheticPath = path.join(workspaceRoot || projectRoot, '__externals__');\n    const externalsObj = Object.create(null) as Record<string, string>;\n    for (const [dep, rootPath] of extractedExternals) {\n      externalsObj[dep] = rootPath;\n    }\n    usedExternals[syntheticPath] = externalsObj;\n  }\n\n  return { output, fileNameToDependencyMap, usedExternals };\n}\n","import type { PluginObj } from '@babel/core';\nimport babel from '@babel/core';\n\nexport function checkConfigExport(result: { hasValidConfig: boolean }): PluginObj {\n  const t = babel.types;\n  // Track which local variable names are assigned to `new Mastra()`\n  const mastraVars = new Set<string>();\n\n  return {\n    visitor: {\n      ExportNamedDeclaration(path) {\n        const decl = path.node.declaration;\n        // 1) export const mastra = new Mastra(...)\n        if (t.isVariableDeclaration(decl)) {\n          const varDecl = decl.declarations[0];\n          if (\n            t.isIdentifier(varDecl?.id, { name: 'mastra' }) &&\n            t.isNewExpression(varDecl.init) &&\n            t.isIdentifier(varDecl.init.callee, { name: 'Mastra' })\n          ) {\n            result.hasValidConfig = true;\n          }\n        }\n        /**\n         * 2) export { foo as mastra }\n         * 3) export { mastra }\n         * 4) export { mastra, foo }\n         */\n        if (Array.isArray(path.node.specifiers)) {\n          for (const spec of path.node.specifiers) {\n            if (\n              t.isExportSpecifier(spec) &&\n              t.isIdentifier(spec.exported, { name: 'mastra' }) &&\n              t.isIdentifier(spec.local) &&\n              mastraVars.has(spec.local.name)\n            ) {\n              result.hasValidConfig = true;\n            }\n          }\n        }\n      },\n      // For cases 2-4 we need to track whether those variables are assigned to `new Mastra()`\n      VariableDeclaration(path) {\n        for (const decl of path.node.declarations) {\n          if (\n            t.isIdentifier(decl.id) &&\n            t.isNewExpression(decl.init) &&\n            t.isIdentifier(decl.init.callee, { name: 'Mastra' })\n          ) {\n            mastraVars.add(decl.id.name);\n          }\n        }\n      },\n    },\n  };\n}\n","import { existsSync } from 'node:fs';\nimport { readFile, writeFile } from 'node:fs/promises';\nimport { basename, join, relative } from 'node:path';\nimport * as babel from '@babel/core';\nimport { ErrorCategory, ErrorDomain, MastraError } from '@mastra/core/error';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport type { OutputAsset, OutputChunk } from 'rollup';\nimport * as stackTraceParser from 'stacktrace-parser';\nimport { getWorkspaceInformation } from '../bundler/workspaceDependencies';\nimport type { WorkspacePackageInfo } from '../bundler/workspaceDependencies';\nimport { validate, ValidationError } from '../validator/validate';\nimport { analyzeEntry } from './analyze/analyzeEntry';\nimport { bundleExternals } from './analyze/bundleExternals';\nimport { GLOBAL_EXTERNALS } from './analyze/constants';\nimport { checkConfigExport } from './babel/check-config-export';\nimport type { BundlerOptions, DependencyMetadata, ExternalDependencyInfo } from './types';\nimport { getPackageName, isBuiltinModule, isDependencyPartOfPackage, slash } from './utils';\nimport type { BundlerPlatform } from './utils';\n\ntype ErrorId =\n  | 'DEPLOYER_ANALYZE_MODULE_NOT_FOUND'\n  | 'DEPLOYER_ANALYZE_MISSING_NATIVE_BUILD'\n  | 'DEPLOYER_ANALYZE_TYPE_ERROR';\n\nfunction throwExternalDependencyError({\n  errorId,\n  moduleName,\n  packageName,\n  messagePrefix,\n}: {\n  errorId: ErrorId;\n  moduleName: string;\n  packageName: string;\n  messagePrefix: string;\n}): never {\n  throw new MastraError({\n    id: errorId,\n    domain: ErrorDomain.DEPLOYER,\n    category: ErrorCategory.USER,\n    details: {\n      importFile: moduleName,\n      packageName: packageName,\n    },\n    text: `${messagePrefix} \\`${packageName}\\` to your externals.\n\nexport const mastra = new Mastra({\n  bundler: {\n    externals: [\"${packageName}\"],\n  }\n})`,\n  });\n}\n\nfunction getPackageNameFromBundledModuleName(moduleName: string) {\n  // New encoding uses __ to separate path segments (e.g., @inner__inner-tools -> @inner/inner-tools)\n  if (moduleName.includes('__')) {\n    return moduleName.replaceAll('__', '/');\n  }\n\n  // Legacy fallback for old format using - as separator\n  const chunks = moduleName.split('-');\n\n  if (!chunks.length) {\n    return moduleName;\n  }\n\n  if (chunks[0]?.startsWith('@')) {\n    return chunks.slice(0, 2).join('/');\n  }\n\n  return chunks[0];\n}\n\nfunction validateError(\n  err: ValidationError | Error,\n  file: OutputChunk,\n  {\n    binaryMapData,\n    workspaceMap,\n  }: {\n    binaryMapData: Record<string, string[]>;\n    logger: IMastraLogger;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n  },\n) {\n  let moduleName: string | undefined | null = null;\n  let errorConfig: {\n    id: ErrorId;\n    messagePrefix: string;\n  } | null = null;\n\n  if (err instanceof ValidationError) {\n    const parsedStack = stackTraceParser.parse(err.stack);\n    if (err.type === 'TypeError') {\n      const pkgNameRegex = /.*node_modules\\/([^\\/]+)\\//;\n      const stacktraceFrame = parsedStack.find(frame => frame.file && pkgNameRegex.test(frame.file));\n      if (stacktraceFrame) {\n        const match = stacktraceFrame.file!.match(pkgNameRegex);\n        moduleName = match?.[1] ?? getPackageNameFromBundledModuleName(basename(file.name));\n      } else {\n        moduleName = getPackageNameFromBundledModuleName(basename(file.name));\n      }\n\n      errorConfig = {\n        id: 'DEPLOYER_ANALYZE_TYPE_ERROR',\n        messagePrefix: `Mastra wasn't able to bundle \"${moduleName}\", might be an older commonJS module. Please add`,\n      };\n    } else if (err.stack?.includes?.('[ERR_MODULE_NOT_FOUND]')) {\n      moduleName = err.message.match(/Cannot find package '([^']+)'/)?.[1];\n\n      const parentModuleName = getPackageNameFromBundledModuleName(basename(file.name));\n\n      errorConfig = {\n        id: 'DEPLOYER_ANALYZE_MODULE_NOT_FOUND',\n        messagePrefix: `Mastra wasn't able to build your project, We couldn't load \"${moduleName}\" from \"${parentModuleName}\". Make sure \"${moduleName}\" is installed or add`,\n      };\n\n      // if they are the same, the feedback we give to our user is not really useful and probably something else went wrong\n      if (moduleName === parentModuleName) {\n        return;\n      }\n    }\n  }\n\n  if (err.message.includes('No native build was found')) {\n    const pkgName = getPackageNameFromBundledModuleName(basename(file.name));\n    moduleName = binaryMapData[file.fileName]?.[0] ?? pkgName;\n    errorConfig = {\n      id: 'DEPLOYER_ANALYZE_MISSING_NATIVE_BUILD',\n      messagePrefix: 'We found a binary dependency in your bundle but we cannot bundle it yet. Please add',\n    };\n  }\n\n  if (moduleName && workspaceMap.has(moduleName)) {\n    throw new MastraError({\n      id: 'DEPLOYER_ANALYZE_ERROR_IN_WORKSPACE',\n      domain: ErrorDomain.DEPLOYER,\n      category: ErrorCategory.USER,\n      details: {\n        // importFile: moduleName,\n        packageName: moduleName,\n      },\n      text: `We found an error in the ${moduleName} workspace package. Please find the offending package and fix the error.\n  Error: ${err.stack}`,\n    });\n  }\n\n  if (errorConfig && moduleName) {\n    throwExternalDependencyError({\n      errorId: errorConfig.id,\n      moduleName: moduleName!,\n      packageName: moduleName!,\n      messagePrefix: errorConfig.messagePrefix,\n    });\n  }\n}\n\nasync function validateFile(\n  root: string,\n  file: OutputChunk,\n  {\n    binaryMapData,\n    moduleResolveMapLocation,\n    logger,\n    workspaceMap,\n  }: {\n    binaryMapData: Record<string, string[]>;\n    moduleResolveMapLocation: string;\n    logger: IMastraLogger;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n  },\n) {\n  try {\n    if (!file.isDynamicEntry && file.isEntry) {\n      // validate if the chunk is actually valid, a failsafe to make sure bundling didn't make any mistakes\n      await validate(join(root, file.fileName), {\n        moduleResolveMapLocation,\n        injectESMShim: false,\n      });\n    }\n  } catch (err) {\n    let errorToHandle = err;\n    if (\n      err instanceof ValidationError &&\n      err.type === 'ReferenceError' &&\n      (err.message.startsWith('__dirname') || err.message.startsWith('__filename'))\n    ) {\n      try {\n        await validate(join(root, file.fileName), {\n          moduleResolveMapLocation,\n          injectESMShim: true,\n        });\n        errorToHandle = null;\n      } catch (err) {\n        errorToHandle = err;\n      }\n    }\n\n    if (errorToHandle instanceof Error) {\n      validateError(errorToHandle, file, { binaryMapData, logger, workspaceMap });\n    }\n  }\n}\n\n/**\n * Validates the bundled output by attempting to import each generated module.\n * Tracks external dependencies that couldn't be bundled.\n *\n * @param output - Bundle output from rollup\n * @param reverseVirtualReferenceMap - Map to resolve virtual module names back to original deps\n * @param outputDir - Directory containing the bundled files\n * @param logger - Logger instance for debugging\n * @param workspaceMap - Map of workspace packages that gets directly passed through for later consumption\n * @returns Analysis result containing dependency mappings\n */\nasync function validateOutput(\n  {\n    output,\n    reverseVirtualReferenceMap,\n    usedExternals,\n    outputDir,\n    projectRoot,\n    workspaceMap,\n    depsVersionInfo,\n  }: {\n    output: (OutputChunk | OutputAsset)[];\n    reverseVirtualReferenceMap: Map<string, string>;\n    usedExternals: Record<string, Record<string, string>>;\n    outputDir: string;\n    projectRoot: string;\n    workspaceMap: Map<string, WorkspacePackageInfo>;\n    depsVersionInfo: Map<string, ExternalDependencyInfo>;\n  },\n  logger: IMastraLogger,\n) {\n  const result = {\n    dependencies: new Map<string, string>(),\n    externalDependencies: new Map<string, ExternalDependencyInfo>(),\n    workspaceMap,\n  };\n\n  // store resolve map for validation\n  // we should resolve the version of the deps\n  for (const deps of Object.values(usedExternals)) {\n    for (const dep of Object.keys(deps)) {\n      const pkgName = getPackageName(dep);\n      if (pkgName) {\n        // Use version info from analysis if available\n        const versionInfo = depsVersionInfo.get(dep) || depsVersionInfo.get(pkgName) || {};\n        result.externalDependencies.set(pkgName, versionInfo);\n      }\n    }\n  }\n  let binaryMapData: Record<string, string[]> = {};\n\n  if (existsSync(join(outputDir, 'binary-map.json'))) {\n    const binaryMap = await readFile(join(outputDir, 'binary-map.json'), 'utf-8');\n    binaryMapData = JSON.parse(binaryMap);\n  }\n\n  for (const file of output) {\n    if (file.type === 'asset') {\n      continue;\n    }\n\n    logger.debug(`Validating if ${file.fileName} is a valid module.`);\n    if (file.isEntry && reverseVirtualReferenceMap.has(file.name)) {\n      result.dependencies.set(reverseVirtualReferenceMap.get(file.name)!, file.fileName);\n    }\n\n    // validate if the chunk is actually valid, a failsafe to make sure bundling didn't make any mistakes\n    await validateFile(projectRoot, file, {\n      binaryMapData,\n      moduleResolveMapLocation: join(outputDir, 'module-resolve-map.json'),\n      logger,\n      workspaceMap,\n    });\n  }\n\n  return result;\n}\n\n/**\n * Main bundle analysis function that orchestrates the three-step process:\n * 1. Analyze dependencies\n * 2. Bundle dependencies modules\n * 3. Validate generated bundles\n *\n * This helps identify which dependencies need to be externalized vs bundled.\n */\nexport async function analyzeBundle(\n  entries: string[],\n  mastraEntry: string,\n  {\n    outputDir,\n    projectRoot,\n    isDev = false,\n    bundlerOptions,\n  }: {\n    outputDir: string;\n    projectRoot: string;\n    platform: BundlerPlatform;\n    isDev?: boolean;\n    bundlerOptions?: Pick<BundlerOptions, 'externals' | 'enableSourcemap'> | null;\n  },\n  logger: IMastraLogger,\n) {\n  const mastraConfig = await readFile(mastraEntry, 'utf-8');\n  const mastraConfigResult = {\n    hasValidConfig: false,\n  } as const;\n\n  await babel.transformAsync(mastraConfig, {\n    filename: mastraEntry,\n    presets: [import.meta.resolve('@babel/preset-typescript')],\n    plugins: [checkConfigExport(mastraConfigResult)],\n  });\n\n  if (!mastraConfigResult.hasValidConfig) {\n    logger.warn(`Invalid Mastra config. Please make sure that your entry file looks like this:\nexport const mastra = new Mastra({\n  // your options\n})\n\nIf you think your configuration is valid, please open an issue.`);\n  }\n\n  const { workspaceMap, workspaceRoot } = await getWorkspaceInformation({ mastraEntryFile: mastraEntry });\n\n  let externalsPreset = false;\n\n  const userExternals = Array.isArray(bundlerOptions?.externals) ? bundlerOptions?.externals : [];\n  if (bundlerOptions?.externals === true) {\n    externalsPreset = true;\n  }\n\n  let index = 0;\n  const depsToOptimize = new Map<string, DependencyMetadata>();\n  const allExternals: string[] = [...GLOBAL_EXTERNALS, ...userExternals].filter(Boolean) as string[];\n\n  logger.info('Analyzing dependencies...');\n\n  // Track external dependencies with their version info\n  const allUsedExternals = new Map<string, ExternalDependencyInfo>();\n  for (const entry of entries) {\n    const isVirtualFile = entry.includes('\\n') || !existsSync(entry);\n    const analyzeResult = await analyzeEntry({ entry, isVirtualFile }, mastraEntry, {\n      logger,\n      sourcemapEnabled: bundlerOptions?.enableSourcemap ?? false,\n      workspaceMap,\n      projectRoot,\n      shouldCheckTransitiveDependencies: isDev || externalsPreset,\n    });\n\n    // Write the entry file to the output dir so that we can use it for workspace resolution stuff\n    await writeFile(join(outputDir, `entry-${index++}.mjs`), analyzeResult.output.code);\n\n    // Merge dependencies from each entry (main, tools, etc.)\n    for (const [dep, metadata] of analyzeResult.dependencies.entries()) {\n      const isPartOfExternals = allExternals.some(external => isDependencyPartOfPackage(dep, external));\n      if (isPartOfExternals || (externalsPreset && !metadata.isWorkspace)) {\n        // Add all packages coming from src/mastra with their version info\n        const pkgName = getPackageName(dep);\n        if (pkgName && !allUsedExternals.has(pkgName)) {\n          allUsedExternals.set(pkgName, {\n            version: metadata.version,\n          });\n        }\n        continue;\n      }\n\n      if (depsToOptimize.has(dep)) {\n        // Merge with existing exports if dependency already exists\n        const existingEntry = depsToOptimize.get(dep)!;\n        depsToOptimize.set(dep, {\n          ...existingEntry,\n          exports: [...new Set([...existingEntry.exports, ...metadata.exports])],\n        });\n      } else {\n        depsToOptimize.set(dep, metadata);\n      }\n    }\n  }\n\n  /**\n   * Only during `mastra dev` we want to optimize workspace packages. In previous steps we might have added dependencies that are not workspace packages, so we gotta remove them again.\n   */\n  if (isDev || externalsPreset) {\n    for (const [dep, metadata] of depsToOptimize.entries()) {\n      if (!metadata.isWorkspace) {\n        depsToOptimize.delete(dep);\n      }\n    }\n  }\n\n  const sortedDeps = Array.from(depsToOptimize.keys()).sort();\n  logger.info('Optimizing dependencies...');\n  logger.debug(`${sortedDeps.map(key => `- ${key}`).join('\\n')}`);\n\n  const { output, fileNameToDependencyMap, usedExternals } = await bundleExternals(depsToOptimize, outputDir, {\n    bundlerOptions: {\n      ...bundlerOptions,\n      externals: bundlerOptions?.externals ?? allExternals,\n      isDev,\n    },\n    projectRoot,\n    workspaceRoot,\n    workspaceMap,\n  });\n\n  // Filesystem-relative workspace paths for filtering workspace imports from rollup output.\n  // Normalize to forward slashes so the startsWith check works on Windows where\n  // path.relative() produces backslashes but rollup uses forward slashes.\n  const relativeWorkspaceFolderPaths = Array.from(workspaceMap.values()).map(pkgInfo =>\n    slash(relative(workspaceRoot || projectRoot, pkgInfo.location)),\n  );\n\n  // Build a map of dependency versions from depsToOptimize for lookup\n  const depsVersionInfo = new Map<string, ExternalDependencyInfo>();\n  for (const [dep, metadata] of depsToOptimize.entries()) {\n    const pkgName = getPackageName(dep);\n    if (pkgName && metadata.version) {\n      depsVersionInfo.set(pkgName, {\n        version: metadata.version,\n      });\n    }\n    // Also store by full import path for subpath imports\n    if (metadata.version) {\n      depsVersionInfo.set(dep, {\n        version: metadata.version,\n      });\n    }\n  }\n\n  for (const o of output) {\n    if (o.type === 'asset') {\n      continue;\n    }\n\n    for (const i of o.imports) {\n      if (isBuiltinModule(i)) {\n        continue;\n      }\n\n      // Skip relative imports - they're local chunks, not external packages\n      if (i.startsWith('.') || i.startsWith('/')) {\n        continue;\n      }\n\n      // Do not include workspace packages\n      if (relativeWorkspaceFolderPaths.some(workspacePath => i.startsWith(workspacePath))) {\n        continue;\n      }\n\n      const pkgName = getPackageName(i);\n\n      if (pkgName && !allUsedExternals.has(pkgName)) {\n        // Try to get version info from our tracked dependencies\n        const versionInfo = depsVersionInfo.get(i) || depsVersionInfo.get(pkgName) || {};\n        allUsedExternals.set(pkgName, versionInfo);\n      }\n    }\n  }\n\n  const result = await validateOutput(\n    {\n      output,\n      reverseVirtualReferenceMap: fileNameToDependencyMap,\n      usedExternals,\n      outputDir,\n      projectRoot: workspaceRoot || projectRoot,\n      workspaceMap,\n      depsVersionInfo,\n    },\n    logger,\n  );\n\n  // Merge external dependencies from validateOutput and allUsedExternals\n  // Prefer entries with version info over entries without\n  const mergedExternalDeps = new Map<string, ExternalDependencyInfo>(result.externalDependencies);\n  for (const [dep, info] of allUsedExternals) {\n    const existing = mergedExternalDeps.get(dep);\n    if (!existing || (!existing.version && info.version)) {\n      mergedExternalDeps.set(dep, info);\n    }\n  }\n\n  return {\n    ...result,\n    externalDependencies: mergedExternalDeps,\n  };\n}\n"]}