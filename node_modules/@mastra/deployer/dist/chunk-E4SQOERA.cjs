'use strict';

var chunkITC6JDLC_cjs = require('./chunk-ITC6JDLC.cjs');
var url = require('url');
var localPkg = require('local-pkg');
var originalEsbuild = require('rollup-plugin-esbuild');
var babel = require('@babel/core');
var fs = require('fs');
var path = require('path');
var stripJsonComments = require('strip-json-comments');
var typescriptPaths = require('typescript-paths');
var originalEsmShim = require('@rollup/plugin-esm-shim');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var originalEsbuild__default = /*#__PURE__*/_interopDefault(originalEsbuild);
var babel__namespace = /*#__PURE__*/_interopNamespace(babel);
var fs__default = /*#__PURE__*/_interopDefault(fs);
var path__default = /*#__PURE__*/_interopDefault(path);
var stripJsonComments__default = /*#__PURE__*/_interopDefault(stripJsonComments);
var originalEsmShim__default = /*#__PURE__*/_interopDefault(originalEsmShim);

async function getPackageRootPath(packageName, parentPath) {
  let rootPath;
  try {
    let options = void 0;
    if (parentPath) {
      if (!parentPath.startsWith("file://")) {
        parentPath = url.pathToFileURL(parentPath).href;
      }
      options = {
        paths: [parentPath]
      };
    }
    const pkg = await localPkg.getPackageInfo(packageName, options);
    rootPath = pkg?.rootPath ?? null;
  } catch {
    rootPath = null;
  }
  return rootPath;
}
function esbuild(options = {}) {
  return originalEsbuild__default.default({
    target: "node20",
    platform: "node",
    minify: false,
    ...options
  });
}
function removeDeployer() {
  const t = babel__namespace.default.types;
  function removeDeployerFromObject(objectExpr, scope) {
    const deployerProp = objectExpr.properties.find(
      (prop) => t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === "deployer"
    );
    if (deployerProp) {
      objectExpr.properties = objectExpr.properties.filter((prop) => prop !== deployerProp);
      if (t.isIdentifier(deployerProp.value)) {
        const deployerBinding = scope.getBinding(deployerProp.value.name);
        if (deployerBinding) {
          deployerBinding.path?.parentPath?.remove();
        }
      }
    }
    return deployerProp;
  }
  return {
    name: "remove-deployer",
    visitor: {
      NewExpression(path2, state) {
        const varDeclaratorPath = path2.findParent((path3) => t.isVariableDeclarator(path3.node));
        if (!varDeclaratorPath) {
          return;
        }
        const parentNode = path2.parentPath.node;
        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== "mastra") {
          return;
        }
        if (!state.hasReplaced) {
          state.hasReplaced = true;
          const newMastraObj = t.cloneNode(path2.node);
          if (t.isObjectExpression(newMastraObj.arguments[0]) && newMastraObj.arguments[0].properties?.length) {
            const objectArg = newMastraObj.arguments[0];
            let foundDeployer = false;
            const directDeployer = removeDeployerFromObject(objectArg, state.file.scope);
            if (directDeployer) {
              foundDeployer = true;
            }
            for (const prop of objectArg.properties) {
              if (t.isSpreadElement(prop) && t.isIdentifier(prop.argument)) {
                const spreadBinding = state.file.scope.getBinding(prop.argument.name);
                if (spreadBinding?.path && t.isVariableDeclarator(spreadBinding.path.node)) {
                  const init = spreadBinding.path.node.init;
                  if (t.isObjectExpression(init)) {
                    const spreadDeployer = removeDeployerFromObject(init, state.file.scope);
                    if (spreadDeployer) {
                      foundDeployer = true;
                    }
                  }
                }
              }
            }
            if (foundDeployer) {
              path2.replaceWith(newMastraObj);
            }
          }
        }
      }
    }
  };
}

// src/build/plugins/remove-deployer.ts
function removeDeployer2(mastraEntry, options) {
  return {
    name: "remove-deployer",
    transform(code, id) {
      if (id !== mastraEntry) {
        return;
      }
      return new Promise((resolve, reject) => {
        babel__namespace.transform(
          code,
          {
            babelrc: false,
            configFile: false,
            filename: id,
            plugins: [removeDeployer],
            sourceMaps: options?.sourcemap
          },
          (err, result) => {
            if (err) {
              return reject(err);
            }
            resolve({
              code: result.code,
              map: result.map
            });
          }
        );
      });
    }
  };
}
var PLUGIN_NAME = "tsconfig-paths";
function hasPaths(tsConfigPath) {
  try {
    const content = fs__default.default.readFileSync(tsConfigPath, "utf8");
    const config = JSON.parse(stripJsonComments__default.default(content));
    return !!(config.compilerOptions?.paths && Object.keys(config.compilerOptions.paths).length > 0 || typeof config.extends === "string" && config.extends.length > 0 || Array.isArray(config.extends) && config.extends.length > 0);
  } catch {
    return false;
  }
}
function tsConfigPaths({ tsConfigPath, respectCoreModule, localResolve } = {}) {
  const handlerCache = /* @__PURE__ */ new Map();
  function findTsConfigForFile(filePath) {
    let currentDir = path__default.default.dirname(filePath);
    const root = path__default.default.parse(currentDir).root;
    while (currentDir !== root) {
      const tsConfigPath2 = path__default.default.join(currentDir, "tsconfig.json");
      if (fs__default.default.existsSync(tsConfigPath2)) {
        if (hasPaths(tsConfigPath2)) {
          return tsConfigPath2;
        }
      }
      const tsConfigBasePath = path__default.default.join(currentDir, "tsconfig.base.json");
      if (fs__default.default.existsSync(tsConfigBasePath)) {
        if (hasPaths(tsConfigBasePath)) {
          return tsConfigBasePath;
        }
      }
      currentDir = path__default.default.dirname(currentDir);
    }
    return null;
  }
  function getHandlerForFile(filePath) {
    if (tsConfigPath && typeof tsConfigPath === "string") {
      if (!handlerCache.has(tsConfigPath)) {
        handlerCache.set(
          tsConfigPath,
          typescriptPaths.createHandler({
            log: () => {
            },
            tsConfigPath,
            respectCoreModule,
            falllback: (moduleName) => fs__default.default.existsSync(moduleName)
          })
        );
      }
      return handlerCache.get(tsConfigPath);
    }
    const configPath = findTsConfigForFile(filePath);
    if (!configPath) {
      return null;
    }
    if (!handlerCache.has(configPath)) {
      handlerCache.set(
        configPath,
        typescriptPaths.createHandler({
          log: () => {
          },
          tsConfigPath: configPath,
          respectCoreModule,
          falllback: (moduleName) => fs__default.default.existsSync(moduleName)
        })
      );
    }
    return handlerCache.get(configPath);
  }
  function resolveAlias(request, importer) {
    const dynamicHandler = getHandlerForFile(importer);
    if (!dynamicHandler) {
      return null;
    }
    const resolved = dynamicHandler(request, path.normalize(importer));
    return resolved;
  }
  return {
    name: PLUGIN_NAME,
    resolveId: {
      order: "pre",
      async handler(request, importer, options) {
        if (!importer || request.startsWith("\0") || importer.charCodeAt(0) === 0) {
          return null;
        }
        if (!path__default.default.isAbsolute(importer)) {
          importer = path__default.default.resolve(process.cwd(), importer);
        }
        const moduleName = resolveAlias(request, importer);
        if (!moduleName) {
          const resolved2 = await this.resolve(request, importer, { skipSelf: true, ...options });
          if (!resolved2) {
            return null;
          }
          if (localResolve) {
            const importerInfo = this.getModuleInfo(importer);
            const importerPluginMeta = importerInfo?.meta?.[PLUGIN_NAME];
            if (!request.startsWith("./") && !request.startsWith("../") && importerPluginMeta?.resolved) {
              return {
                ...resolved2,
                external: !request.startsWith("hono/") && request !== "hono"
              };
            }
          }
          return {
            ...resolved2,
            meta: {
              ...resolved2.meta || {}
            }
          };
        }
        if (!path__default.default.extname(moduleName)) {
          const resolved2 = await this.resolve(moduleName, importer, { skipSelf: true, ...options });
          if (!resolved2) {
            return null;
          }
          return {
            ...resolved2,
            meta: {
              ...resolved2.meta,
              [PLUGIN_NAME]: {
                resolved: true
              }
            }
          };
        }
        const resolved = await this.resolve(moduleName, importer, { skipSelf: true, ...options });
        if (!resolved) {
          return null;
        }
        return {
          ...resolved,
          meta: {
            ...resolved.meta,
            [PLUGIN_NAME]: {
              resolved: true
            }
          }
        };
      }
    }
  };
}
var FilenameDeclarationRegex = /(?:const|let|var)\s+__filename/;
var DirnameDeclarationRegex = /(?:const|let|var)\s+__dirname/;
function esmShim() {
  const original = originalEsmShim__default.default();
  return {
    name: "esm-shim",
    renderChunk(code, chunk, opts, meta) {
      const hasFilename = code.includes("__filename");
      const hasDirname = code.includes("__dirname");
      const userDeclaredFilename = hasFilename && FilenameDeclarationRegex.test(code);
      const userDeclaredDirname = hasDirname && DirnameDeclarationRegex.test(code);
      if (userDeclaredFilename || userDeclaredDirname) {
        return null;
      }
      if (typeof original.renderChunk === "function") {
        return original.renderChunk.call(this, code, chunk, opts, meta);
      }
      return null;
    }
  };
}

// src/build/plugins/subpath-externals-resolver.ts
function subpathExternalsResolver(externals) {
  return {
    name: "subpath-externals-resolver",
    resolveId(id) {
      if (id.startsWith(".") || id.startsWith("/")) {
        return null;
      }
      const isPartOfExternals = externals.some((external) => chunkITC6JDLC_cjs.isDependencyPartOfPackage(id, external));
      if (isPartOfExternals) {
        return {
          id,
          external: true
        };
      }
    }
  };
}

exports.esbuild = esbuild;
exports.esmShim = esmShim;
exports.getPackageRootPath = getPackageRootPath;
exports.removeDeployer = removeDeployer2;
exports.subpathExternalsResolver = subpathExternalsResolver;
exports.tsConfigPaths = tsConfigPaths;
//# sourceMappingURL=chunk-E4SQOERA.cjs.map
//# sourceMappingURL=chunk-E4SQOERA.cjs.map