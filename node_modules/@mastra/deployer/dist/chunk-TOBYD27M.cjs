'use strict';

var chunkK7J2W7DJ_cjs = require('./chunk-K7J2W7DJ.cjs');
var chunkSAAWBL2Q_cjs = require('./chunk-SAAWBL2Q.cjs');
var chunkR2SIOO54_cjs = require('./chunk-R2SIOO54.cjs');
var chunkE4SQOERA_cjs = require('./chunk-E4SQOERA.cjs');
var chunkITC6JDLC_cjs = require('./chunk-ITC6JDLC.cjs');
var path = require('path');
var logger = require('@mastra/core/logger');
var pkg = require('empathic/package');
var rollup = require('rollup');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var pkg__namespace = /*#__PURE__*/_interopNamespace(pkg);

async function getInputOptions2(entryFile, platform, env, {
  sourcemap = false,
  bundlerOptions = {
    enableSourcemap: false,
    enableEsmShim: true,
    externals: true
  }
} = {}) {
  const closestPkgJson = pkg__namespace.up({ cwd: path.dirname(entryFile) });
  const projectRoot = closestPkgJson ? path.dirname(chunkITC6JDLC_cjs.slash(closestPkgJson)) : chunkITC6JDLC_cjs.slash(process.cwd());
  const { workspaceMap, workspaceRoot } = await chunkSAAWBL2Q_cjs.getWorkspaceInformation({ mastraEntryFile: entryFile });
  const analyzeEntryResult = await chunkSAAWBL2Q_cjs.analyzeBundle(
    [entryFile],
    entryFile,
    {
      outputDir: path.posix.join(process.cwd(), ".mastra", ".build"),
      projectRoot: workspaceRoot || process.cwd(),
      platform,
      isDev: true,
      bundlerOptions
    },
    logger.noopLogger
  );
  const deps = /* @__PURE__ */ new Map();
  for (const [dep, metadata] of analyzeEntryResult.dependencies.entries()) {
    const pkgName = chunkITC6JDLC_cjs.getPackageName(dep);
    if (pkgName && workspaceMap.has(pkgName)) {
      deps.set(dep, metadata);
    }
  }
  const inputOptions = await chunkR2SIOO54_cjs.getInputOptions(
    entryFile,
    {
      dependencies: deps,
      externalDependencies: /* @__PURE__ */ new Map(),
      workspaceMap
    },
    platform,
    env,
    { sourcemap, isDev: true, workspaceRoot, projectRoot, externalsPreset: bundlerOptions?.externals === true }
  );
  if (Array.isArray(inputOptions.plugins)) {
    const plugins = [];
    inputOptions.plugins.forEach((plugin) => {
      if (plugin?.name === "node-resolve") {
        return;
      }
      if (plugin?.name === "tsconfig-paths") {
        plugins.push(
          chunkE4SQOERA_cjs.tsConfigPaths({
            localResolve: true
          })
        );
        return;
      }
      plugins.push(plugin);
    });
    inputOptions.plugins = plugins;
    inputOptions.plugins.push(chunkSAAWBL2Q_cjs.aliasHono());
    inputOptions.plugins.push(chunkR2SIOO54_cjs.nodeModulesExtensionResolver());
  }
  return inputOptions;
}
async function createWatcher(inputOptions, outputOptions) {
  const watcher = await rollup.watch({
    ...inputOptions,
    output: {
      ...outputOptions,
      format: "esm",
      entryFileNames: "[name].mjs",
      chunkFileNames: "[name].mjs"
    }
  });
  return watcher;
}

// src/build/serverOptions.ts
async function getServerOptions(entryFile, outputDir, logger) {
  const result = await chunkK7J2W7DJ_cjs.extractMastraOption("server", entryFile, outputDir, logger);
  if (!result) {
    return null;
  }
  return result.getConfig();
}

exports.createWatcher = createWatcher;
exports.getInputOptions = getInputOptions2;
exports.getServerOptions = getServerOptions;
//# sourceMappingURL=chunk-TOBYD27M.cjs.map
//# sourceMappingURL=chunk-TOBYD27M.cjs.map