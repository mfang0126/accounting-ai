{"version":3,"sources":["../src/build/babel/remove-all-options-except.ts","../src/build/plugins/remove-all-except.ts","../src/build/babel/remove-non-referenced-nodes.ts","../src/build/plugins/remove-unused-references.ts","../src/build/shared/extract-mastra-option.ts","../src/build/bundlerOptions.ts"],"names":["babel","path","babel2","result","babel4","rollup","tsConfigPaths","esbuild","optimizeLodashImports","commonjs","json","pathToFileURL"],"mappings":"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","file":"chunk-K7J2W7DJ.cjs","sourcesContent":["import babel from '@babel/core';\nimport type { NodePath, types } from '@babel/core';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport type { Config as MastraConfig } from '@mastra/core/mastra';\n\nexport function removeAllOptionsFromMastraExcept(\n  result: { hasCustomConfig: boolean },\n  option: keyof MastraConfig,\n  logger?: IMastraLogger,\n) {\n  const t = babel.types;\n\n  return {\n    name: 'remove-all-except-' + option + '-config',\n    visitor: {\n      ExportNamedDeclaration: {\n        // remove all exports\n        exit(path) {\n          path.remove();\n        },\n      },\n\n      NewExpression(path, state) {\n        // is a variable declaration\n        const varDeclaratorPath = path.findParent(path => t.isVariableDeclarator(path.node));\n        if (!varDeclaratorPath) {\n          return;\n        }\n\n        const parentNode = path.parentPath.node;\n        // check if it's a const of mastra\n        if (!t.isVariableDeclarator(parentNode) || !t.isIdentifier(parentNode.id) || parentNode.id.name !== 'mastra') {\n          return;\n        }\n\n        let mastraArgs = t.objectExpression([]);\n        if (t.isObjectExpression(path.node.arguments[0])) {\n          mastraArgs = path.node.arguments[0];\n        }\n\n        // Find the config property, skipping SpreadElement nodes\n        let configProperty = mastraArgs.properties.find(\n          prop => t.isObjectProperty(prop) && t.isIdentifier(prop.key) && prop.key.name === option,\n        );\n        let configValue: types.Expression = t.objectExpression([]);\n\n        const programPath = path.scope.getProgramParent().path as NodePath<types.Program> | undefined;\n        if (!programPath) {\n          return;\n        }\n\n        if (configProperty && t.isObjectProperty(configProperty) && t.isExpression(configProperty.value)) {\n          result.hasCustomConfig = true;\n          configValue = configProperty.value;\n\n          if (t.isIdentifier(configProperty.value) && configProperty.value.name === option) {\n            const configBinding = state.file.scope.getBinding(option)!;\n\n            if (configBinding && t.isVariableDeclarator(configBinding.path.node)) {\n              const id = path.scope.generateUidIdentifier(option);\n\n              configBinding.path.replaceWith(t.variableDeclarator(id, configBinding.path.node.init!));\n              configValue = id;\n            }\n          }\n        }\n\n        // add the deployer export\n        const exportDeclaration = t.exportNamedDeclaration(\n          t.variableDeclaration('const', [t.variableDeclarator(t.identifier(option), configValue)]),\n          [],\n        );\n\n        programPath.node.body.push(exportDeclaration);\n      },\n\n      Program: {\n        exit(path) {\n          // Add a fallback export if no mastra configuration was found\n          const hasExport = path.node.body.some(\n            node => node.type === 'ExportNamedDeclaration' || node.type === 'ExportDefaultDeclaration',\n          );\n\n          if (!hasExport) {\n            if (logger) {\n              logger.warn(`Mastra ${option} config could not be extracted. Please make sure your entry file looks like this:\nexport const mastra = new Mastra({\n  ${option}: <value>\n})\n\n`);\n            }\n\n            const fallbackExportDeclaration = t.exportNamedDeclaration(\n              t.variableDeclaration('const', [t.variableDeclarator(t.identifier(option), t.objectExpression([]))]),\n              [],\n            );\n            path.node.body.push(fallbackExportDeclaration);\n          }\n        },\n      },\n    },\n  } as babel.PluginObj;\n}\n","import * as babel from '@babel/core';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport type { Config as MastraConfig } from '@mastra/core/mastra';\nimport type { Plugin } from 'rollup';\nimport { removeAllOptionsFromMastraExcept } from '../babel/remove-all-options-except';\n\nexport function removeAllOptionsFromMastraExceptPlugin(\n  mastraEntry: string,\n  name: keyof MastraConfig,\n  result: { hasCustomConfig: boolean },\n  options?: { sourcemap?: boolean; logger?: IMastraLogger },\n): Plugin {\n  return {\n    name: `remove-${name}`,\n    transform(code, id) {\n      if (id !== mastraEntry) {\n        return;\n      }\n\n      return new Promise((resolve, reject) => {\n        babel.transform(\n          code,\n          {\n            babelrc: false,\n            configFile: false,\n            filename: id,\n            plugins: [removeAllOptionsFromMastraExcept(result, name, options?.logger)],\n            sourceMaps: options?.sourcemap,\n          },\n          (err, result) => {\n            if (err) {\n              return reject(err);\n            }\n\n            resolve({\n              code: result!.code!,\n              map: result!.map!,\n            });\n          },\n        );\n      });\n    },\n  } satisfies Plugin;\n}\n","import babel from '@babel/core';\n\nexport function removeNonReferencedNodes() {\n  const t = babel.types;\n\n  return {\n    name: 'remove-non-referenced-nodes',\n    visitor: {\n      Program(path) {\n        // Get the scope information\n        const scope = path.scope;\n\n        // Filter body to keep only referenced nodes\n        const currentBody = path.get('body');\n        const filteredBody = currentBody.filter(childPath => {\n          if (childPath.isExportDeclaration()) {\n            return true;\n          }\n\n          // For variable declarations, check if any declared variables are referenced\n          if (childPath.isVariableDeclaration()) {\n            return childPath.node.declarations.some(decl => {\n              if (!t.isIdentifier(decl.id)) {\n                return false;\n              }\n\n              const name = decl.id.name;\n              const binding = scope.getBinding(name);\n              // Keep if it has references or is exported\n              return binding && (binding.referenced || binding.referencePaths.length > 0);\n            });\n          }\n\n          // For function/class declarations, check if they're referenced\n          if (childPath.isFunctionDeclaration() || childPath.isClassDeclaration()) {\n            if (!t.isIdentifier(childPath.node.id)) {\n              return false;\n            }\n\n            const name = childPath.node.id.name;\n            const binding = scope.getBinding(name);\n            return binding && (binding.referenced || binding.referencePaths.length > 0);\n          }\n\n          // For imports, check if any imported items are referenced\n          if (childPath.isImportDeclaration()) {\n            return childPath.node.specifiers.some(specifier => {\n              const importedName = specifier.local.name;\n              const binding = scope.getBinding(importedName);\n              return binding && (binding.referenced || binding.referencePaths.length > 0);\n            });\n          }\n\n          // Default to keeping other node types\n          return false;\n        });\n\n        // Replace the program body with filtered nodes\n        path.set(\n          'body',\n          filteredBody.map(p => p.node),\n        );\n      },\n    },\n  } as babel.PluginObj;\n}\n","import * as babel from '@babel/core';\nimport { removeNonReferencedNodes } from '../babel/remove-non-referenced-nodes';\n\nexport function recursiveRemoveNonReferencedNodes(code: string) {\n  return new Promise<{ code: string; map: any }>(async (resolve, reject) => {\n    babel.transform(\n      code,\n      {\n        babelrc: false,\n        configFile: false,\n        plugins: [removeNonReferencedNodes()],\n      },\n      (err, result) => {\n        if (err) {\n          return reject(err);\n        }\n\n        // keep looping until the code is not changed\n        if (result && result.code! !== code) {\n          return recursiveRemoveNonReferencedNodes(result!.code!).then(resolve, reject);\n        }\n\n        resolve({\n          code: result!.code!,\n          map: result!.map!,\n        });\n      },\n    );\n  });\n}\n","import { pathToFileURL } from 'node:url';\nimport type { IMastraLogger } from '@mastra/core/logger';\nimport type { Config as MastraConfig } from '@mastra/core/mastra';\nimport { optimizeLodashImports } from '@optimize-lodash/rollup-plugin';\nimport commonjs from '@rollup/plugin-commonjs';\nimport json from '@rollup/plugin-json';\nimport { rollup } from 'rollup';\nimport type { RollupOutput } from 'rollup';\nimport { esbuild } from '../plugins/esbuild';\nimport { removeAllOptionsFromMastraExceptPlugin } from '../plugins/remove-all-except';\nimport { recursiveRemoveNonReferencedNodes } from '../plugins/remove-unused-references';\nimport { tsConfigPaths } from '../plugins/tsconfig-paths';\n\nexport function extractMastraOptionBundler(\n  name: keyof MastraConfig,\n  entryFile: string,\n  result: {\n    hasCustomConfig: boolean;\n  },\n  logger?: IMastraLogger,\n) {\n  return rollup({\n    logLevel: 'silent',\n    input: {\n      [`${name}-config`]: entryFile,\n    },\n    treeshake: 'smallest',\n    plugins: [\n      tsConfigPaths(),\n      // transpile typescript to something we understand\n      esbuild(),\n      optimizeLodashImports({\n        include: '**/*.{js,ts,mjs,cjs}',\n      }),\n      commonjs({\n        extensions: ['.js', '.ts'],\n        strictRequires: 'strict',\n        transformMixedEsModules: true,\n        ignoreTryCatch: false,\n      }),\n      json(),\n      removeAllOptionsFromMastraExceptPlugin(entryFile, name, result, { logger }),\n      // let esbuild remove all unused imports\n      esbuild(),\n      {\n        name: 'cleanup',\n        transform(code, id) {\n          if (id !== entryFile) {\n            return;\n          }\n\n          return recursiveRemoveNonReferencedNodes(code);\n        },\n      },\n      // let esbuild remove it once more\n      esbuild(),\n    ],\n  });\n}\n\nexport async function extractMastraOption<T extends keyof MastraConfig>(\n  name: T,\n  entryFile: string,\n  outputDir: string,\n  logger?: IMastraLogger,\n): Promise<{\n  bundleOutput: RollupOutput;\n  getConfig: () => Promise<MastraConfig[T]>;\n} | null> {\n  const result = {\n    hasCustomConfig: false,\n  };\n\n  const bundler = await extractMastraOptionBundler(name, entryFile, result, logger);\n\n  const output = await bundler.write({\n    dir: outputDir,\n    format: 'es',\n    entryFileNames: '[name].mjs',\n  });\n\n  if (result.hasCustomConfig) {\n    const configPath = `${outputDir}/${name}-config.mjs`;\n\n    return {\n      bundleOutput: output,\n      getConfig: () => import(pathToFileURL(configPath).href).then(m => m[name] as MastraConfig[T]),\n    };\n  }\n\n  return null;\n}\n","import type { IMastraLogger } from '@mastra/core/logger';\nimport type { Config } from '@mastra/core/mastra';\nimport { extractMastraOption, extractMastraOptionBundler } from './shared/extract-mastra-option';\n\nexport function getBundlerOptionsBundler(\n  entryFile: string,\n  result: {\n    hasCustomConfig: false;\n  },\n) {\n  return extractMastraOptionBundler('bundler', entryFile, result);\n}\n\nexport async function getBundlerOptions(\n  entryFile: string,\n  outputDir: string,\n  logger?: IMastraLogger,\n): Promise<Config['bundler'] | null> {\n  const result = await extractMastraOption('bundler', entryFile, outputDir, logger);\n\n  if (!result) {\n    return null;\n  }\n\n  return result.getConfig();\n}\n"]}