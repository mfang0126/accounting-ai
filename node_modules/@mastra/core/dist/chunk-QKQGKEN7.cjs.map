{"version":3,"sources":["../src/workspace/errors.ts","../src/workspace/lifecycle.ts","../src/workspace/filesystem/composite-filesystem.ts","../src/workspace/filesystem/mastra-filesystem.ts","../src/workspace/utils.ts","../src/workspace/filesystem/fs-utils.ts","../src/workspace/filesystem/local-filesystem.ts","../src/workspace/filesystem/file-read-tracker.ts","../src/workspace/filesystem/file-write-lock.ts","../src/workspace/glob.ts","../src/workspace/lsp/language.ts","../src/workspace/lsp/client.ts","../src/workspace/lsp/servers.ts","../src/workspace/lsp/manager.ts","../src/workspace/sandbox/errors.ts","../src/workspace/sandbox/mount-manager.ts","../src/workspace/sandbox/utils.ts","../src/workspace/sandbox/mastra-sandbox.ts","../src/workspace/line-utils.ts","../src/workspace/search/bm25.ts","../src/workspace/search/search-engine.ts","../src/workspace/skills/schemas.ts","../src/workspace/skills/local-skill-source.ts","../src/workspace/skills/versioned-skill-source.ts","../src/workspace/skills/composite-versioned-skill-source.ts","../src/workspace/skills/workspace-skills.ts","../src/workspace/skills/publish.ts","../src/workspace/workspace.ts","../src/workspace/sandbox/process-manager/process-handle.ts","../src/workspace/sandbox/process-manager/process-manager.ts","../src/workspace/sandbox/local-process-manager.ts","../src/workspace/sandbox/native-sandbox/detect.ts","../src/workspace/sandbox/native-sandbox/seatbelt.ts","../src/workspace/sandbox/native-sandbox/bubblewrap.ts","../src/workspace/sandbox/native-sandbox/wrapper.ts","../src/workspace/sandbox/local-sandbox.ts","../src/workspace/constants/index.ts","../src/workspace/tools/helpers.ts","../src/workspace/tools/ast-edit.ts","../src/workspace/tools/delete-file.ts","../src/workspace/tools/edit-file.ts","../src/workspace/tools/output-helpers.ts","../src/workspace/tools/execute-command.ts","../src/workspace/tools/file-stat.ts","../src/workspace/tools/get-process-output.ts","../src/workspace/tools/grep.ts","../src/workspace/tools/index-content.ts","../src/workspace/tools/kill-process.ts","../src/workspace/tools/tree-formatter.ts","../src/workspace/tools/list-files.ts","../src/workspace/tools/mkdir.ts","../src/workspace/tools/read-file.ts","../src/workspace/tools/search.ts","../src/workspace/tools/write-file.ts","../src/workspace/tools/tools.ts"],"names":["path","fs","posixPath","stat","access","MastraBase","RegisteredLogger","nodePath","relative","fs2","fsConstants","nodePath2","resolve","nodePath3","picomatch","createRequire","pathToFileURL","execFileSync","join","parse","existsSync","dirname","createHash","path3","fs3","matter","Readable","Writable","childProcess","os","platform","path4","fs4","crypto","os2","createTool","z","pattern","joinPath"],"mappings":"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","file":"chunk-QKQGKEN7.cjs","sourcesContent":["/**\n * Workspace Errors\n *\n * Error classes for workspace operations.\n */\n\nimport type { WorkspaceStatus } from './types';\n\n// =============================================================================\n// Base Error\n// =============================================================================\n\nexport class WorkspaceError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly workspaceId?: string,\n  ) {\n    super(message);\n    this.name = 'WorkspaceError';\n  }\n}\n\n// =============================================================================\n// Availability Errors\n// =============================================================================\n\nexport class WorkspaceNotAvailableError extends WorkspaceError {\n  constructor() {\n    super('Workspace not available. Ensure the agent has a workspace configured.', 'NO_WORKSPACE');\n    this.name = 'WorkspaceNotAvailableError';\n  }\n}\n\nexport class FilesystemNotAvailableError extends WorkspaceError {\n  constructor() {\n    super('Workspace does not have a filesystem configured', 'NO_FILESYSTEM');\n    this.name = 'FilesystemNotAvailableError';\n  }\n}\n\nexport class SandboxNotAvailableError extends WorkspaceError {\n  constructor(message?: string) {\n    super(message ?? 'Workspace does not have a sandbox configured', 'NO_SANDBOX');\n    this.name = 'SandboxNotAvailableError';\n  }\n}\n\nexport class SandboxFeatureNotSupportedError extends WorkspaceError {\n  constructor(feature: 'executeCommand' | 'installPackage' | 'processes') {\n    super(`Sandbox does not support ${feature}`, 'FEATURE_NOT_SUPPORTED');\n    this.name = 'SandboxFeatureNotSupportedError';\n  }\n}\n\nexport class SearchNotAvailableError extends WorkspaceError {\n  constructor() {\n    super('Workspace does not have search configured (enable bm25 or provide vectorStore + embedder)', 'NO_SEARCH');\n    this.name = 'SearchNotAvailableError';\n  }\n}\n\n// =============================================================================\n// State Errors\n// =============================================================================\n\nexport class WorkspaceNotReadyError extends WorkspaceError {\n  constructor(workspaceId: string, status: WorkspaceStatus) {\n    super(`Workspace is not ready (status: ${status})`, 'NOT_READY', workspaceId);\n    this.name = 'WorkspaceNotReadyError';\n  }\n}\n\nexport class WorkspaceReadOnlyError extends WorkspaceError {\n  constructor(operation: string) {\n    super(`Workspace is in read-only mode. Cannot perform: ${operation}`, 'READ_ONLY');\n    this.name = 'WorkspaceReadOnlyError';\n  }\n}\n\n// =============================================================================\n// Filesystem Errors\n// =============================================================================\n\nexport class FilesystemError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly path: string,\n  ) {\n    super(message);\n    this.name = 'FilesystemError';\n  }\n}\n\nexport class FileNotFoundError extends FilesystemError {\n  constructor(path: string) {\n    super(`File not found: ${path}`, 'ENOENT', path);\n    this.name = 'FileNotFoundError';\n  }\n}\n\nexport class DirectoryNotFoundError extends FilesystemError {\n  constructor(path: string) {\n    super(`Directory not found: ${path}`, 'ENOENT', path);\n    this.name = 'DirectoryNotFoundError';\n  }\n}\n\nexport class FileExistsError extends FilesystemError {\n  constructor(path: string) {\n    super(`File already exists: ${path}`, 'EEXIST', path);\n    this.name = 'FileExistsError';\n  }\n}\n\nexport class IsDirectoryError extends FilesystemError {\n  constructor(path: string) {\n    super(`Path is a directory: ${path}`, 'EISDIR', path);\n    this.name = 'IsDirectoryError';\n  }\n}\n\nexport class NotDirectoryError extends FilesystemError {\n  constructor(path: string) {\n    super(`Path is not a directory: ${path}`, 'ENOTDIR', path);\n    this.name = 'NotDirectoryError';\n  }\n}\n\nexport class DirectoryNotEmptyError extends FilesystemError {\n  constructor(path: string) {\n    super(`Directory not empty: ${path}`, 'ENOTEMPTY', path);\n    this.name = 'DirectoryNotEmptyError';\n  }\n}\n\nexport class PermissionError extends FilesystemError {\n  constructor(\n    path: string,\n    public readonly operation: string,\n  ) {\n    super(`Permission denied: ${operation} on ${path}`, 'EACCES', path);\n    this.name = 'PermissionError';\n  }\n}\n\nexport class FileReadRequiredError extends FilesystemError {\n  constructor(path: string, reason: string) {\n    super(reason, 'EREAD_REQUIRED', path);\n    this.name = 'FileReadRequiredError';\n  }\n}\n\n/**\n * Error thrown when a filesystem operation is attempted before initialization.\n */\nexport class FilesystemNotReadyError extends FilesystemError {\n  constructor(id: string) {\n    super(`Filesystem \"${id}\" is not ready. Call init() first or use ensureReady().`, 'ENOTREADY', id);\n    this.name = 'FilesystemNotReadyError';\n  }\n}\n","/**\n * Workspace Lifecycle Interfaces\n *\n * Defines lifecycle contracts for workspace providers (filesystem, sandbox).\n * The base `Lifecycle` holds shared members while `FilesystemLifecycle` and\n * `SandboxLifecycle` add the methods each provider kind actually uses.\n */\n\n// =============================================================================\n// Base Lifecycle Interface\n// =============================================================================\n\n/**\n * Shared lifecycle base for workspace providers.\n *\n * Contains status tracking, destroy, readiness check, and info retrieval.\n * Provider-specific lifecycle methods live in the extended interfaces:\n * - {@link FilesystemLifecycle} adds `init()`\n * - {@link SandboxLifecycle} adds `start()` / `stop()`\n *\n * @typeParam TInfo - The type returned by getInfo() (e.g., FilesystemInfo, SandboxInfo)\n */\nexport interface Lifecycle<TInfo = unknown> {\n  /** Current status */\n  status: ProviderStatus;\n\n  /** Error message when status is 'error' */\n  error?: string;\n\n  /**\n   * Clean up all resources.\n   *\n   * Called when the workspace is being permanently shut down.\n   * Use for operations like:\n   * - Terminating cloud instances\n   * - Closing all connections\n   * - Cleaning up temporary files\n   */\n  destroy?(): void | Promise<void>;\n\n  /** @deprecated Use `status === 'running'` instead. */\n  isReady?(): boolean | Promise<boolean>;\n\n  /**\n   * Get status and metadata.\n   *\n   * Returns information about the current state of the provider.\n   */\n  getInfo?(): TInfo | Promise<TInfo>;\n}\n\n// =============================================================================\n// Filesystem Lifecycle\n// =============================================================================\n\n/**\n * Lifecycle interface for filesystem providers (two-phase: init  destroy).\n *\n * @typeParam TInfo - The type returned by getInfo()\n */\nexport interface FilesystemLifecycle<TInfo = unknown> extends Lifecycle<TInfo> {\n  /**\n   * One-time setup operations.\n   *\n   * Called once when the workspace is first initialized.\n   * Use for operations like:\n   * - Creating base directories\n   * - Setting up database tables\n   * - Provisioning cloud resources\n   * - Installing dependencies\n   */\n  init?(): void | Promise<void>;\n}\n\n// =============================================================================\n// Sandbox Lifecycle\n// =============================================================================\n\n/**\n * Lifecycle interface for sandbox providers (three-phase: start  stop  destroy).\n *\n * @typeParam TInfo - The type returned by getInfo()\n */\nexport interface SandboxLifecycle<TInfo = unknown> extends Lifecycle<TInfo> {\n  /**\n   * Begin active operation.\n   *\n   * Called to transition from initialized to running state.\n   * Use for operations like:\n   * - Establishing connection pools\n   * - Spinning up cloud instances\n   * - Starting background processes\n   * - Warming up caches\n   */\n  start?(): void | Promise<void>;\n\n  /**\n   * Pause operation, keeping state for potential restart.\n   *\n   * Called to temporarily stop without full cleanup.\n   * Use for operations like:\n   * - Closing connections (but keeping config)\n   * - Pausing cloud instances\n   * - Flushing buffers\n   */\n  stop?(): void | Promise<void>;\n}\n\n// =============================================================================\n// Status Types\n// =============================================================================\n\n/**\n * Common status values for stateful providers.\n *\n * Not all providers need status tracking - local/stateless providers\n * may not use this. But providers with connection pools or cloud\n * instances can use these states.\n */\nexport type ProviderStatus =\n  | 'pending' // Created but not initialized\n  | 'initializing' // Running init()\n  | 'ready' // Initialized, waiting to start (or stateless and ready)\n  | 'starting' // Running start()\n  | 'running' // Active and accepting requests\n  | 'stopping' // Running stop()\n  | 'stopped' // Stopped but can restart\n  | 'destroying' // Running destroy()\n  | 'destroyed' // Fully cleaned up\n  | 'error'; // Something went wrong\n\n// =============================================================================\n// Lifecycle Helper\n// =============================================================================\n\n/**\n * Provider that may have lifecycle methods.\n * Used by `callLifecycle` to dispatch to the correct method.\n */\ninterface LifecycleProvider {\n  _init?(): void | Promise<void>;\n  _start?(): void | Promise<void>;\n  _stop?(): void | Promise<void>;\n  _destroy?(): void | Promise<void>;\n  init?(): void | Promise<void>;\n  start?(): void | Promise<void>;\n  stop?(): void | Promise<void>;\n  destroy?(): void | Promise<void>;\n}\n\n/**\n * Call a lifecycle method on a provider, preferring the `_`-prefixed wrapper\n * (which adds status tracking & race-condition safety) when available,\n * falling back to the plain method for interface-only implementations.\n *\n * @example\n * ```typescript\n * await callLifecycle(sandbox, 'start');   // calls sandbox._start() ?? sandbox.start()\n * await callLifecycle(filesystem, 'init'); // calls filesystem._init() ?? filesystem.init()\n * ```\n */\nexport async function callLifecycle(\n  provider: LifecycleProvider,\n  method: 'init' | 'start' | 'stop' | 'destroy',\n): Promise<void> {\n  const wrapped = `_${method}` as const;\n  const wrappedFn = provider[wrapped];\n  if (typeof wrappedFn === 'function') {\n    await wrappedFn.call(provider);\n  } else {\n    const plainFn = provider[method];\n    if (typeof plainFn === 'function') {\n      await plainFn.call(provider);\n    }\n  }\n}\n","/**\n * CompositeFilesystem - Routes operations to mounted filesystems based on path.\n *\n * Creates a unified filesystem view by combining multiple filesystems at different\n * mount points. Useful for composing local storage, S3, and other backends.\n *\n * @example\n * ```typescript\n * const cfs = new CompositeFilesystem({\n *   mounts: {\n *     '/local': new LocalFilesystem({ basePath: './data' }),\n *     '/s3': new S3Filesystem({ bucket: 'my-bucket', ... }),\n *   }\n * });\n *\n * // readdir('/') returns ['local', 's3']\n * // readFile('/local/file.txt') reads from LocalFilesystem\n * // readFile('/s3/data.json') reads from S3Filesystem\n * ```\n */\n\nimport posixPath from 'node:path/posix';\n\nimport type { RequestContext } from '../../request-context';\nimport { PermissionError } from '../errors';\nimport { callLifecycle } from '../lifecycle';\nimport type { ProviderStatus } from '../lifecycle';\nimport type {\n  WorkspaceFilesystem,\n  FileContent,\n  FileEntry,\n  FileStat,\n  FilesystemInfo,\n  ReadOptions,\n  WriteOptions,\n  ListOptions,\n  CopyOptions,\n  RemoveOptions,\n} from './filesystem';\n\n/**\n * Configuration for CompositeFilesystem.\n */\nexport interface CompositeFilesystemConfig<\n  TMounts extends Record<string, WorkspaceFilesystem> = Record<string, WorkspaceFilesystem>,\n> {\n  /** Map of mount paths to filesystem instances */\n  mounts: TMounts;\n}\n\ninterface ResolvedMount {\n  fs: WorkspaceFilesystem;\n  fsPath: string;\n  mountPath: string;\n}\n\n/**\n * CompositeFilesystem implementation.\n *\n * Routes file operations to the appropriate underlying filesystem based on path.\n * Supports cross-mount operations (copy/move between different filesystems).\n *\n * The generic parameter preserves the concrete types of mounted filesystems,\n * enabling typed access via `mounts.get()`.\n *\n * @example\n * ```typescript\n * const cfs = new CompositeFilesystem({\n *   mounts: {\n *     '/local': new LocalFilesystem({ basePath: './data' }),\n *     '/s3': new S3Filesystem({ bucket: 'my-bucket' }),\n *   },\n * });\n *\n * cfs.mounts.get('/local') // LocalFilesystem\n * cfs.mounts.get('/s3')    // S3Filesystem\n * ```\n */\nexport class CompositeFilesystem<\n  TMounts extends Record<string, WorkspaceFilesystem> = Record<string, WorkspaceFilesystem>,\n> implements WorkspaceFilesystem {\n  readonly id: string;\n  readonly name = 'CompositeFilesystem';\n  readonly provider = 'composite';\n\n  readonly readOnly?: boolean;\n  status: ProviderStatus = 'ready';\n\n  private readonly _mounts: Map<string, WorkspaceFilesystem>;\n\n  constructor(config: CompositeFilesystemConfig<TMounts>) {\n    this.id = `cfs-${Date.now().toString(36)}`;\n    this._mounts = new Map();\n\n    for (const [path, fs] of Object.entries(config.mounts)) {\n      const normalized = this.normalizePath(path);\n      this._mounts.set(normalized, fs);\n    }\n\n    if (this._mounts.size === 0) {\n      throw new Error('CompositeFilesystem requires at least one mount');\n    }\n\n    // Composite is read-only when every mount is read-only\n    this.readOnly = [...this._mounts.values()].every(fs => fs.readOnly) || undefined;\n\n    // Validate no nested mount paths (e.g., /data and /data/sub)\n    const mountPaths = [...this._mounts.keys()];\n    for (const a of mountPaths) {\n      for (const b of mountPaths) {\n        if (a !== b && b.startsWith(a + '/')) {\n          throw new Error(`Nested mount paths are not supported: \"${b}\" is nested under \"${a}\"`);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get all mount paths.\n   */\n  get mountPaths(): string[] {\n    return Array.from(this._mounts.keys());\n  }\n\n  /**\n   * Get the mounts map.\n   * Returns a typed map where `get()` preserves the concrete filesystem type per mount path.\n   */\n  get mounts(): ReadonlyMountMap<TMounts> {\n    return this._mounts as unknown as ReadonlyMountMap<TMounts>;\n  }\n\n  /**\n   * Get status and metadata for this composite filesystem.\n   * Includes info from each mounted filesystem in `metadata.mounts`.\n   */\n  async getInfo(): Promise<FilesystemInfo> {\n    const mounts: Record<string, FilesystemInfo | null> = {};\n    for (const [mountPath, fs] of this._mounts) {\n      mounts[mountPath] = (await fs.getInfo?.()) ?? null;\n    }\n\n    return {\n      id: this.id,\n      name: this.name,\n      provider: this.provider,\n      status: this.status,\n      readOnly: this.readOnly,\n      metadata: { mounts },\n    };\n  }\n\n  /**\n   * Get the underlying filesystem for a given path.\n   * Returns undefined if the path doesn't resolve to any mount.\n   */\n  getFilesystemForPath(path: string): WorkspaceFilesystem | undefined {\n    const resolved = this.resolveMount(path);\n    return resolved?.fs;\n  }\n\n  /**\n   * Get the mount path for a given path.\n   * Returns undefined if the path doesn't resolve to any mount.\n   */\n  getMountPathForPath(path: string): string | undefined {\n    const resolved = this.resolveMount(path);\n    return resolved?.mountPath;\n  }\n\n  /**\n   * Resolve a workspace-relative path to an absolute disk path.\n   * Strips the mount prefix and delegates to the underlying filesystem.\n   */\n  resolveAbsolutePath(path: string): string | undefined {\n    const r = this.resolveMount(path);\n    if (!r) return undefined;\n    return r.fs.resolveAbsolutePath?.(r.fsPath);\n  }\n\n  private normalizePath(path: string): string {\n    if (!path || path === '/') return '/';\n    // posix.normalize resolves dot segments (./foo  foo, a/../b  b)\n    let n = posixPath.normalize(path);\n    if (!n.startsWith('/')) n = `/${n}`;\n    if (n.length > 1 && n.endsWith('/')) n = n.slice(0, -1);\n    return n;\n  }\n\n  private resolveMount(path: string): ResolvedMount | null {\n    const normalized = this.normalizePath(path);\n    let best: { mountPath: string; fs: WorkspaceFilesystem } | null = null;\n\n    for (const [mountPath, fs] of this._mounts) {\n      if (normalized === mountPath || normalized.startsWith(mountPath + '/')) {\n        if (!best || mountPath.length > best.mountPath.length) {\n          best = { mountPath, fs };\n        }\n      }\n    }\n\n    if (!best) return null;\n\n    let fsPath = normalized.slice(best.mountPath.length);\n    if (!fsPath) fsPath = '/';\n    if (!fsPath.startsWith('/')) fsPath = '/' + fsPath;\n\n    return { fs: best.fs, fsPath, mountPath: best.mountPath };\n  }\n\n  private getVirtualEntries(path: string): FileEntry[] | null {\n    const normalized = this.normalizePath(path);\n    if (this.resolveMount(normalized)) return null;\n\n    const entriesMap = new Map<string, FileEntry>();\n    for (const [mountPath, fs] of this._mounts.entries()) {\n      const isUnder = normalized === '/' ? mountPath.startsWith('/') : mountPath.startsWith(normalized + '/');\n\n      if (isUnder) {\n        const remaining = normalized === '/' ? mountPath.slice(1) : mountPath.slice(normalized.length + 1);\n        const next = remaining.split('/')[0];\n        if (next && !entriesMap.has(next)) {\n          // Check if this is a direct mount point (e.g., listing '/' and mount is '/s3')\n          const isDirectMount = remaining === next;\n          const entry: FileEntry = { name: next, type: 'directory' as const };\n\n          // If it's a direct mount point, include filesystem metadata\n          if (isDirectMount) {\n            entry.mount = {\n              provider: fs.provider,\n              icon: fs.icon,\n              displayName: fs.displayName,\n              description: fs.description,\n              status: fs.status,\n              error: fs.error,\n            };\n          }\n\n          entriesMap.set(next, entry);\n        }\n      }\n    }\n\n    return entriesMap.size > 0 ? Array.from(entriesMap.values()) : null;\n  }\n\n  private isVirtualPath(path: string): boolean {\n    const normalized = this.normalizePath(path);\n    if (normalized === '/' && !this._mounts.has('/')) return true;\n    for (const mountPath of this._mounts.keys()) {\n      if (mountPath.startsWith(normalized + '/')) return true;\n    }\n    return false;\n  }\n\n  /**\n   * Assert that a filesystem is writable (not read-only).\n   * @throws {PermissionError} if the filesystem is read-only\n   */\n  private assertWritable(fs: WorkspaceFilesystem, path: string, operation: string): void {\n    if (fs.readOnly) {\n      throw new PermissionError(path, `${operation} (filesystem is read-only)`);\n    }\n  }\n\n  // ===========================================================================\n  // WorkspaceFilesystem Implementation\n  // ===========================================================================\n\n  async init(): Promise<void> {\n    this.status = 'initializing';\n    for (const [mountPath, fs] of this._mounts.entries()) {\n      try {\n        await callLifecycle(fs, 'init');\n      } catch (e) {\n        // Individual mount failed - it will have status='error'\n        // Log but continue with other mounts\n        const message = e instanceof Error ? e.message : String(e);\n        console.warn(`[CompositeFilesystem] Mount \"${mountPath}\" failed to initialize: ${message}`);\n      }\n    }\n    // CompositeFilesystem is ready even if some mounts failed\n    // Operations on errored mounts will be handled by the underlying filesystem\n    this.status = 'ready';\n  }\n\n  async destroy(): Promise<void> {\n    this.status = 'destroying';\n    const errors: Error[] = [];\n    for (const fs of this._mounts.values()) {\n      try {\n        await callLifecycle(fs, 'destroy');\n      } catch (e) {\n        errors.push(e instanceof Error ? e : new Error(String(e)));\n      }\n    }\n    if (errors.length > 0) {\n      this.status = 'error';\n      throw new AggregateError(errors, 'Some filesystems failed to destroy');\n    }\n    this.status = 'destroyed';\n  }\n\n  async readFile(path: string, options?: ReadOptions): Promise<string | Buffer> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    return r.fs.readFile(r.fsPath, options);\n  }\n\n  async writeFile(path: string, content: FileContent, options?: WriteOptions): Promise<void> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    this.assertWritable(r.fs, path, 'writeFile');\n    return r.fs.writeFile(r.fsPath, content, options);\n  }\n\n  async appendFile(path: string, content: FileContent): Promise<void> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    this.assertWritable(r.fs, path, 'appendFile');\n    return r.fs.appendFile(r.fsPath, content);\n  }\n\n  async deleteFile(path: string, options?: RemoveOptions): Promise<void> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    this.assertWritable(r.fs, path, 'deleteFile');\n    return r.fs.deleteFile(r.fsPath, options);\n  }\n\n  async copyFile(src: string, dest: string, options?: CopyOptions): Promise<void> {\n    const srcR = this.resolveMount(src);\n    const destR = this.resolveMount(dest);\n    if (!srcR) throw new Error(`No mount for source: ${src}`);\n    if (!destR) throw new Error(`No mount for dest: ${dest}`);\n    this.assertWritable(destR.fs, dest, 'copyFile');\n\n    // Same mount - delegate\n    if (srcR.mountPath === destR.mountPath) {\n      return srcR.fs.copyFile(srcR.fsPath, destR.fsPath, options);\n    }\n\n    // Cross-mount copy - read then write\n    const content = await srcR.fs.readFile(srcR.fsPath);\n    await destR.fs.writeFile(destR.fsPath, content, { overwrite: options?.overwrite });\n  }\n\n  async moveFile(src: string, dest: string, options?: CopyOptions): Promise<void> {\n    const srcR = this.resolveMount(src);\n    const destR = this.resolveMount(dest);\n    if (!srcR) throw new Error(`No mount for source: ${src}`);\n    if (!destR) throw new Error(`No mount for dest: ${dest}`);\n    this.assertWritable(destR.fs, dest, 'moveFile');\n    this.assertWritable(srcR.fs, src, 'moveFile'); // Source must be writable for delete\n\n    // Same mount - delegate\n    if (srcR.mountPath === destR.mountPath) {\n      return srcR.fs.moveFile(srcR.fsPath, destR.fsPath, options);\n    }\n\n    // Cross-mount move - copy then delete\n    await this.copyFile(src, dest, options);\n    await srcR.fs.deleteFile(srcR.fsPath);\n  }\n\n  async readdir(path: string, options?: ListOptions): Promise<FileEntry[]> {\n    const virtual = this.getVirtualEntries(path);\n    if (virtual) return virtual;\n\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    return r.fs.readdir(r.fsPath, options);\n  }\n\n  async mkdir(path: string, options?: { recursive?: boolean }): Promise<void> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    this.assertWritable(r.fs, path, 'mkdir');\n    return r.fs.mkdir(r.fsPath, options);\n  }\n\n  async rmdir(path: string, options?: RemoveOptions): Promise<void> {\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n    this.assertWritable(r.fs, path, 'rmdir');\n    return r.fs.rmdir(r.fsPath, options);\n  }\n\n  async exists(path: string): Promise<boolean> {\n    if (this.isVirtualPath(path)) return true;\n    const r = this.resolveMount(path);\n    if (!r) return false;\n    // Mount point root always exists (even if errored)\n    if (r.fsPath === '/') return true;\n    return r.fs.exists(r.fsPath);\n  }\n\n  async stat(path: string): Promise<FileStat> {\n    const normalized = this.normalizePath(path);\n\n    if (this.isVirtualPath(path)) {\n      const parts = normalized.split('/').filter(Boolean);\n      const now = new Date();\n      return {\n        name: parts[parts.length - 1] || '',\n        path: normalized,\n        type: 'directory',\n        size: 0,\n        createdAt: now,\n        modifiedAt: now,\n      };\n    }\n\n    const r = this.resolveMount(path);\n    if (!r) throw new Error(`No mount for path: ${path}`);\n\n    // Mount point root always returns directory stat (even if errored)\n    if (r.fsPath === '/') {\n      const parts = normalized.split('/').filter(Boolean);\n      const now = new Date();\n      return {\n        name: parts[parts.length - 1] || '',\n        path: normalized,\n        type: 'directory',\n        size: 0,\n        createdAt: now,\n        modifiedAt: now,\n      };\n    }\n\n    return r.fs.stat(r.fsPath);\n  }\n\n  async isFile(path: string): Promise<boolean> {\n    if (this.isVirtualPath(path)) return false;\n    const r = this.resolveMount(path);\n    if (!r) return false;\n    try {\n      const stat = await r.fs.stat(r.fsPath);\n      return stat.type === 'file';\n    } catch {\n      return false;\n    }\n  }\n\n  async isDirectory(path: string): Promise<boolean> {\n    if (this.isVirtualPath(path)) return true;\n    const r = this.resolveMount(path);\n    if (!r) return false;\n    // Mount point root is always a directory (even if errored)\n    if (r.fsPath === '/') return true;\n    try {\n      const stat = await r.fs.stat(r.fsPath);\n      return stat.type === 'directory';\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Get instructions describing the mounted filesystems.\n   * Used by agents to understand available storage locations.\n   */\n  getInstructions(_opts?: { requestContext?: RequestContext }): string {\n    const mountDescriptions = Array.from(this._mounts.entries())\n      .map(([mountPath, fs]) => {\n        const name = fs.displayName || fs.provider;\n        const access = fs.readOnly ? '(read-only)' : '(read-write)';\n        return `- ${mountPath}: ${name} ${access}`;\n      })\n      .join('\\n');\n\n    return `Filesystem mount points:\\n${mountDescriptions}`;\n  }\n}\n\n/**\n * Distributive mapped type that produces a union of correlated `[key, value]` tuples.\n *\n * For `{ '/local': LocalFilesystem, '/s3': S3Filesystem }` this yields:\n * `['/local', LocalFilesystem] | ['/s3', S3Filesystem]`\n *\n * This enables discriminated-union narrowing when iterating entries without destructuring:\n * ```typescript\n * for (const entry of mounts.entries()) {\n *   if (entry[0] === '/local') {\n *     entry[1] // LocalFilesystem\n *   }\n * }\n * ```\n */\nexport type MountMapEntry<TMounts extends Record<string, WorkspaceFilesystem>> = {\n  [K in string & keyof TMounts]: [K, TMounts[K]];\n}[string & keyof TMounts];\n\n/**\n * A read-only view of mounted filesystems with typed per-key access.\n *\n * Unlike `ReadonlyMap<string, WorkspaceFilesystem>`, this preserves the\n * concrete filesystem type for each mount path via an overloaded `get()`.\n *\n * Iteration methods return correlated `[key, value]` tuples ({@link MountMapEntry})\n * so that checking `entry[0]` narrows `entry[1]` to the concrete filesystem type.\n *\n * @example\n * ```typescript\n * const mounts = cfs.mounts;\n * mounts.get('/local') // LocalFilesystem\n * mounts.get('/s3')    // S3Filesystem\n * ```\n */\nexport interface ReadonlyMountMap<TMounts extends Record<string, WorkspaceFilesystem>> {\n  /** Get a mounted filesystem by path. Returns the concrete type for known mount paths. */\n  get<K extends string & keyof TMounts>(key: K): TMounts[K];\n  get(key: string): WorkspaceFilesystem | undefined;\n\n  has(key: string): boolean;\n  readonly size: number;\n\n  keys(): IterableIterator<string & keyof TMounts>;\n  values(): IterableIterator<TMounts[keyof TMounts & string]>;\n  entries(): IterableIterator<MountMapEntry<TMounts>>;\n  forEach(\n    callbackfn: (\n      value: TMounts[keyof TMounts & string],\n      key: string & keyof TMounts,\n      map: ReadonlyMountMap<TMounts>,\n    ) => void,\n  ): void;\n  [Symbol.iterator](): IterableIterator<MountMapEntry<TMounts>>;\n}\n","/**\n * MastraFilesystem Base Class\n *\n * Abstract base class for filesystem providers that want automatic logger integration\n * and lifecycle management.\n *\n * Extends MastraBase to receive the Mastra logger when registered with a Mastra instance.\n *\n * ## Lifecycle Management\n *\n * The base class provides race-condition-safe lifecycle wrappers:\n * - `_init()` - Handles concurrent calls, status management\n * - `_destroy()` - Handles concurrent calls and status management\n *\n * Subclasses override the plain `init()` and `destroy()` methods to provide\n * their implementation. Callers use the `_`-prefixed wrappers (or `callLifecycle()`)\n * which add status tracking and race-condition safety.\n *\n * External providers can extend this class to get logger support, or implement\n * the WorkspaceFilesystem interface directly if they don't need logging.\n */\n\nimport { MastraBase } from '../../base';\nimport { RegisteredLogger } from '../../logger/constants';\nimport { FilesystemNotReadyError } from '../errors';\nimport type { ProviderStatus } from '../lifecycle';\nimport type {\n  WorkspaceFilesystem,\n  FileContent,\n  FileStat,\n  FileEntry,\n  ReadOptions,\n  WriteOptions,\n  ListOptions,\n  RemoveOptions,\n  CopyOptions,\n} from './filesystem';\n\n/**\n * Lifecycle hook that fires during filesystem state transitions.\n * Receives the filesystem instance so users can inspect state, log, etc.\n */\nexport type FilesystemLifecycleHook = (args: { filesystem: WorkspaceFilesystem }) => void | Promise<void>;\n\n/**\n * Options for the MastraFilesystem base class constructor.\n * Providers extend this to add their own options while inheriting lifecycle hooks.\n */\nexport interface MastraFilesystemOptions {\n  /** Called after the filesystem reaches 'ready' status */\n  onInit?: FilesystemLifecycleHook;\n  /** Called before the filesystem is destroyed */\n  onDestroy?: FilesystemLifecycleHook;\n}\n\n/**\n * Abstract base class for filesystem providers with logger support and lifecycle management.\n *\n * Providers that extend this class automatically receive the Mastra logger\n * when the filesystem is used with a Mastra instance.\n *\n * @example\n * ```typescript\n * class MyCustomFilesystem extends MastraFilesystem {\n *   readonly id = 'my-fs';\n *   readonly name = 'MyCustomFilesystem';\n *   readonly provider = 'custom';\n *   status: ProviderStatus = 'pending';\n *\n *   constructor() {\n *     super({ name: 'MyCustomFilesystem' });\n *   }\n *\n *   // Override init() to provide initialization logic\n *   async init(): Promise<void> {\n *     // Your initialization logic here\n *   }\n *\n *   async readFile(path: string): Promise<string | Buffer> {\n *     await this.ensureReady();\n *     this.logger.debug('Reading file', { path });\n *     // Implementation...\n *   }\n *   // ... implement other WorkspaceFilesystem methods\n * }\n * ```\n */\nexport abstract class MastraFilesystem extends MastraBase implements WorkspaceFilesystem {\n  /** Unique identifier for this filesystem instance */\n  abstract readonly id: string;\n\n  /** Human-readable name (e.g., 'LocalFilesystem', 'AgentFS') */\n  abstract readonly name: string;\n\n  /** Provider type identifier */\n  abstract readonly provider: string;\n\n  /** Current status of the filesystem */\n  abstract status: ProviderStatus;\n\n  /** Error message when status is 'error' */\n  error?: string;\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle Promise Tracking (prevents race conditions)\n  // ---------------------------------------------------------------------------\n\n  /** Promise for _init() to prevent race conditions from concurrent calls */\n  private _initPromise?: Promise<void>;\n\n  /** Promise for _destroy() to prevent race conditions from concurrent calls */\n  private _destroyPromise?: Promise<void>;\n\n  /** Lifecycle callbacks */\n  private readonly _onInit?: FilesystemLifecycleHook;\n  private readonly _onDestroy?: FilesystemLifecycleHook;\n\n  constructor(options: { name: string } & MastraFilesystemOptions) {\n    super({ name: options.name, component: RegisteredLogger.WORKSPACE });\n\n    this._onInit = options.onInit;\n    this._onDestroy = options.onDestroy;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle Wrappers (race-condition-safe)\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Initialize the filesystem (wrapper with status management and race-condition safety).\n   *\n   * This method is race-condition-safe - concurrent calls will return the same promise.\n   * Handles status management automatically.\n   *\n   * Subclasses override `init()` to provide their initialization logic.\n   */\n  async _init(): Promise<void> {\n    // Already ready\n    // Note: intentionally allows re-init after destroy() for reconnect scenarios\n    if (this.status === 'ready') {\n      return;\n    }\n\n    // Wait for any in-progress destroy to complete before (re-)initializing\n    if (this._destroyPromise) {\n      try {\n        await this._destroyPromise;\n      } catch {\n        // Ignore destroy errors  we're re-initializing anyway\n      }\n    }\n\n    // Init already in progress - return existing promise\n    if (this._initPromise) {\n      return this._initPromise;\n    }\n\n    // Create and store the init promise\n    this._initPromise = this._executeInit();\n\n    try {\n      await this._initPromise;\n    } finally {\n      this._initPromise = undefined;\n    }\n  }\n\n  /**\n   * Internal init execution - handles status.\n   */\n  private async _executeInit(): Promise<void> {\n    this.status = 'initializing';\n    this.error = undefined;\n\n    try {\n      await this.init();\n      this.status = 'ready';\n\n      // Fire onInit callback after filesystem is ready  treat failure as non-fatal\n      // so that a bad callback doesn't kill an otherwise healthy filesystem\n      try {\n        await this._onInit?.({ filesystem: this });\n      } catch (error) {\n        this.logger.warn('onInit callback failed', { error });\n      }\n    } catch (error) {\n      this.status = 'error';\n      this.error = error instanceof Error ? error.message : String(error);\n      this.logger.error('Failed to initialize filesystem', { error, id: this.id });\n      throw error;\n    }\n  }\n\n  /**\n   * Override this method to implement filesystem initialization logic.\n   *\n   * Called by `_init()` after status is set to 'initializing'.\n   * Status will be set to 'ready' on success, 'error' on failure.\n   *\n   * @example\n   * ```typescript\n   * async init(): Promise<void> {\n   *   this._client = new StorageClient({ ... });\n   *   await this._client.connect();\n   * }\n   * ```\n   */\n  async init(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  /**\n   * Ensure the filesystem is ready.\n   *\n   * Calls `_init()` if status is not 'ready'. Useful for lazy initialization\n   * where operations should automatically initialize the filesystem if needed.\n   *\n   * @throws {FilesystemNotReadyError} if the filesystem fails to reach 'ready' status\n   *\n   * @example\n   * ```typescript\n   * async readFile(path: string): Promise<string | Buffer> {\n   *   await this.ensureReady();\n   *   // Now safe to use the filesystem\n   * }\n   * ```\n   */\n  protected async ensureReady(): Promise<void> {\n    if (this.status !== 'ready') {\n      await this._init();\n    }\n    if (this.status !== 'ready') {\n      throw new FilesystemNotReadyError(this.id);\n    }\n  }\n\n  /**\n   * Destroy the filesystem and clean up all resources (wrapper with status management).\n   *\n   * This method is race-condition-safe - concurrent calls will return the same promise.\n   * Handles status management.\n   *\n   * Subclasses override `destroy()` to provide their destroy logic.\n   */\n  async _destroy(): Promise<void> {\n    // Already destroyed\n    if (this.status === 'destroyed') {\n      return;\n    }\n\n    // Never initialized  nothing to tear down\n    if (this.status === 'pending') {\n      this.status = 'destroyed';\n      return;\n    }\n\n    // Destroy already in progress - return existing promise\n    if (this._destroyPromise) {\n      return this._destroyPromise;\n    }\n\n    // Create and store the destroy promise\n    this._destroyPromise = this._executeDestroy();\n\n    try {\n      await this._destroyPromise;\n    } finally {\n      this._destroyPromise = undefined;\n    }\n  }\n\n  /**\n   * Internal destroy execution - handles status.\n   */\n  private async _executeDestroy(): Promise<void> {\n    // Wait for any in-progress init to complete before destroying\n    if (this._initPromise) {\n      try {\n        await this._initPromise;\n      } catch {\n        // Ignore init errors  we're destroying anyway\n      }\n    }\n    this.status = 'destroying';\n\n    try {\n      // Fire onDestroy callback before destroying\n      await this._onDestroy?.({ filesystem: this });\n\n      await this.destroy();\n      this.status = 'destroyed';\n    } catch (error) {\n      this.status = 'error';\n      this.logger.error('Failed to destroy filesystem', { error, id: this.id });\n      throw error;\n    }\n  }\n\n  /**\n   * Override this method to implement filesystem destroy logic.\n   *\n   * Called by `_destroy()` after status is set to 'destroying'.\n   * Status will be set to 'destroyed' on success, 'error' on failure.\n   */\n  async destroy(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  // ---------------------------------------------------------------------------\n  // Abstract methods - implementations must provide these\n  // ---------------------------------------------------------------------------\n\n  abstract readFile(path: string, options?: ReadOptions): Promise<string | Buffer>;\n  abstract writeFile(path: string, content: FileContent, options?: WriteOptions): Promise<void>;\n  abstract appendFile(path: string, content: FileContent): Promise<void>;\n  abstract deleteFile(path: string, options?: RemoveOptions): Promise<void>;\n  abstract copyFile(src: string, dest: string, options?: CopyOptions): Promise<void>;\n  abstract moveFile(src: string, dest: string, options?: CopyOptions): Promise<void>;\n  abstract mkdir(path: string, options?: { recursive?: boolean }): Promise<void>;\n  abstract rmdir(path: string, options?: RemoveOptions): Promise<void>;\n  abstract readdir(path: string, options?: ListOptions): Promise<FileEntry[]>;\n  abstract exists(path: string): Promise<boolean>;\n  abstract stat(path: string): Promise<FileStat>;\n}\n","import type { RequestContext } from '../request-context';\nimport type { InstructionsOption } from './types';\n\n/**\n * Resolve an instructions override against default instructions.\n *\n * - `undefined`  return default\n * - `string`  return the string as-is\n * - `function`  call with { defaultInstructions, requestContext }\n */\nexport function resolveInstructions(\n  override: InstructionsOption | undefined,\n  getDefault: () => string,\n  requestContext?: RequestContext,\n): string {\n  if (typeof override === 'string') return override;\n  const defaultInstructions = getDefault();\n  if (override === undefined) return defaultInstructions;\n  return override({ defaultInstructions, requestContext });\n}\n","/**\n * Shared filesystem utilities for LocalFilesystem and LocalSkillSource.\n *\n * These utilities provide consistent implementations for common fs operations.\n */\n\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\n\nimport { FileNotFoundError } from '../errors';\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/**\n * Full file stat information.\n * Used by both WorkspaceFilesystem and SkillSource.\n */\nexport interface FsStatResult {\n  /** File or directory name */\n  name: string;\n  /** 'file' or 'directory' */\n  type: 'file' | 'directory';\n  /** Size in bytes (0 for directories) */\n  size: number;\n  /** Creation time */\n  createdAt: Date;\n  /** Last modification time */\n  modifiedAt: Date;\n  /** MIME type (for files) */\n  mimeType?: string;\n}\n\n// =============================================================================\n// Error Utilities\n// =============================================================================\n\n/**\n * Check if an error is an ENOENT (file not found) error.\n */\nexport function isEnoentError(error: unknown): error is NodeJS.ErrnoException & { code: 'ENOENT' } {\n  return (\n    error !== null && typeof error === 'object' && 'code' in error && (error as NodeJS.ErrnoException).code === 'ENOENT'\n  );\n}\n\n/**\n * Check if an error is an EEXIST (file exists) error.\n */\nexport function isEexistError(error: unknown): error is NodeJS.ErrnoException & { code: 'EEXIST' } {\n  return (\n    error !== null && typeof error === 'object' && 'code' in error && (error as NodeJS.ErrnoException).code === 'EEXIST'\n  );\n}\n\n// =============================================================================\n// MIME Type Detection\n// =============================================================================\n\nconst MIME_TYPES: Record<string, string> = {\n  // Text\n  txt: 'text/plain',\n  html: 'text/html',\n  htm: 'text/html',\n  css: 'text/css',\n  csv: 'text/csv',\n  md: 'text/markdown',\n  // Code\n  js: 'application/javascript',\n  mjs: 'application/javascript',\n  ts: 'application/typescript',\n  tsx: 'application/typescript',\n  jsx: 'application/javascript',\n  json: 'application/json',\n  xml: 'application/xml',\n  yaml: 'text/yaml',\n  yml: 'text/yaml',\n  // Programming languages\n  py: 'text/x-python',\n  rb: 'text/x-ruby',\n  go: 'text/x-go',\n  rs: 'text/x-rust',\n  java: 'text/x-java',\n  c: 'text/x-c',\n  cpp: 'text/x-c++',\n  h: 'text/x-c',\n  hpp: 'text/x-c++',\n  sh: 'text/x-sh',\n  bash: 'text/x-sh',\n  zsh: 'text/x-sh',\n  // Config\n  toml: 'text/toml',\n  ini: 'text/plain',\n  env: 'text/plain',\n  // Database/Query\n  sql: 'text/x-sql',\n  graphql: 'application/graphql',\n  gql: 'application/graphql',\n  // Frameworks\n  vue: 'text/x-vue',\n  // Images\n  png: 'image/png',\n  jpg: 'image/jpeg',\n  jpeg: 'image/jpeg',\n  gif: 'image/gif',\n  svg: 'image/svg+xml',\n  webp: 'image/webp',\n  ico: 'image/x-icon',\n  // Documents\n  pdf: 'application/pdf',\n};\n\n/**\n * Get MIME type for a filename based on extension.\n */\nexport function getMimeType(filename: string): string {\n  const ext = path.extname(filename).slice(1).toLowerCase();\n  return MIME_TYPES[ext] ?? 'application/octet-stream';\n}\n\n/**\n * Extensions that should be treated as text files.\n */\nconst TEXT_EXTENSIONS = new Set([\n  '.md',\n  '.txt',\n  '.json',\n  '.yaml',\n  '.yml',\n  '.js',\n  '.mjs',\n  '.ts',\n  '.tsx',\n  '.jsx',\n  '.py',\n  '.rb',\n  '.go',\n  '.rs',\n  '.java',\n  '.c',\n  '.cpp',\n  '.h',\n  '.hpp',\n  '.sh',\n  '.bash',\n  '.zsh',\n  '.html',\n  '.htm',\n  '.css',\n  '.xml',\n  '.toml',\n  '.ini',\n  '.env',\n  '.csv',\n  '.sql',\n  '.graphql',\n  '.gql',\n  '.vue',\n  '.svg',\n]);\n\n/**\n * Check if a file should be treated as text based on extension.\n */\nexport function isTextFile(filename: string): boolean {\n  const ext = path.extname(filename).toLowerCase();\n  return TEXT_EXTENSIONS.has(ext);\n}\n\n// =============================================================================\n// Path Resolution\n// =============================================================================\n\n/**\n * Resolve a workspace path to an absolute OS filesystem path.\n *\n * Workspace paths typically start with '/' but are relative to `basePath`\n * (e.g. \"/app.ts\"  \"basePath/app.ts\"). However, with `contained: false` or\n * when the path is already a real path within `basePath`, it should be used as-is.\n *\n * @param basePath - The workspace filesystem base path\n * @param filePath - The workspace path to resolve\n * @returns The absolute OS filesystem path\n */\nexport function resolveWorkspacePath(basePath: string, filePath: string): string {\n  if (path.isAbsolute(filePath)) {\n    const normalizedBase = path.normalize(basePath);\n    const normalizedFile = path.normalize(filePath);\n    const rel = path.relative(normalizedBase, normalizedFile);\n    if (!rel.startsWith('..') && !path.isAbsolute(rel)) {\n      return normalizedFile;\n    }\n  }\n  return path.join(basePath, filePath.replace(/^\\/+/, ''));\n}\n\n// =============================================================================\n// Filesystem Operations\n// =============================================================================\n\n/**\n * Check if a path exists.\n * Never throws - returns false on any error.\n *\n * @param absolutePath - The absolute path to check\n * @returns true if path exists and is accessible\n */\nexport async function fsExists(absolutePath: string): Promise<boolean> {\n  try {\n    await fs.access(absolutePath);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get file/directory stats.\n * Throws FileNotFoundError if path doesn't exist.\n *\n * @param absolutePath - The absolute path to stat\n * @param userPath - The user-facing path for error messages\n * @returns File stat information\n * @throws {FileNotFoundError} if path doesn't exist\n */\nexport async function fsStat(absolutePath: string, userPath: string): Promise<FsStatResult> {\n  try {\n    const stats = await fs.stat(absolutePath);\n    return {\n      name: path.basename(absolutePath),\n      type: stats.isDirectory() ? 'directory' : 'file',\n      size: stats.size,\n      createdAt: stats.birthtime,\n      modifiedAt: stats.mtime,\n      mimeType: stats.isFile() ? getMimeType(absolutePath) : undefined,\n    };\n  } catch (error: unknown) {\n    if (isEnoentError(error)) {\n      throw new FileNotFoundError(userPath);\n    }\n    throw error;\n  }\n}\n","/**\n * Local Filesystem Provider\n *\n * A filesystem implementation backed by a folder on the local disk.\n * This is the default filesystem for development and local agents.\n */\n\nimport { constants as fsConstants } from 'node:fs';\nimport * as fs from 'node:fs/promises';\nimport * as nodePath from 'node:path';\nimport type { RequestContext } from '../../request-context';\nimport {\n  FileNotFoundError,\n  DirectoryNotFoundError,\n  FileExistsError,\n  IsDirectoryError,\n  NotDirectoryError,\n  DirectoryNotEmptyError,\n  PermissionError,\n  WorkspaceReadOnlyError,\n} from '../errors';\nimport type { ProviderStatus } from '../lifecycle';\nimport type { InstructionsOption } from '../types';\nimport { resolveInstructions } from '../utils';\nimport type {\n  FilesystemInfo,\n  FileContent,\n  FileStat,\n  FileEntry,\n  ReadOptions,\n  WriteOptions,\n  ListOptions,\n  RemoveOptions,\n  CopyOptions,\n} from './filesystem';\nimport { fsExists, fsStat, isEnoentError, isEexistError, resolveWorkspacePath } from './fs-utils';\nimport { MastraFilesystem } from './mastra-filesystem';\nimport type { MastraFilesystemOptions } from './mastra-filesystem';\n\n/**\n * Local filesystem provider configuration.\n */\nexport interface LocalFilesystemOptions extends MastraFilesystemOptions {\n  /** Unique identifier for this filesystem instance */\n  id?: string;\n  /** Base directory path on disk */\n  basePath: string;\n  /**\n   * When true, all file operations are restricted to stay within basePath.\n   * Prevents path traversal attacks and symlink escapes.\n   *\n   * Path resolution depends on this setting:\n   * - `contained: true` (default)  Absolute paths that fall within basePath are\n   *   used as-is; all other absolute paths are treated as virtual (resolved\n   *   relative to basePath, e.g. `/file.txt`  `basePath/file.txt`). Any\n   *   resolved path that escapes basePath throws a PermissionError.\n   * - `contained: false`  Absolute paths are always treated as real filesystem\n   *   paths. No containment check is applied.\n   *\n   * Set to `false` when the filesystem needs to access paths outside basePath,\n   * such as global skills directories or user home directories.\n   *\n   * @default true\n   */\n  contained?: boolean;\n  /**\n   * When true, all write operations to this filesystem are blocked.\n   * Read operations are still allowed.\n   * @default false\n   */\n  readOnly?: boolean;\n  /**\n   * Additional paths (absolute) that are allowed beyond basePath.\n   * Useful with `contained: true` to grant access to specific directories\n   * outside the basePath without disabling containment entirely.\n   *\n   * Paths are resolved to absolute paths using `path.resolve()`.\n   *\n   * @example\n   * ```typescript\n   * new LocalFilesystem({\n   *   basePath: '/project',\n   *   contained: true,\n   *   allowedPaths: ['/home/user/.config'],\n   * })\n   * ```\n   */\n  allowedPaths?: string[];\n  /**\n   * Custom instructions that override the default instructions\n   * returned by `getInstructions()`.\n   *\n   * - `string`  Fully replaces the default instructions.\n   *   Pass an empty string to suppress instructions entirely.\n   * - `(opts) => string`  Receives the default instructions and\n   *   optional request context so you can extend or customise per-request.\n   */\n  instructions?: InstructionsOption;\n}\n\n/**\n * Local filesystem implementation.\n *\n * Stores files in a folder on the user's machine.\n * This is the recommended filesystem for development and persistent local storage.\n *\n * @example\n * ```typescript\n * import { Workspace, LocalFilesystem } from '@mastra/core';\n *\n * const workspace = new Workspace({\n *   filesystem: new LocalFilesystem({ basePath: './my-workspace' }),\n * });\n *\n * await workspace.init();\n * await workspace.writeFile('/hello.txt', 'Hello World!');\n * ```\n */\nexport class LocalFilesystem extends MastraFilesystem {\n  readonly id: string;\n  readonly name = 'LocalFilesystem';\n  readonly provider = 'local';\n  readonly readOnly?: boolean;\n\n  status: ProviderStatus = 'pending';\n\n  private readonly _basePath: string;\n  private readonly _contained: boolean;\n  private _allowedPaths: string[];\n  private readonly _instructionsOverride?: InstructionsOption;\n\n  /**\n   * The absolute base path on disk where files are stored.\n   * Useful for understanding how workspace paths map to disk paths.\n   */\n  get basePath(): string {\n    return this._basePath;\n  }\n\n  /**\n   * Current set of additional allowed paths (absolute, resolved).\n   * These paths are permitted beyond basePath when containment is enabled.\n   */\n  get allowedPaths(): readonly string[] {\n    return this._allowedPaths;\n  }\n\n  /**\n   * Update allowed paths. Accepts a direct array or an updater callback\n   * receiving the current paths (React setState pattern).\n   *\n   * @example\n   * ```typescript\n   * // Set directly\n   * fs.setAllowedPaths(['/home/user/.config']);\n   *\n   * // Update with callback\n   * fs.setAllowedPaths(prev => [...prev, '/home/user/.ssh']);\n   * ```\n   */\n  setAllowedPaths(pathsOrUpdater: string[] | ((current: readonly string[]) => string[])): void {\n    const newPaths = typeof pathsOrUpdater === 'function' ? pathsOrUpdater(this._allowedPaths) : pathsOrUpdater;\n    this._allowedPaths = newPaths.map(p => nodePath.resolve(p));\n  }\n\n  constructor(options: LocalFilesystemOptions) {\n    super({ ...options, name: 'LocalFilesystem' });\n    this.id = options.id ?? this.generateId();\n    this._basePath = nodePath.resolve(options.basePath);\n    this._contained = options.contained ?? true;\n    this.readOnly = options.readOnly;\n    this._allowedPaths = (options.allowedPaths ?? []).map(p => nodePath.resolve(p));\n    this._instructionsOverride = options.instructions;\n  }\n\n  private generateId(): string {\n    return `local-fs-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n  }\n\n  /**\n   * Check if an absolute path falls within basePath or any allowed path.\n   */\n  private _isWithinAnyRoot(absolutePath: string): boolean {\n    const roots = [this._basePath, ...this._allowedPaths];\n    return roots.some(root => {\n      const relative = nodePath.relative(root, absolutePath);\n      return !relative.startsWith('..') && !nodePath.isAbsolute(relative);\n    });\n  }\n\n  private toBuffer(content: FileContent): Buffer {\n    if (Buffer.isBuffer(content)) return content;\n    if (content instanceof Uint8Array) return Buffer.from(content);\n    return Buffer.from(content, 'utf-8');\n  }\n\n  private resolvePath(inputPath: string): string {\n    let absolutePath: string;\n\n    if (!this._contained && nodePath.isAbsolute(inputPath)) {\n      // Containment disabled  absolute paths are real filesystem paths\n      absolutePath = nodePath.normalize(inputPath);\n    } else if (this._contained && nodePath.isAbsolute(inputPath)) {\n      // Containment enabled  check if this is a real path within basePath\n      // or an allowed path (e.g. \"/Users/foo/project/src\") vs the virtual-root\n      // convention (e.g. \"/file.txt\" meaning \"basePath/file.txt\")\n      const normalized = nodePath.normalize(inputPath);\n      if (this._isWithinAnyRoot(normalized)) {\n        absolutePath = normalized;\n      } else {\n        absolutePath = resolveWorkspacePath(this._basePath, inputPath);\n      }\n    } else {\n      absolutePath = resolveWorkspacePath(this._basePath, inputPath);\n    }\n\n    if (this._contained) {\n      if (!this._isWithinAnyRoot(absolutePath)) {\n        throw new PermissionError(inputPath, 'access');\n      }\n    }\n\n    return absolutePath;\n  }\n\n  /**\n   * Resolve a workspace-relative path to an absolute disk path.\n   * Uses the same resolution logic as internal file operations.\n   * Returns `undefined` if the path violates containment.\n   */\n  resolveAbsolutePath(inputPath: string): string | undefined {\n    try {\n      return this.resolvePath(inputPath);\n    } catch {\n      // PermissionError from containment check  path is not resolvable\n      return undefined;\n    }\n  }\n\n  private toRelativePath(absolutePath: string): string {\n    return '/' + nodePath.relative(this._basePath, absolutePath).replace(/\\\\/g, '/');\n  }\n\n  private assertWritable(operation: string): void {\n    if (this.readOnly) {\n      throw new WorkspaceReadOnlyError(operation);\n    }\n  }\n\n  /**\n   * Verify that the resolved path doesn't escape basePath via symlinks.\n   * Uses realpath to resolve symlinks and check the actual target.\n   */\n  private async assertPathContained(absolutePath: string): Promise<void> {\n    if (!this._contained) return;\n\n    // Resolve real paths for all roots (basePath + allowedPaths)\n    const rootReals: string[] = [];\n    for (const root of [this._basePath, ...this._allowedPaths]) {\n      try {\n        rootReals.push(await fs.realpath(root));\n      } catch (error: unknown) {\n        if (isEnoentError(error)) {\n          // Root doesn't exist yet  skip (operations will fail naturally)\n          continue;\n        }\n        throw error;\n      }\n    }\n\n    if (rootReals.length === 0) {\n      throw new DirectoryNotFoundError(this._basePath);\n    }\n\n    let targetReal: string;\n    try {\n      targetReal = await fs.realpath(absolutePath);\n    } catch (error: unknown) {\n      // If path doesn't exist, walk up to find an existing parent\n      if (isEnoentError(error)) {\n        let parentPath = absolutePath;\n        while (true) {\n          const nextParent = nodePath.dirname(parentPath);\n          if (nextParent === parentPath) {\n            // Reached filesystem root without finding existing directory\n            throw new DirectoryNotFoundError(absolutePath);\n          }\n          parentPath = nextParent;\n          try {\n            targetReal = await fs.realpath(parentPath);\n            break;\n          } catch (parentError: unknown) {\n            if (!isEnoentError(parentError)) {\n              throw parentError;\n            }\n            // Continue walking up\n          }\n        }\n      } else {\n        throw error;\n      }\n    }\n\n    const isWithinRoot = rootReals.some(\n      rootReal => targetReal === rootReal || targetReal.startsWith(rootReal + nodePath.sep),\n    );\n\n    if (!isWithinRoot) {\n      throw new PermissionError(absolutePath, 'access');\n    }\n  }\n\n  async readFile(inputPath: string, options?: ReadOptions): Promise<string | Buffer> {\n    this.logger.debug('Reading file', { path: inputPath, encoding: options?.encoding });\n    await this.ensureReady();\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    try {\n      const stats = await fs.stat(absolutePath);\n      if (stats.isDirectory()) {\n        throw new IsDirectoryError(inputPath);\n      }\n\n      if (options?.encoding) {\n        return await fs.readFile(absolutePath, { encoding: options.encoding });\n      }\n      return await fs.readFile(absolutePath);\n    } catch (error: unknown) {\n      if (error instanceof IsDirectoryError) throw error;\n      if (isEnoentError(error)) {\n        throw new FileNotFoundError(inputPath);\n      }\n      throw error;\n    }\n  }\n\n  async writeFile(inputPath: string, content: FileContent, options?: WriteOptions): Promise<void> {\n    const contentSize = Buffer.isBuffer(content) ? content.length : content.length;\n    this.logger.debug('Writing file', { path: inputPath, size: contentSize, recursive: options?.recursive });\n    await this.ensureReady();\n    this.assertWritable('writeFile');\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    // When recursive is explicitly false, verify parent directory exists\n    if (options?.recursive === false) {\n      const dir = nodePath.dirname(absolutePath);\n      const parentPath = nodePath.dirname(inputPath);\n      try {\n        const stat = await fs.stat(dir);\n        if (!stat.isDirectory()) {\n          throw new NotDirectoryError(parentPath);\n        }\n      } catch (error: unknown) {\n        if (error instanceof NotDirectoryError) throw error;\n        if (isEnoentError(error)) {\n          throw new DirectoryNotFoundError(parentPath);\n        }\n        throw error;\n      }\n    }\n\n    if (options?.recursive !== false) {\n      const dir = nodePath.dirname(absolutePath);\n      await fs.mkdir(dir, { recursive: true });\n    }\n\n    // Use 'wx' flag for atomic overwrite check (avoids TOCTOU race)\n    const writeFlag = options?.overwrite === false ? 'wx' : 'w';\n    try {\n      await fs.writeFile(absolutePath, this.toBuffer(content), { flag: writeFlag });\n    } catch (error: unknown) {\n      if (options?.overwrite === false && isEexistError(error)) {\n        throw new FileExistsError(inputPath);\n      }\n      throw error;\n    }\n  }\n\n  async appendFile(inputPath: string, content: FileContent): Promise<void> {\n    const contentSize = Buffer.isBuffer(content) ? content.length : content.length;\n    this.logger.debug('Appending to file', { path: inputPath, size: contentSize });\n    await this.ensureReady();\n    this.assertWritable('appendFile');\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n    const dir = nodePath.dirname(absolutePath);\n    await fs.mkdir(dir, { recursive: true });\n    await fs.appendFile(absolutePath, this.toBuffer(content));\n  }\n\n  async deleteFile(inputPath: string, options?: RemoveOptions): Promise<void> {\n    this.logger.debug('Deleting file', { path: inputPath, force: options?.force });\n    await this.ensureReady();\n    this.assertWritable('deleteFile');\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    try {\n      const stats = await fs.stat(absolutePath);\n      if (stats.isDirectory()) {\n        throw new IsDirectoryError(inputPath);\n      }\n      await fs.unlink(absolutePath);\n    } catch (error: unknown) {\n      if (error instanceof IsDirectoryError) throw error;\n      if (isEnoentError(error)) {\n        if (!options?.force) {\n          throw new FileNotFoundError(inputPath);\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async copyFile(src: string, dest: string, options?: CopyOptions): Promise<void> {\n    this.logger.debug('Copying file', { src, dest, recursive: options?.recursive });\n    await this.ensureReady();\n    this.assertWritable('copyFile');\n    const srcPath = this.resolvePath(src);\n    const destPath = this.resolvePath(dest);\n    await this.assertPathContained(srcPath);\n    await this.assertPathContained(destPath);\n\n    try {\n      const stats = await fs.stat(srcPath);\n      if (stats.isDirectory()) {\n        if (!options?.recursive) {\n          throw new IsDirectoryError(src);\n        }\n        await this.copyDirectory(srcPath, destPath, options);\n      } else {\n        await fs.mkdir(nodePath.dirname(destPath), { recursive: true });\n        // Use COPYFILE_EXCL for atomic overwrite check (avoids TOCTOU race)\n        const copyFlags = options?.overwrite === false ? fsConstants.COPYFILE_EXCL : 0;\n        try {\n          await fs.copyFile(srcPath, destPath, copyFlags);\n        } catch (error: unknown) {\n          if (options?.overwrite === false && isEexistError(error)) {\n            throw new FileExistsError(dest);\n          }\n          throw error;\n        }\n      }\n    } catch (error: unknown) {\n      if (error instanceof IsDirectoryError || error instanceof FileExistsError) throw error;\n      if (isEnoentError(error)) {\n        throw new FileNotFoundError(src);\n      }\n      throw error;\n    }\n  }\n\n  private async copyDirectory(src: string, dest: string, options?: CopyOptions): Promise<void> {\n    await this.ensureReady();\n    await fs.mkdir(dest, { recursive: true });\n    const entries = await fs.readdir(src, { withFileTypes: true });\n\n    for (const entry of entries) {\n      const srcEntry = nodePath.join(src, entry.name);\n      const destEntry = nodePath.join(dest, entry.name);\n\n      // Verify entries don't escape sandbox via symlink\n      await this.assertPathContained(srcEntry);\n      await this.assertPathContained(destEntry);\n\n      if (entry.isDirectory()) {\n        await this.copyDirectory(srcEntry, destEntry, options);\n      } else {\n        // Use COPYFILE_EXCL for atomic overwrite check (avoids TOCTOU race)\n        const copyFlags = options?.overwrite === false ? fsConstants.COPYFILE_EXCL : 0;\n        try {\n          await fs.copyFile(srcEntry, destEntry, copyFlags);\n        } catch (error: unknown) {\n          if (options?.overwrite === false && isEexistError(error)) {\n            // Skip existing files when overwrite is false\n            continue;\n          }\n          throw error;\n        }\n      }\n    }\n  }\n\n  async moveFile(src: string, dest: string, options?: CopyOptions): Promise<void> {\n    this.logger.debug('Moving file', { src, dest, overwrite: options?.overwrite });\n    await this.ensureReady();\n    this.assertWritable('moveFile');\n    const srcPath = this.resolvePath(src);\n    const destPath = this.resolvePath(dest);\n    await this.assertPathContained(srcPath);\n    await this.assertPathContained(destPath);\n\n    try {\n      await fs.mkdir(nodePath.dirname(destPath), { recursive: true });\n\n      // When overwrite: false, use copy+delete to avoid TOCTOU race condition.\n      // copyFile uses COPYFILE_EXCL which atomically checks and writes.\n      if (options?.overwrite === false) {\n        await this.copyFile(src, dest, { ...options, overwrite: false });\n        await fs.rm(srcPath, { recursive: true, force: true });\n        return;\n      }\n\n      try {\n        await fs.rename(srcPath, destPath);\n      } catch (error: unknown) {\n        // Only fall back to copy+delete for cross-device moves (EXDEV)\n        const code = (error as NodeJS.ErrnoException).code;\n        if (code !== 'EXDEV') {\n          throw error;\n        }\n        await this.copyFile(src, dest, options);\n        await fs.rm(srcPath, { recursive: true, force: true });\n      }\n    } catch (error: unknown) {\n      if (error instanceof FileExistsError) throw error;\n      if (isEnoentError(error)) {\n        throw new FileNotFoundError(src);\n      }\n      throw error;\n    }\n  }\n\n  async mkdir(inputPath: string, options?: { recursive?: boolean }): Promise<void> {\n    this.logger.debug('Creating directory', { path: inputPath, recursive: options?.recursive });\n    await this.ensureReady();\n    this.assertWritable('mkdir');\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    try {\n      await fs.mkdir(absolutePath, { recursive: options?.recursive ?? true });\n    } catch (error: unknown) {\n      if (isEexistError(error)) {\n        const stats = await fs.stat(absolutePath);\n        if (!stats.isDirectory()) {\n          throw new FileExistsError(inputPath);\n        }\n      } else if (isEnoentError(error)) {\n        // Parent directory doesn't exist (only happens when recursive: false)\n        const parentPath = nodePath.dirname(inputPath);\n        throw new DirectoryNotFoundError(parentPath);\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async rmdir(inputPath: string, options?: RemoveOptions): Promise<void> {\n    this.logger.debug('Removing directory', { path: inputPath, recursive: options?.recursive, force: options?.force });\n    await this.ensureReady();\n    this.assertWritable('rmdir');\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    try {\n      const stats = await fs.stat(absolutePath);\n      if (!stats.isDirectory()) {\n        throw new NotDirectoryError(inputPath);\n      }\n\n      if (options?.recursive) {\n        await fs.rm(absolutePath, { recursive: true, force: options?.force ?? false });\n      } else {\n        const entries = await fs.readdir(absolutePath);\n        if (entries.length > 0) {\n          throw new DirectoryNotEmptyError(inputPath);\n        }\n        await fs.rmdir(absolutePath);\n      }\n    } catch (error: unknown) {\n      if (error instanceof NotDirectoryError || error instanceof DirectoryNotEmptyError) {\n        throw error;\n      }\n      if (isEnoentError(error)) {\n        if (!options?.force) {\n          throw new DirectoryNotFoundError(inputPath);\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async readdir(inputPath: string, options?: ListOptions): Promise<FileEntry[]> {\n    this.logger.debug('Reading directory', { path: inputPath, recursive: options?.recursive });\n    await this.ensureReady();\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n\n    try {\n      const stats = await fs.stat(absolutePath);\n      if (!stats.isDirectory()) {\n        throw new NotDirectoryError(inputPath);\n      }\n\n      const entries = await fs.readdir(absolutePath, { withFileTypes: true });\n      const result: FileEntry[] = [];\n\n      for (const entry of entries) {\n        const entryPath = nodePath.join(absolutePath, entry.name);\n\n        if (options?.extension) {\n          const extensions = Array.isArray(options.extension) ? options.extension : [options.extension];\n          if (entry.isFile()) {\n            const ext = nodePath.extname(entry.name);\n            if (!extensions.some(e => e === ext || e === ext.slice(1))) {\n              continue;\n            }\n          }\n        }\n\n        // Check if entry is a symlink\n        const isSymlink = entry.isSymbolicLink();\n        let symlinkTarget: string | undefined;\n        let resolvedType: 'file' | 'directory' = 'file';\n\n        if (isSymlink) {\n          try {\n            // Get the symlink target path\n            symlinkTarget = await fs.readlink(entryPath);\n            // Determine the type of the target (follow the symlink)\n            const targetStat = await fs.stat(entryPath);\n            resolvedType = targetStat.isDirectory() ? 'directory' : 'file';\n          } catch {\n            // If we can't read the symlink target or it's broken, treat as file\n            resolvedType = 'file';\n          }\n        } else {\n          resolvedType = entry.isDirectory() ? 'directory' : 'file';\n        }\n\n        const fileEntry: FileEntry = {\n          name: entry.name,\n          type: resolvedType,\n          isSymlink: isSymlink || undefined,\n          symlinkTarget,\n        };\n\n        if (resolvedType === 'file' && !isSymlink) {\n          try {\n            const stat = await fs.stat(entryPath);\n            fileEntry.size = stat.size;\n          } catch {\n            // Ignore\n          }\n        }\n\n        result.push(fileEntry);\n\n        // Only recurse into directories (follow symlinks to directories)\n        if (options?.recursive && resolvedType === 'directory') {\n          // Default to 100 to prevent stack overflow on deeply nested structures\n          const depth = options.maxDepth ?? 100;\n          if (depth > 0) {\n            const subEntries = await this.readdir(this.toRelativePath(entryPath), { ...options, maxDepth: depth - 1 });\n            result.push(\n              ...subEntries.map(e => ({\n                ...e,\n                name: `${entry.name}/${e.name}`,\n              })),\n            );\n          }\n        }\n      }\n\n      return result;\n    } catch (error: unknown) {\n      if (error instanceof NotDirectoryError) throw error;\n      if (isEnoentError(error)) {\n        throw new DirectoryNotFoundError(inputPath);\n      }\n      throw error;\n    }\n  }\n\n  async exists(inputPath: string): Promise<boolean> {\n    await this.ensureReady();\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n    return fsExists(absolutePath);\n  }\n\n  async stat(inputPath: string): Promise<FileStat> {\n    await this.ensureReady();\n    const absolutePath = this.resolvePath(inputPath);\n    await this.assertPathContained(absolutePath);\n    const result = await fsStat(absolutePath, inputPath);\n    return {\n      ...result,\n      path: this.toRelativePath(absolutePath),\n    };\n  }\n\n  /**\n   * Initialize the local filesystem by creating the base directory.\n   * Status management is handled by the base class.\n   */\n  async init(): Promise<void> {\n    this.logger.debug('Initializing filesystem', { basePath: this._basePath });\n    await fs.mkdir(this._basePath, { recursive: true });\n    this.logger.debug('Filesystem initialized', { basePath: this._basePath });\n  }\n\n  /**\n   * Clean up the local filesystem.\n   * LocalFilesystem doesn't delete files on destroy by default.\n   * Status management is handled by the base class.\n   */\n  async destroy(): Promise<void> {\n    // LocalFilesystem doesn't clean up files on destroy by default\n  }\n\n  getInfo(): FilesystemInfo<{ basePath: string; contained: boolean; allowedPaths?: string[] }> {\n    return {\n      id: this.id,\n      name: this.name,\n      provider: this.provider,\n      readOnly: this.readOnly,\n      status: this.status,\n      error: this.error,\n      metadata: {\n        basePath: this.basePath,\n        contained: this._contained,\n        ...(this._allowedPaths.length > 0 && { allowedPaths: [...this._allowedPaths] }),\n      },\n    };\n  }\n\n  getInstructions(opts?: { requestContext?: RequestContext }): string {\n    return resolveInstructions(this._instructionsOverride, () => this._getDefaultInstructions(), opts?.requestContext);\n  }\n\n  private _getDefaultInstructions(): string {\n    const allowedNote =\n      this._allowedPaths.length > 0\n        ? ` Additionally, the following paths outside basePath are accessible: ${this._allowedPaths.join(', ')}.`\n        : '';\n    if (this._contained) {\n      return `Local filesystem at \"${this.basePath}\". Files at workspace path \"/foo\" are stored at \"${this.basePath}/foo\" on disk.${allowedNote}`;\n    }\n    return `Local filesystem rooted at \"${this.basePath}\". Containment is disabled so absolute paths access the real filesystem. Use paths relative to \"${this.basePath}\" (e.g. \"foo/bar.txt\") for workspace files. Avoid unnecessary listing \"/\" as it would traverse the entire host filesystem.${allowedNote}`;\n  }\n}\n","import * as nodePath from 'node:path';\n\n/**\n * File Read Tracker\n *\n * Tracks when files were last read by the workspace.\n * Used to enforce \"read before write\" semantics.\n */\n\n/**\n * Record of when a file was read.\n */\nexport interface FileReadRecord {\n  /** The file path that was read */\n  path: string;\n  /** When the file was read */\n  readAt: Date;\n  /** The file's modification time when it was read */\n  modifiedAtRead: Date;\n}\n\n/**\n * Interface for tracking file reads.\n */\nexport interface FileReadTracker {\n  /** Record that a file was read */\n  recordRead(path: string, modifiedAt: Date): void;\n\n  /** Get the last read record for a path */\n  getReadRecord(path: string): FileReadRecord | undefined;\n\n  /**\n   * Check if file needs re-reading.\n   * Returns needsReRead: true if file was never read or was modified since last read.\n   */\n  needsReRead(path: string, currentModifiedAt: Date): { needsReRead: boolean; reason?: string };\n\n  /** Clear read record (typically after a successful write) */\n  clearReadRecord(path: string): void;\n\n  /** Clear all records */\n  clear(): void;\n}\n\n/**\n * In-memory implementation of FileReadTracker.\n */\nexport class InMemoryFileReadTracker implements FileReadTracker {\n  private records = new Map<string, FileReadRecord>();\n\n  recordRead(path: string, modifiedAt: Date): void {\n    const normalizedPath = this.normalizePath(path);\n    this.records.set(normalizedPath, {\n      path: normalizedPath,\n      readAt: new Date(),\n      modifiedAtRead: modifiedAt,\n    });\n  }\n\n  getReadRecord(path: string): FileReadRecord | undefined {\n    return this.records.get(this.normalizePath(path));\n  }\n\n  needsReRead(path: string, currentModifiedAt: Date): { needsReRead: boolean; reason?: string } {\n    const record = this.getReadRecord(path);\n\n    if (!record) {\n      return {\n        needsReRead: true,\n        reason: `File \"${path}\" has not been read. You must read a file before writing to it.`,\n      };\n    }\n\n    // Compare timestamps - if current modification time is newer than when we read it\n    if (currentModifiedAt.getTime() > record.modifiedAtRead.getTime()) {\n      return {\n        needsReRead: true,\n        reason: `File \"${path}\" was modified since last read (read at: ${record.modifiedAtRead.toISOString()}, current: ${currentModifiedAt.toISOString()}). Please re-read the file to get the latest contents.`,\n      };\n    }\n\n    return { needsReRead: false };\n  }\n\n  clearReadRecord(path: string): void {\n    this.records.delete(this.normalizePath(path));\n  }\n\n  clear(): void {\n    this.records.clear();\n  }\n\n  private normalizePath(pathStr: string): string {\n    // Normalize path: unify separators, resolve dot segments, remove trailing slash\n    const normalized = nodePath.posix.normalize(pathStr.replace(/\\\\/g, '/'));\n    return normalized.replace(/\\/$/, '') || '/';\n  }\n}\n","import * as nodePath from 'node:path';\n\n/**\n * File Write Lock\n *\n * Per-file promise queue that serializes write operations to the same path.\n * Prevents read-modify-write race conditions when multiple tool calls\n * target the same file concurrently.\n */\n\n/** Options for constructing a FileWriteLock. */\nexport interface FileWriteLockOptions {\n  /** Maximum time (ms) a single lock-holder may run before being rejected. Default: 30 000. */\n  timeoutMs?: number;\n}\n\n/**\n * Interface for per-file write locking.\n */\nexport interface FileWriteLock {\n  /** Execute `fn` while holding an exclusive lock on `filePath`. */\n  withLock<T>(filePath: string, fn: () => Promise<T>): Promise<T>;\n\n  /** Number of paths that currently have queued operations. */\n  get size(): number;\n}\n\n/**\n * In-memory implementation of FileWriteLock using per-path promise queues.\n *\n * Adapted from mastracode's `withWriteLock` pattern.\n */\nexport class InMemoryFileWriteLock implements FileWriteLock {\n  private queues = new Map<string, Promise<void>>();\n  private readonly timeoutMs: number;\n\n  constructor(opts?: FileWriteLockOptions) {\n    this.timeoutMs = opts?.timeoutMs ?? 30_000;\n  }\n\n  get size(): number {\n    return this.queues.size;\n  }\n\n  withLock<T>(filePath: string, fn: () => Promise<T>): Promise<T> {\n    const key = this.normalizePath(filePath);\n\n    // Get the current queue for this file (or a resolved promise if none)\n    const currentQueue = this.queues.get(key) ?? Promise.resolve();\n\n    // Create a deferred promise for our result\n    let resolve!: (value: T) => void;\n    let reject!: (error: unknown) => void;\n    const resultPromise = new Promise<T>((res, rej) => {\n      resolve = res;\n      reject = rej;\n    });\n\n    // Chain our operation onto the queue\n    const queuePromise = currentQueue\n      .catch(() => {}) // Ignore errors from previous operations\n      .then(async () => {\n        let timeoutId: ReturnType<typeof setTimeout> | undefined;\n        try {\n          const result = await Promise.race([\n            fn(),\n            new Promise<never>((_, rej) => {\n              timeoutId = setTimeout(\n                () => rej(new Error(`write-lock timeout on \"${key}\" after ${this.timeoutMs}ms`)),\n                this.timeoutMs,\n              );\n            }),\n          ]);\n          clearTimeout(timeoutId);\n          resolve(result);\n        } catch (error) {\n          clearTimeout(timeoutId);\n          reject(error);\n        }\n      });\n\n    // Update the queue\n    this.queues.set(key, queuePromise);\n\n    // Clean up when our operation completes\n    void queuePromise.finally(() => {\n      // Only delete if we're still the last in queue\n      if (this.queues.get(key) === queuePromise) {\n        this.queues.delete(key);\n      }\n    });\n\n    return resultPromise;\n  }\n\n  private normalizePath(pathStr: string): string {\n    // Normalize path: unify separators, resolve dot segments, remove trailing slash.\n    //\n    // Known limitations:\n    // - Case-sensitive comparison: on case-insensitive filesystems (macOS HFS+,\n    //   Windows NTFS) \"Foo.txt\" and \"foo.txt\" produce different lock keys.\n    //   Acceptable because workspace tool calls echo paths back consistently.\n    // - No base-directory resolution: \"foo.txt\" and \"/workspace/foo.txt\" are\n    //   distinct keys. Workspace tools pass paths relative to the workspace root,\n    //   so this doesn't arise in practice.\n    // Collapse leading //+ before normalize (POSIX preserves leading //)\n    const normalized = nodePath.posix.normalize(pathStr.replace(/\\\\/g, '/').replace(/^\\/\\/+/, '/'));\n    return normalized.replace(/\\/+$/, '') || '/';\n  }\n}\n","/**\n * Glob Pattern Utilities\n *\n * Shared glob pattern matching for workspace operations.\n * Uses picomatch for battle-tested glob support including\n * brace expansion, character classes, negation, and `**`.\n */\n\nimport picomatch from 'picomatch';\n\n// =============================================================================\n// Glob Metacharacter Detection\n// =============================================================================\n\n/** Characters that indicate a glob pattern (not a plain path) */\nconst GLOB_CHARS = /[*?{}[\\]]/;\n\n/**\n * Check if a string contains glob metacharacters.\n *\n * @example\n * isGlobPattern('/docs')           // false\n * isGlobPattern('/docs/**\\/*.md')   // true\n * isGlobPattern('*.ts')            // true\n * isGlobPattern('/src/{a,b}')      // true\n */\nexport function isGlobPattern(input: string): boolean {\n  return GLOB_CHARS.test(input);\n}\n\n// =============================================================================\n// Glob Base Extraction\n// =============================================================================\n\n/**\n * Extract the static directory prefix before the first glob metacharacter.\n * Returns the deepest non-glob ancestor directory.\n *\n * @example\n * extractGlobBase('/docs/**\\/*.md')  // '/docs'\n * extractGlobBase('**\\/*.md')        // '/'\n * extractGlobBase('/src/*.ts')      // '/src'\n * extractGlobBase('/exact/path')    // '/exact/path'\n */\nexport function extractGlobBase(pattern: string): string {\n  // Find position of first glob metacharacter\n  const firstMeta = pattern.search(GLOB_CHARS);\n\n  if (firstMeta === -1) {\n    // No glob chars  return the pattern as-is (it's a plain path)\n    return pattern;\n  }\n\n  // Get the portion before the first metacharacter\n  const prefix = pattern.slice(0, firstMeta);\n\n  // Walk back to the last directory separator\n  const lastSlash = prefix.lastIndexOf('/');\n\n  if (lastSlash <= 0) {\n    // No slash or only root slash  base is root\n    return '/';\n  }\n\n  return prefix.slice(0, lastSlash);\n}\n\n// =============================================================================\n// Glob Matcher\n// =============================================================================\n\n/** A compiled matcher function: returns true if a path matches */\nexport type GlobMatcher = (path: string) => boolean;\n\nexport interface GlobMatcherOptions {\n  /** Match dotfiles (default: false) */\n  dot?: boolean;\n}\n\n/**\n * Strip leading './' or '/' from a path for picomatch matching.\n * picomatch does not match paths with these prefixes, so both\n * patterns and test paths must be normalized before matching.\n *\n * This only affects matching  filesystem paths should keep their\n * original form for correct resolution with contained/uncontained modes.\n */\nfunction normalizeForMatch(input: string): string {\n  if (input.startsWith('./')) return input.slice(2);\n  if (input.startsWith('/')) return input.slice(1);\n  return input;\n}\n\n/**\n * Compile glob pattern(s) into a reusable matcher function.\n * The matcher tests paths using workspace-style forward slashes.\n *\n * Automatically normalizes leading './' and '/' from both patterns\n * and test paths, since picomatch does not match these prefixes.\n *\n * @example\n * const match = createGlobMatcher('**\\/*.ts');\n * match('src/index.ts')     // true\n * match('src/style.css')    // false\n *\n * const multi = createGlobMatcher(['**\\/*.ts', '**\\/*.tsx']);\n * multi('App.tsx')           // true\n */\nexport function createGlobMatcher(patterns: string | string[], options?: GlobMatcherOptions): GlobMatcher {\n  const patternArray = (Array.isArray(patterns) ? patterns : [patterns]).map(normalizeForMatch);\n  const matcher = picomatch(patternArray, {\n    posix: true,\n    dot: options?.dot ?? false,\n  });\n  return (path: string) => matcher(normalizeForMatch(path));\n}\n\n/**\n * One-off convenience: test if a path matches a glob pattern.\n *\n * For repeated matching against the same pattern, prefer createGlobMatcher()\n * to compile once and reuse.\n *\n * @example\n * matchGlob('src/index.ts', '**\\/*.ts')  // true\n */\nexport function matchGlob(path: string, pattern: string | string[], options?: GlobMatcherOptions): boolean {\n  return createGlobMatcher(pattern, options)(path);\n}\n","/**\n * Language Detection\n *\n * Maps file extensions to LSP language identifiers.\n * Browser-safe  no Node.js dependencies.\n */\n\n/**\n * Maps file extensions (including the dot) to LSP language identifiers.\n */\nexport const LANGUAGE_EXTENSIONS: Record<string, string> = {\n  // TypeScript/JavaScript\n  '.ts': 'typescript',\n  '.tsx': 'typescriptreact',\n  '.js': 'javascript',\n  '.jsx': 'javascriptreact',\n  '.mjs': 'javascript',\n  '.cjs': 'javascript',\n\n  // Python\n  '.py': 'python',\n  '.pyi': 'python',\n\n  // Go\n  '.go': 'go',\n\n  // Rust\n  '.rs': 'rust',\n\n  // C/C++\n  '.c': 'c',\n  '.cpp': 'cpp',\n  '.cc': 'cpp',\n  '.cxx': 'cpp',\n  '.h': 'c',\n  '.hpp': 'cpp',\n\n  // Java\n  '.java': 'java',\n\n  // JSON\n  '.json': 'json',\n  '.jsonc': 'jsonc',\n\n  // YAML\n  '.yaml': 'yaml',\n  '.yml': 'yaml',\n\n  // Markdown\n  '.md': 'markdown',\n\n  // HTML/CSS\n  '.html': 'html',\n  '.css': 'css',\n  '.scss': 'scss',\n  '.sass': 'sass',\n  '.less': 'less',\n};\n\n/**\n * Get the LSP language ID for a file path based on its extension.\n * Returns undefined if the extension is not recognized.\n */\nexport function getLanguageId(filePath: string): string | undefined {\n  const dotIndex = filePath.lastIndexOf('.');\n  if (dotIndex === -1) return undefined;\n  const ext = filePath.substring(dotIndex);\n  return LANGUAGE_EXTENSIONS[ext];\n}\n","/**\n * LSP Client\n *\n * JSON-RPC client wrapper for communicating with language servers.\n * Uses dynamic imports for vscode-jsonrpc and vscode-languageserver-protocol\n * to keep them as optional dependencies.\n *\n * Spawns LSP servers via a SandboxProcessManager, so it works with any\n * sandbox backend (local, E2B, etc.) that has a process manager.\n */\n\nimport { createRequire } from 'node:module';\nimport { pathToFileURL } from 'node:url';\n\nimport type { ProcessHandle, SandboxProcessManager } from '../sandbox/process-manager';\nimport type { LSPServerDef } from './types';\n\n// =============================================================================\n// Dynamic Import\n// =============================================================================\n\n/** Cached module references  undefined means not yet checked, null means unavailable */\nlet jsonrpcModule:\n  | {\n      StreamMessageReader: any;\n      StreamMessageWriter: any;\n      createMessageConnection: any;\n    }\n  | null\n  | undefined;\nlet lspProtocolModule:\n  | {\n      TextDocumentIdentifier: any;\n      Position: any;\n    }\n  | null\n  | undefined;\n\n/**\n * Check if vscode-jsonrpc is available without importing it.\n * Synchronous check  safe to call at registration time.\n */\nexport function isLSPAvailable(): boolean {\n  if (jsonrpcModule !== undefined) {\n    return jsonrpcModule !== null;\n  }\n\n  try {\n    const req = createRequire(import.meta.url);\n    req.resolve('vscode-jsonrpc/node');\n    req.resolve('vscode-languageserver-protocol');\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Load vscode-jsonrpc and vscode-languageserver-protocol.\n * Returns null if not available. Caches result after first call.\n */\nexport async function loadLSPDeps(): Promise<{\n  StreamMessageReader: any;\n  StreamMessageWriter: any;\n  createMessageConnection: any;\n  TextDocumentIdentifier: any;\n  Position: any;\n} | null> {\n  if (jsonrpcModule !== undefined && lspProtocolModule !== undefined) {\n    if (jsonrpcModule === null || lspProtocolModule === null) return null;\n    return { ...jsonrpcModule, ...lspProtocolModule };\n  }\n\n  try {\n    const req = createRequire(import.meta.url);\n    const jsonrpc = req('vscode-jsonrpc/node');\n    const protocol = req('vscode-languageserver-protocol');\n    jsonrpcModule = {\n      StreamMessageReader: jsonrpc.StreamMessageReader,\n      StreamMessageWriter: jsonrpc.StreamMessageWriter,\n      createMessageConnection: jsonrpc.createMessageConnection,\n    };\n    lspProtocolModule = {\n      TextDocumentIdentifier: protocol.TextDocumentIdentifier,\n      Position: protocol.Position,\n    };\n    return { ...jsonrpcModule, ...lspProtocolModule };\n  } catch {\n    jsonrpcModule = null;\n    lspProtocolModule = null;\n    return null;\n  }\n}\n\n// =============================================================================\n// URI Helpers\n// =============================================================================\n\n/** Convert a filesystem path to a properly encoded file:// URI. */\nfunction toFileUri(fsPath: string): string {\n  return pathToFileURL(fsPath).toString();\n}\n\n// =============================================================================\n// LSP Client\n// =============================================================================\n\n/**\n * Wraps a JSON-RPC connection to a single LSP server process.\n * Uses a SandboxProcessManager to spawn the server process.\n */\nexport class LSPClient {\n  private connection: any = null;\n  private handle: ProcessHandle | null = null;\n  private serverDef: LSPServerDef;\n  private workspaceRoot: string;\n  private processManager: SandboxProcessManager;\n  private diagnostics: Map<string, any[]> = new Map();\n  private initializationOptions: Record<string, unknown> | null = null;\n\n  constructor(serverDef: LSPServerDef, workspaceRoot: string, processManager: SandboxProcessManager) {\n    this.serverDef = serverDef;\n    this.workspaceRoot = workspaceRoot;\n    this.processManager = processManager;\n  }\n\n  /** Whether the underlying server process is still running. */\n  get isAlive(): boolean {\n    return this.handle !== null && this.handle.exitCode === undefined;\n  }\n\n  /**\n   * Initialize the LSP connection  spawns the server and performs the handshake.\n   */\n  async initialize(initTimeout: number = 10000): Promise<void> {\n    const deps = await loadLSPDeps();\n    if (!deps) {\n      throw new Error('LSP dependencies (vscode-jsonrpc) are not available');\n    }\n    const { StreamMessageReader, StreamMessageWriter, createMessageConnection } = deps;\n\n    const command = this.serverDef.command(this.workspaceRoot);\n    if (!command) {\n      throw new Error('Failed to resolve LSP server command');\n    }\n    this.handle = await this.processManager.spawn(command, { cwd: this.workspaceRoot });\n\n    const initializationOptions = this.serverDef.initialization?.(this.workspaceRoot);\n\n    const reader = new StreamMessageReader(this.handle.reader);\n    const writer = new StreamMessageWriter(this.handle.writer);\n    this.connection = createMessageConnection(reader, writer);\n\n    // Silently ignore stream destroyed errors during shutdown\n    this.connection.onError(() => {});\n\n    // Listen for published diagnostics\n    this.connection.onNotification('textDocument/publishDiagnostics', (params: any) => {\n      this.diagnostics.set(params.uri, params.diagnostics);\n    });\n\n    this.connection.listen();\n\n    // Build initialize params\n    const initParams: any = {\n      processId: process.pid,\n      rootUri: toFileUri(this.workspaceRoot),\n      workspaceFolders: [\n        {\n          name: 'workspace',\n          uri: toFileUri(this.workspaceRoot),\n        },\n      ],\n      capabilities: {\n        window: { workDoneProgress: true },\n        workspace: { configuration: true },\n        textDocument: {\n          publishDiagnostics: {\n            relatedInformation: true,\n            tagSupport: { valueSet: [1, 2] },\n            versionSupport: false,\n          },\n          synchronization: {\n            didOpen: true,\n            didChange: true,\n            dynamicRegistration: false,\n            willSave: false,\n            willSaveWaitUntil: false,\n            didSave: false,\n          },\n          completion: {\n            dynamicRegistration: false,\n            completionItem: {\n              snippetSupport: false,\n              commitCharactersSupport: false,\n              documentationFormat: ['markdown', 'plaintext'],\n              deprecatedSupport: false,\n              preselectSupport: false,\n            },\n          },\n          definition: { dynamicRegistration: false, linkSupport: true },\n          typeDefinition: { dynamicRegistration: false, linkSupport: true },\n          implementation: { dynamicRegistration: false, linkSupport: true },\n          references: { dynamicRegistration: false },\n          documentHighlight: { dynamicRegistration: false },\n          documentSymbol: { dynamicRegistration: false, hierarchicalDocumentSymbolSupport: true },\n          codeAction: {\n            dynamicRegistration: false,\n            codeActionLiteralSupport: {\n              codeActionKind: {\n                valueSet: [\n                  'quickfix',\n                  'refactor',\n                  'refactor.extract',\n                  'refactor.inline',\n                  'refactor.rewrite',\n                  'source',\n                  'source.organizeImports',\n                ],\n              },\n            },\n          },\n          hover: { dynamicRegistration: false, contentFormat: ['markdown', 'plaintext'] },\n        },\n      },\n    };\n\n    if (initializationOptions) {\n      initParams.initializationOptions = initializationOptions;\n      this.initializationOptions = initializationOptions;\n    }\n\n    // Handle workspace/configuration requests\n    this.connection.onRequest('workspace/configuration', (params: any) => {\n      return params.items?.map(() => ({})) || [];\n    });\n\n    // Handle window/workDoneProgress/create requests\n    this.connection.onRequest('window/workDoneProgress/create', () => null);\n\n    let initTimer: ReturnType<typeof setTimeout>;\n    await Promise.race([\n      this.connection.sendRequest('initialize', initParams),\n      new Promise((_, reject) => {\n        initTimer = setTimeout(() => reject(new Error('LSP initialize request timed out')), initTimeout);\n      }),\n    ]).finally(() => clearTimeout(initTimer!));\n\n    // Send initialized notification\n    this.connection.sendNotification('initialized', {});\n\n    // Send workspace/didChangeConfiguration\n    this.connection.sendNotification('workspace/didChangeConfiguration', {\n      settings: this.initializationOptions ?? {},\n    });\n  }\n\n  /**\n   * Notify the server that a document has been opened.\n   */\n  notifyOpen(filePath: string, content: string, languageId: string): void {\n    if (!this.connection) return;\n    const uri = toFileUri(filePath);\n    this.diagnostics.delete(uri);\n    this.connection.sendNotification('textDocument/didOpen', {\n      textDocument: { uri, languageId, version: 0, text: content },\n    });\n  }\n\n  /**\n   * Notify the server that a document has changed.\n   */\n  notifyChange(filePath: string, content: string, version: number): void {\n    if (!this.connection) return;\n    this.connection.sendNotification('textDocument/didChange', {\n      textDocument: { uri: toFileUri(filePath), version },\n      contentChanges: [{ text: content }],\n    });\n  }\n\n  /**\n   * Wait for diagnostics to arrive for a file.\n   *\n   * When `waitForChange` is false (default), returns as soon as diagnostics\n   * are available. To avoid returning a premature empty array (servers may\n   * publish `[]` first while still analysing), empty results trigger a short\n   * settle window: polling continues for up to `settleMs` (default 500ms)\n   * to see if non-empty diagnostics arrive. Non-empty results are returned\n   * immediately.\n   */\n  async waitForDiagnostics(\n    filePath: string,\n    timeoutMs: number = 5000,\n    waitForChange: boolean = false,\n    settleMs: number = 500,\n  ): Promise<any[]> {\n    if (!this.connection) return [];\n    const uri = toFileUri(filePath);\n    const startTime = Date.now();\n    const initialDiagnostics = this.diagnostics.get(uri);\n    let emptyReceivedAt: number | undefined;\n\n    while (Date.now() - startTime < timeoutMs) {\n      const currentDiagnostics = this.diagnostics.get(uri);\n\n      if (waitForChange) {\n        // Compare by reference  the notification handler sets a new array each time\n        if (currentDiagnostics !== undefined && currentDiagnostics !== initialDiagnostics) {\n          return currentDiagnostics;\n        }\n      } else {\n        if (currentDiagnostics !== undefined) {\n          // Non-empty  the server has real results, return immediately\n          if (currentDiagnostics.length > 0) return currentDiagnostics;\n          // Empty  start a settle window. The server may have published a\n          // clearing notification before the real analysis results arrive.\n          if (emptyReceivedAt === undefined) emptyReceivedAt = Date.now();\n          if (Date.now() - emptyReceivedAt >= settleMs) return currentDiagnostics;\n        }\n      }\n\n      await new Promise(resolve => setTimeout(resolve, 100));\n    }\n\n    return waitForChange ? initialDiagnostics || [] : this.diagnostics.get(uri) || [];\n  }\n\n  /**\n   * Notify the server that a document was closed.\n   */\n  notifyClose(filePath: string): void {\n    if (!this.connection) return;\n    const uri = toFileUri(filePath);\n    this.diagnostics.delete(uri);\n    this.connection.sendNotification('textDocument/didClose', {\n      textDocument: { uri },\n    });\n  }\n\n  /**\n   * Shutdown the connection and kill the process.\n   */\n  async shutdown(): Promise<void> {\n    if (this.connection) {\n      try {\n        if (this.handle && this.handle.exitCode === undefined) {\n          let shutdownTimer: ReturnType<typeof setTimeout>;\n          await Promise.race([\n            this.connection.sendRequest('shutdown'),\n            new Promise((_, reject) => {\n              shutdownTimer = setTimeout(() => reject(new Error('Shutdown request timed out')), 1000);\n            }),\n          ]).finally(() => clearTimeout(shutdownTimer!));\n          this.connection.sendNotification('exit');\n        }\n      } catch {\n        // Ignore shutdown errors\n      }\n      try {\n        this.connection.dispose();\n      } catch {\n        // Ignore dispose errors\n      }\n      this.connection = null;\n    }\n\n    if (this.handle) {\n      try {\n        await this.handle.kill();\n      } catch {\n        // Ignore kill errors\n      }\n      this.handle = null;\n    }\n\n    this.diagnostics = new Map();\n  }\n}\n","/**\n * Built-in LSP Server Definitions\n *\n * Defines how to locate language servers and build command strings for supported languages.\n * Server definitions are pure data  they don't spawn processes themselves.\n * The LSPClient uses a SandboxProcessManager to spawn from these command strings.\n */\n\nimport { execFileSync } from 'node:child_process';\nimport { existsSync } from 'node:fs';\nimport { createRequire } from 'node:module';\nimport { dirname, join, parse } from 'node:path';\nimport { pathToFileURL } from 'node:url';\n\nimport { getLanguageId } from './language';\nimport type { LSPServerDef } from './types';\n\n/** Check if a binary exists on PATH. */\nfunction whichSync(binary: string): boolean {\n  try {\n    const cmd = process.platform === 'win32' ? 'where' : 'which';\n    execFileSync(cmd, [binary], { stdio: 'ignore' });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Try to resolve a module from the given directory, then fall back to process.cwd().\n * Returns the createRequire instance that succeeded, or null.\n */\nfunction resolveRequire(root: string, moduleId: string): { require: NodeRequire; resolved: string } | null {\n  // Try from root first\n  try {\n    const req = createRequire(pathToFileURL(join(root, 'package.json')));\n    return { require: req, resolved: req.resolve(moduleId) };\n  } catch {\n    // fall through\n  }\n  // Try from cwd as fallback\n  try {\n    const req = createRequire(pathToFileURL(join(process.cwd(), 'package.json')));\n    return { require: req, resolved: req.resolve(moduleId) };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Walk up from a starting directory looking for any of the given markers.\n * Returns the first directory that contains a marker, or null.\n */\nexport function walkUp(startDir: string, markers: string[]): string | null {\n  let current = startDir;\n  const fsRoot = parse(current).root;\n\n  while (true) {\n    for (const marker of markers) {\n      if (existsSync(join(current, marker))) {\n        return current;\n      }\n    }\n    if (current === fsRoot) break;\n    const parent = dirname(current);\n    if (parent === current) break;\n    current = parent;\n  }\n\n  return null;\n}\n\n/**\n * Async version of walkUp that uses a filesystem's exists() method.\n * Works with any filesystem (local, S3, GCS, composite) that implements exists().\n */\nexport async function walkUpAsync(\n  startDir: string,\n  markers: string[],\n  fs: { exists(path: string): Promise<boolean> },\n): Promise<string | null> {\n  let current = startDir;\n  const fsRoot = parse(current).root;\n\n  while (true) {\n    for (const marker of markers) {\n      if (await fs.exists(join(current, marker))) {\n        return current;\n      }\n    }\n    if (current === fsRoot) break;\n    const parent = dirname(current);\n    if (parent === current) break;\n    current = parent;\n  }\n\n  return null;\n}\n\n/** Default markers used to find a project root when no server-specific markers are available. */\nconst DEFAULT_MARKERS = [\n  'tsconfig.json',\n  'package.json',\n  'pyproject.toml',\n  'go.mod',\n  'Cargo.toml',\n  'composer.json',\n  '.git',\n];\n\n/**\n * Find a project root by walking up from a starting directory.\n * Uses default markers (tsconfig.json, package.json, go.mod, etc.).\n * Used by Workspace to resolve the default LSP root at construction time.\n */\nexport function findProjectRoot(startDir: string): string | null {\n  return walkUp(startDir, DEFAULT_MARKERS);\n}\n\n/**\n * Async version of findProjectRoot that uses a filesystem's exists() method.\n * Works with any filesystem (local, S3, GCS, composite) that implements exists().\n */\nexport async function findProjectRootAsync(\n  startDir: string,\n  fs: { exists(path: string): Promise<boolean> },\n): Promise<string | null> {\n  return walkUpAsync(startDir, DEFAULT_MARKERS, fs);\n}\n\n/**\n * Built-in LSP server definitions.\n */\nexport const BUILTIN_SERVERS: Record<string, LSPServerDef> = {\n  typescript: {\n    id: 'typescript',\n    name: 'TypeScript Language Server',\n    languageIds: ['typescript', 'typescriptreact', 'javascript', 'javascriptreact'],\n    markers: ['tsconfig.json', 'package.json'],\n    command: (root: string) => {\n      const ts = resolveRequire(root, 'typescript/lib/tsserver.js');\n      if (!ts) return undefined;\n\n      // Find typescript-language-server binary: root node_modules, then cwd node_modules\n      const localBin = join(root, 'node_modules', '.bin', 'typescript-language-server');\n      const cwdBin = join(process.cwd(), 'node_modules', '.bin', 'typescript-language-server');\n      if (existsSync(localBin)) return `${localBin} --stdio`;\n      if (existsSync(cwdBin)) return `${cwdBin} --stdio`;\n      return undefined;\n    },\n    initialization: (root: string) => {\n      const ts = resolveRequire(root, 'typescript/lib/tsserver.js');\n      if (!ts) return undefined;\n      return {\n        tsserver: {\n          path: ts.resolved,\n          logVerbosity: 'off',\n        },\n      };\n    },\n  },\n\n  eslint: {\n    id: 'eslint',\n    name: 'ESLint Language Server',\n    languageIds: ['typescript', 'typescriptreact', 'javascript', 'javascriptreact'],\n    markers: [\n      'package.json',\n      '.eslintrc.js',\n      '.eslintrc.json',\n      '.eslintrc.yml',\n      '.eslintrc.yaml',\n      'eslint.config.js',\n      'eslint.config.mjs',\n      'eslint.config.ts',\n    ],\n    command: (root: string) => {\n      const localBin = join(root, 'node_modules', '.bin', 'vscode-eslint-language-server');\n      const cwdBin = join(process.cwd(), 'node_modules', '.bin', 'vscode-eslint-language-server');\n      if (existsSync(localBin)) return `${localBin} --stdio`;\n      if (existsSync(cwdBin)) return `${cwdBin} --stdio`;\n      return undefined;\n    },\n  },\n\n  python: {\n    id: 'python',\n    name: 'Python Language Server (Pyright)',\n    languageIds: ['python'],\n    markers: ['pyproject.toml', 'setup.py', 'requirements.txt', 'setup.cfg'],\n    command: (root: string) => {\n      const localBin = join(root, 'node_modules', '.bin', 'pyright-langserver');\n      const cwdBin = join(process.cwd(), 'node_modules', '.bin', 'pyright-langserver');\n      if (existsSync(localBin)) return `${localBin} --stdio`;\n      if (existsSync(cwdBin)) return `${cwdBin} --stdio`;\n      return whichSync('pyright-langserver') ? 'pyright-langserver --stdio' : undefined;\n    },\n  },\n\n  go: {\n    id: 'go',\n    name: 'Go Language Server (gopls)',\n    languageIds: ['go'],\n    markers: ['go.mod'],\n    command: () => {\n      return whichSync('gopls') ? 'gopls serve' : undefined;\n    },\n  },\n\n  rust: {\n    id: 'rust',\n    name: 'Rust Language Server (rust-analyzer)',\n    languageIds: ['rust'],\n    markers: ['Cargo.toml'],\n    command: () => {\n      return whichSync('rust-analyzer') ? 'rust-analyzer --stdio' : undefined;\n    },\n  },\n};\n\n/**\n * Get all server definitions that can handle the given file.\n * Filters by language ID match only  the manager resolves the root and checks command availability.\n */\nexport function getServersForFile(filePath: string, disabledServers?: string[]): LSPServerDef[] {\n  const languageId = getLanguageId(filePath);\n  if (!languageId) return [];\n\n  const disabled = new Set(disabledServers ?? []);\n\n  return Object.values(BUILTIN_SERVERS).filter(\n    server => !disabled.has(server.id) && server.languageIds.includes(languageId),\n  );\n}\n","/**\n * LSP Manager\n *\n * Per-workspace manager that owns LSP server clients.\n * NOT a singleton  each Workspace instance creates its own LSPManager.\n *\n * Resolves the project root per-file by walking up from the file's directory\n * using language-specific markers defined on each server (e.g. tsconfig.json\n * for TypeScript, go.mod for Go). Falls back to the default root when\n * walkup finds nothing.\n */\n\nimport path from 'node:path';\n\nimport type { SandboxProcessManager } from '../sandbox/process-manager';\nimport { LSPClient } from './client';\nimport { getLanguageId } from './language';\nimport { getServersForFile, walkUp, walkUpAsync } from './servers';\nimport type { DiagnosticSeverity, LSPConfig, LSPDiagnostic, LSPServerDef } from './types';\n\n/** Map LSP DiagnosticSeverity (numeric) to our string severity */\nfunction mapSeverity(severity: number | undefined): DiagnosticSeverity {\n  switch (severity) {\n    case 1:\n      return 'error';\n    case 2:\n      return 'warning';\n    case 3:\n      return 'info';\n    case 4:\n      return 'hint';\n    default:\n      return 'warning';\n  }\n}\n\nexport class LSPManager {\n  private clients: Map<string, LSPClient> = new Map();\n  private initPromises: Map<string, Promise<void>> = new Map();\n  private fileLocks: Map<string, Promise<void>> = new Map();\n  private processManager: SandboxProcessManager;\n  private _root: string;\n  private config: LSPConfig;\n  private filesystem?: {\n    exists(path: string): Promise<boolean>;\n  };\n\n  constructor(\n    processManager: SandboxProcessManager,\n    root: string,\n    config: LSPConfig = {},\n    filesystem?: {\n      exists(path: string): Promise<boolean>;\n    },\n  ) {\n    this.processManager = processManager;\n    this._root = root;\n    this.config = config;\n    this.filesystem = filesystem;\n  }\n\n  /** Default project root (fallback when per-file walkup finds nothing). */\n  get root(): string {\n    return this._root;\n  }\n\n  /**\n   * Resolve the project root for a given file path using the server's markers.\n   * Uses the workspace filesystem when available (supports remote filesystems),\n   * falls back to sync walkUp (local disk) otherwise.\n   */\n  private async resolveRoot(filePath: string, markers: string[]): Promise<string> {\n    const fileDir = path.dirname(filePath);\n    if (this.filesystem) {\n      return (await walkUpAsync(fileDir, markers, this.filesystem)) ?? this._root;\n    }\n    return walkUp(fileDir, markers) ?? this._root;\n  }\n\n  /**\n   * Acquire a per-file lock so that concurrent getDiagnostics calls for the\n   * same file are serialized (preventing interleaved open/change/close).\n   * Different files can run in parallel.\n   */\n  private async acquireFileLock(filePath: string): Promise<() => void> {\n    // Wait for any existing lock on this file\n    while (this.fileLocks.has(filePath)) {\n      await this.fileLocks.get(filePath);\n    }\n\n    let release!: () => void;\n    const lockPromise = new Promise<void>(resolve => {\n      release = resolve;\n    });\n    this.fileLocks.set(filePath, lockPromise);\n\n    return () => {\n      this.fileLocks.delete(filePath);\n      release();\n    };\n  }\n\n  /**\n   * Initialize an LSP client for the given server definition and project root.\n   * Handles timeout, deduplication of concurrent init calls, and caching.\n   */\n  private async initClient(serverDef: LSPServerDef, projectRoot: string, key: string): Promise<LSPClient | null> {\n    // In-progress initialization  wait for it\n    if (this.initPromises.has(key)) {\n      await this.initPromises.get(key);\n      return this.clients.get(key) || null;\n    }\n\n    // Create and initialize\n    const initTimeout = this.config.initTimeout ?? 15000;\n    let timedOut = false;\n    const initPromise = (async () => {\n      const client = new LSPClient(serverDef, projectRoot, this.processManager);\n      await client.initialize(initTimeout);\n      if (timedOut) {\n        await client.shutdown().catch(() => {});\n        return;\n      }\n      this.clients.set(key, client);\n    })();\n\n    this.initPromises.set(key, initPromise);\n    initPromise.catch(() => {}); // prevent unhandled rejection if timeout wins\n\n    try {\n      await Promise.race([\n        initPromise,\n        new Promise<void>((_, reject) =>\n          setTimeout(() => reject(new Error('LSP client initialization timed out')), initTimeout + 1000),\n        ),\n      ]);\n      return this.clients.get(key) || null;\n    } catch {\n      timedOut = true;\n      this.clients.delete(key);\n      return null;\n    } finally {\n      this.initPromises.delete(key);\n    }\n  }\n\n  /**\n   * Get or create an LSP client for a file path.\n   * Resolves the project root per-file using the server's markers.\n   * Returns null if no server is available.\n   */\n  async getClient(filePath: string): Promise<LSPClient | null> {\n    const servers = getServersForFile(filePath, this.config.disableServers);\n    if (servers.length === 0) return null;\n\n    // Prefer well-known language servers\n    const serverDef =\n      servers.find(\n        s =>\n          s.languageIds.includes('typescript') ||\n          s.languageIds.includes('javascript') ||\n          s.languageIds.includes('python') ||\n          s.languageIds.includes('go'),\n      ) ?? servers[0]!;\n\n    const projectRoot = await this.resolveRoot(filePath, serverDef.markers);\n\n    // Check if the server's command is available at this root\n    if (serverDef.command(projectRoot) === undefined) return null;\n\n    const key = `${serverDef.name}:${projectRoot}`;\n\n    // Existing client  check liveness before returning\n    if (this.clients.has(key)) {\n      const existing = this.clients.get(key)!;\n      if (!existing.isAlive) {\n        this.clients.delete(key);\n        existing.shutdown().catch(() => {});\n      } else {\n        return existing;\n      }\n    }\n\n    return this.initClient(serverDef, projectRoot, key);\n  }\n\n  /**\n   * Convenience method: open file, send content, wait for diagnostics, return normalized results.\n   * Returns an empty array on any failure (non-blocking).\n   * Uses a per-file lock to serialize concurrent calls for the same file.\n   */\n  async getDiagnostics(filePath: string, content: string): Promise<LSPDiagnostic[]> {\n    const release = await this.acquireFileLock(filePath);\n    try {\n      const client = await this.getClient(filePath);\n      if (!client) return [];\n\n      const languageId = getLanguageId(filePath);\n      if (!languageId) return [];\n\n      // Open + change  triggers diagnostics\n      client.notifyOpen(filePath, content, languageId);\n      client.notifyChange(filePath, content, 1);\n\n      const diagnosticTimeout = this.config.diagnosticTimeout ?? 5000;\n      let rawDiagnostics: any[];\n      try {\n        rawDiagnostics = await client.waitForDiagnostics(filePath, diagnosticTimeout);\n      } finally {\n        client.notifyClose(filePath);\n      }\n\n      return rawDiagnostics.map((d: any) => ({\n        severity: mapSeverity(d.severity),\n        message: d.message,\n        line: (d.range?.start?.line ?? 0) + 1, // LSP is 0-indexed, we report 1-indexed\n        character: (d.range?.start?.character ?? 0) + 1,\n        source: d.source,\n      }));\n    } catch {\n      return [];\n    } finally {\n      release();\n    }\n  }\n\n  /**\n   * Get diagnostics from ALL matching language servers for a file.\n   * Deduplicates results by (line, character, message).\n   * Individual server failures don't block other servers.\n   */\n  async getDiagnosticsMulti(filePath: string, content: string): Promise<LSPDiagnostic[]> {\n    const servers = getServersForFile(filePath, this.config.disableServers);\n    if (servers.length === 0) return [];\n\n    const release = await this.acquireFileLock(filePath);\n    try {\n      const languageId = getLanguageId(filePath);\n      if (!languageId) return [];\n\n      const allDiagnostics: LSPDiagnostic[] = [];\n\n      const results = await Promise.allSettled(\n        servers.map(async serverDef => {\n          const projectRoot = await this.resolveRoot(filePath, serverDef.markers);\n          if (serverDef.command(projectRoot) === undefined) return [];\n\n          const key = `${serverDef.name}:${projectRoot}`;\n\n          // Existing client  check liveness\n          if (this.clients.has(key)) {\n            const existing = this.clients.get(key)!;\n            if (!existing.isAlive) {\n              this.clients.delete(key);\n              existing.shutdown().catch(() => {});\n            } else {\n              return this.collectDiagnostics(existing, filePath, content, languageId);\n            }\n          }\n\n          const client = await this.initClient(serverDef, projectRoot, key);\n          if (!client) return [];\n\n          return this.collectDiagnostics(client, filePath, content, languageId);\n        }),\n      );\n\n      for (const result of results) {\n        if (result.status === 'fulfilled') {\n          allDiagnostics.push(...result.value);\n        }\n      }\n\n      // Deduplicate by (line, character, message)\n      const seen = new Set<string>();\n      return allDiagnostics.filter(d => {\n        const key = `${d.line}:${d.character}:${d.message}`;\n        if (seen.has(key)) return false;\n        seen.add(key);\n        return true;\n      });\n    } finally {\n      release();\n    }\n  }\n\n  /**\n   * Collect diagnostics from a single client for a file.\n   */\n  private async collectDiagnostics(\n    client: LSPClient,\n    filePath: string,\n    content: string,\n    languageId: string,\n  ): Promise<LSPDiagnostic[]> {\n    client.notifyOpen(filePath, content, languageId);\n    client.notifyChange(filePath, content, 1);\n\n    const diagnosticTimeout = this.config.diagnosticTimeout ?? 5000;\n    let rawDiagnostics: any[];\n    try {\n      rawDiagnostics = await client.waitForDiagnostics(filePath, diagnosticTimeout);\n    } finally {\n      client.notifyClose(filePath);\n    }\n\n    return rawDiagnostics.map((d: any) => ({\n      severity: mapSeverity(d.severity),\n      message: d.message,\n      line: (d.range?.start?.line ?? 0) + 1,\n      character: (d.range?.start?.character ?? 0) + 1,\n      source: d.source,\n    }));\n  }\n\n  /**\n   * Shutdown all managed LSP clients.\n   */\n  async shutdownAll(): Promise<void> {\n    await Promise.allSettled(Array.from(this.clients.values()).map(client => client.shutdown()));\n    this.clients.clear();\n    this.initPromises.clear();\n    this.fileLocks.clear();\n  }\n}\n","/**\n * Sandbox Errors\n *\n * Error classes for sandbox operations including execution and mounting.\n */\n\nimport type { SandboxOperation } from './types';\n\n// =============================================================================\n// Base Error\n// =============================================================================\n\nexport class SandboxError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly details?: Record<string, unknown>,\n  ) {\n    super(message);\n    this.name = 'SandboxError';\n  }\n}\n\n// =============================================================================\n// Execution Errors\n// =============================================================================\n\nexport class SandboxExecutionError extends SandboxError {\n  constructor(\n    message: string,\n    public readonly exitCode: number,\n    public readonly stdout: string,\n    public readonly stderr: string,\n  ) {\n    super(message, 'EXECUTION_FAILED', { exitCode, stdout, stderr });\n    this.name = 'SandboxExecutionError';\n  }\n}\n\nexport class SandboxTimeoutError extends SandboxError {\n  constructor(\n    public readonly timeoutMs: number,\n    public readonly operation: SandboxOperation,\n  ) {\n    super(`Execution timed out after ${timeoutMs}ms`, 'TIMEOUT', { timeoutMs, operation });\n    this.name = 'SandboxTimeoutError';\n  }\n}\n\nexport class SandboxNotReadyError extends SandboxError {\n  constructor(idOrStatus: string) {\n    super(`Sandbox is not ready: ${idOrStatus}`, 'NOT_READY', { id: idOrStatus });\n    this.name = 'SandboxNotReadyError';\n  }\n}\n\nexport class IsolationUnavailableError extends SandboxError {\n  constructor(\n    public readonly backend: string,\n    public readonly reason: string,\n  ) {\n    super(`Isolation backend '${backend}' is not available: ${reason}`, 'ISOLATION_UNAVAILABLE', { backend, reason });\n    this.name = 'IsolationUnavailableError';\n  }\n}\n\n// =============================================================================\n// Mount Errors\n// =============================================================================\n\n/**\n * Base error for mount operations.\n */\nexport class MountError extends SandboxError {\n  constructor(\n    message: string,\n    public readonly mountPath: string,\n    details?: Record<string, unknown>,\n  ) {\n    super(message, 'MOUNT_ERROR', { ...details, mountPath });\n    this.name = 'MountError';\n  }\n}\n\n/**\n * Error thrown when sandbox doesn't support mounting.\n */\nexport class MountNotSupportedError extends SandboxError {\n  constructor(sandboxProvider: string) {\n    super(`Sandbox provider '${sandboxProvider}' does not support mounting`, 'MOUNT_NOT_SUPPORTED', {\n      sandboxProvider,\n    });\n    this.name = 'MountNotSupportedError';\n  }\n}\n\n/**\n * Error thrown when a filesystem cannot be mounted.\n */\nexport class FilesystemNotMountableError extends SandboxError {\n  constructor(filesystemProvider: string, reason?: string) {\n    const message = reason\n      ? `Filesystem '${filesystemProvider}' cannot be mounted: ${reason}`\n      : `Filesystem '${filesystemProvider}' does not support mounting`;\n    super(message, 'FILESYSTEM_NOT_MOUNTABLE', { filesystemProvider, reason });\n    this.name = 'FilesystemNotMountableError';\n  }\n}\n","/**\n * Mount Manager\n *\n * Encapsulates all mount-related state and operations for sandboxes.\n * Used by BaseSandbox to manage filesystem mounts.\n */\n\nimport { createHash } from 'node:crypto';\n\nimport type { IMastraLogger } from '../../logger';\nimport type { WorkspaceFilesystem } from '../filesystem/filesystem';\nimport type { FilesystemMountConfig, MountResult } from '../filesystem/mount';\n\nimport type { Workspace } from '../workspace';\nimport type { WorkspaceSandbox } from './sandbox';\nimport type { MountEntry, MountState } from './types';\n\n// Type-only import  erased at compile time, no circular dependency at runtime.\n\n/**\n * Mount function signature.\n */\nexport type MountFn = (filesystem: WorkspaceFilesystem, mountPath: string) => Promise<MountResult>;\n\n/**\n * onMount hook result.\n * - false: skip mount\n * - { success, error? }: hook handled it\n * - void: use default mount\n */\nexport type OnMountResult = false | { success: boolean; error?: string } | void;\n\n/**\n * Arguments passed to the onMount hook.\n */\nexport interface OnMountArgs {\n  /** The filesystem being mounted */\n  filesystem: WorkspaceFilesystem;\n  /** The mount path in the sandbox */\n  mountPath: string;\n  /** The mount configuration from filesystem.getMountConfig() (undefined if not supported) */\n  config: FilesystemMountConfig | undefined;\n  /** The sandbox instance for custom mount implementations */\n  sandbox: WorkspaceSandbox;\n  /** The workspace instance */\n  workspace: Workspace;\n}\n\n/**\n * onMount hook function.\n *\n * Called for each filesystem before mounting into sandbox.\n * Return value controls mounting behavior (see {@link OnMountResult}).\n *\n * @example Skip local filesystems\n * ```typescript\n * onMount: ({ filesystem }) => {\n *   if (filesystem.provider === 'local') return false;\n * }\n * ```\n *\n * @example Custom mount implementation\n * ```typescript\n * onMount: async ({ filesystem, mountPath, sandbox }) => {\n *   if (mountPath === '/custom') {\n *     await sandbox.executeCommand?.('my-mount-script', [mountPath]);\n *     return { success: true };\n *   }\n * }\n * ```\n */\nexport type OnMountHook = (args: OnMountArgs) => Promise<OnMountResult> | OnMountResult;\n\n/**\n * MountManager configuration.\n */\nexport interface MountManagerConfig {\n  /** The mount implementation from the sandbox */\n  mount: MountFn;\n  /** Logger instance */\n  logger: IMastraLogger;\n}\n\n/**\n * Manages filesystem mounts for a sandbox.\n *\n * Provides methods for tracking mount state, updating entries,\n * and processing pending mounts.\n */\nexport class MountManager {\n  private _entries: Map<string, MountEntry> = new Map();\n  private _mountFn: MountFn;\n  private _onMount?: OnMountHook;\n  private _sandbox?: WorkspaceSandbox;\n  private _workspace?: Workspace;\n  private logger: IMastraLogger;\n\n  constructor(config: MountManagerConfig) {\n    this._mountFn = config.mount;\n    this.logger = config.logger;\n  }\n\n  /**\n   * Set the sandbox and workspace references for onMount hook args.\n   * Called by Workspace during construction.\n   */\n  setContext(context: { sandbox: WorkspaceSandbox; workspace: Workspace }): void {\n    this._sandbox = context.sandbox;\n    this._workspace = context.workspace;\n  }\n\n  /**\n   * Set the onMount hook for custom mount handling.\n   * Called before each mount - can skip, handle, or defer to default.\n   */\n  setOnMount(hook: OnMountHook | undefined): void {\n    this._onMount = hook;\n  }\n\n  /**\n   * Update the logger instance.\n   * Called when the sandbox receives a logger from Mastra.\n   * @internal\n   */\n  __setLogger(logger: IMastraLogger): void {\n    this.logger = logger;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Entry Access\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Get all mount entries.\n   */\n  get entries(): ReadonlyMap<string, MountEntry> {\n    return this._entries;\n  }\n\n  /**\n   * Get a mount entry by path.\n   */\n  get(path: string): MountEntry | undefined {\n    return this._entries.get(path);\n  }\n\n  /**\n   * Check if a mount exists at the given path.\n   */\n  has(path: string): boolean {\n    return this._entries.has(path);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Entry Modification\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Add pending mounts from workspace config.\n   * These will be processed when `processPending()` is called.\n   */\n  add(mounts: Record<string, WorkspaceFilesystem>): void {\n    const paths = Object.keys(mounts);\n    this.logger.debug(`Adding ${paths.length} pending mount(s)`, { paths });\n\n    for (const [path, filesystem] of Object.entries(mounts)) {\n      this._entries.set(path, {\n        filesystem,\n        state: 'pending',\n      });\n    }\n  }\n\n  /**\n   * Update a mount entry's state.\n   * Creates the entry if it doesn't exist.\n   */\n  set(\n    path: string,\n    updates: {\n      filesystem?: WorkspaceFilesystem;\n      state: MountState;\n      config?: FilesystemMountConfig;\n      error?: string;\n    },\n  ): void {\n    const existing = this._entries.get(path);\n\n    if (existing) {\n      existing.state = updates.state;\n      if (updates.config) {\n        existing.config = updates.config;\n        existing.configHash = this.hashConfig(updates.config);\n      }\n      if ('error' in updates) {\n        existing.error = updates.error;\n      }\n    } else if (updates.filesystem) {\n      // Create new entry (for direct mount() calls without add())\n      this._entries.set(path, {\n        filesystem: updates.filesystem,\n        state: updates.state,\n        config: updates.config,\n        configHash: updates.config ? this.hashConfig(updates.config) : undefined,\n        error: updates.error,\n      });\n    } else {\n      this.logger.debug(`set() called for unknown path \"${path}\" without filesystem  no entry created`);\n    }\n  }\n\n  /**\n   * Delete a mount entry.\n   */\n  delete(path: string): boolean {\n    return this._entries.delete(path);\n  }\n\n  /**\n   * Clear all mount entries.\n   */\n  clear(): void {\n    this._entries.clear();\n  }\n\n  // ---------------------------------------------------------------------------\n  // Mount Processing\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Process all pending mounts.\n   * Call this after sandbox is ready (in start()).\n   */\n  async processPending(): Promise<void> {\n    const pendingCount = [...this._entries.values()].filter(e => e.state === 'pending').length;\n    if (pendingCount === 0) {\n      return;\n    }\n\n    this.logger.debug(`Processing ${pendingCount} pending mount(s)`);\n\n    for (const [path, entry] of this._entries) {\n      if (entry.state !== 'pending') {\n        continue;\n      }\n\n      const fsProvider = entry.filesystem.provider;\n\n      // Get config if available\n      const config = entry.filesystem.getMountConfig?.();\n\n      // Call onMount hook if configured\n      if (this._onMount) {\n        try {\n          const hookResult = await this._onMount({\n            filesystem: entry.filesystem,\n            mountPath: path,\n            config,\n            sandbox: this._sandbox!,\n            workspace: this._workspace!,\n          });\n\n          // false = skip mount entirely\n          if (hookResult === false) {\n            entry.state = 'unsupported';\n            entry.error = 'Skipped by onMount hook';\n            this.logger.debug(`Mount skipped by onMount hook`, { path, provider: fsProvider });\n            continue;\n          }\n\n          // { success, error? } = hook handled it\n          if (hookResult && typeof hookResult === 'object') {\n            if (hookResult.success) {\n              entry.state = 'mounted';\n              entry.config = config;\n              entry.configHash = config ? this.hashConfig(config) : undefined;\n              this.logger.info(`Mount handled by onMount hook`, { path, provider: fsProvider });\n            } else {\n              entry.state = 'error';\n              entry.error = hookResult.error ?? 'Mount hook failed';\n              this.logger.error(`Mount hook failed`, { path, provider: fsProvider, error: entry.error });\n            }\n            continue;\n          }\n\n          // void = continue with default mount\n        } catch (err) {\n          entry.state = 'error';\n          entry.error = `Mount hook error: ${String(err)}`;\n          this.logger.error(`Mount hook threw error`, { path, provider: fsProvider, error: entry.error });\n          continue;\n        }\n      }\n\n      // Check if filesystem supports mounting (for default behavior)\n      if (!config) {\n        entry.state = 'unsupported';\n        entry.error = 'Filesystem does not support mounting';\n        this.logger.debug(`Filesystem does not support mounting`, { path, provider: fsProvider });\n        continue;\n      }\n\n      // Store config and mark as mounting\n      entry.config = config;\n      entry.configHash = this.hashConfig(config);\n      entry.state = 'mounting';\n\n      this.logger.debug(`Mounting filesystem`, { path, provider: fsProvider, type: config.type });\n\n      // Call the sandbox's mount implementation\n      try {\n        const result = await this._mountFn(entry.filesystem, path);\n        if (result.success) {\n          entry.state = 'mounted';\n          this.logger.info(`Mount successful`, { path, provider: fsProvider });\n        } else {\n          entry.state = 'error';\n          entry.error = result.error ?? 'Mount failed';\n          this.logger.error(`Mount failed`, { path, provider: fsProvider, error: entry.error });\n        }\n      } catch (err) {\n        entry.state = 'error';\n        entry.error = String(err);\n        this.logger.error(`Mount threw error`, { path, provider: fsProvider, error: entry.error });\n      }\n    }\n  }\n\n  // ---------------------------------------------------------------------------\n  // Marker File Helpers\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Generate a marker filename for a mount path.\n   * Used by sandboxes to store mount metadata for reconnection detection.\n   *\n   * @param mountPath - The mount path to generate a filename for\n   * @returns A safe filename like \"mount-abc123\"\n   */\n  markerFilename(mountPath: string): string {\n    let hash = 0;\n    for (let i = 0; i < mountPath.length; i++) {\n      const char = mountPath.charCodeAt(i);\n      hash = (hash << 5) - hash + char;\n      hash |= 0; // Convert to 32-bit integer\n    }\n    return `mount-${Math.abs(hash).toString(36)}`;\n  }\n\n  /**\n   * Generate marker file content for a mount path.\n   * Format: \"path|configHash\" - used for detecting config changes on reconnect.\n   *\n   * @param mountPath - The mount path\n   * @returns Marker content string, or null if no config hash available\n   */\n  getMarkerContent(mountPath: string): string | null {\n    const entry = this._entries.get(mountPath);\n    if (!entry?.configHash) {\n      return null;\n    }\n    return `${mountPath}|${entry.configHash}`;\n  }\n\n  /**\n   * Parse marker file content.\n   *\n   * @param content - The marker file content (format: \"path|configHash\")\n   * @returns Parsed path and configHash, or null if invalid format\n   */\n  parseMarkerContent(content: string): { path: string; configHash: string } | null {\n    const separatorIndex = content.lastIndexOf('|');\n    if (separatorIndex <= 0) {\n      return null;\n    }\n    const path = content.slice(0, separatorIndex);\n    const configHash = content.slice(separatorIndex + 1);\n    if (!path || !configHash) return null;\n    return { path, configHash };\n  }\n\n  /**\n   * Check if a config hash matches the expected hash for a mount path.\n   *\n   * @param mountPath - The mount path to check\n   * @param storedHash - The hash from the marker file\n   * @returns true if the hashes match\n   */\n  isConfigMatching(mountPath: string, storedHash: string): boolean {\n    const entry = this._entries.get(mountPath);\n    return entry?.configHash === storedHash;\n  }\n\n  /**\n   * Compute a hash for a mount config. Used for comparing configs across mounts.\n   *\n   * @param config - The config to hash\n   * @returns A hash string suitable for comparison\n   */\n  computeConfigHash(config: FilesystemMountConfig): string {\n    return this.hashConfig(config);\n  }\n\n  // ---------------------------------------------------------------------------\n  // Internal\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Hash a mount config for comparison.\n   */\n  private hashConfig(config: FilesystemMountConfig): string {\n    const normalized = JSON.stringify(this.sortKeysDeep(config));\n    return createHash('sha256').update(normalized).digest('hex').slice(0, 16);\n  }\n\n  private sortKeysDeep(obj: unknown): unknown {\n    if (obj === null || typeof obj !== 'object') return obj;\n    if (Array.isArray(obj)) return obj.map(item => this.sortKeysDeep(item));\n    return Object.keys(obj as Record<string, unknown>)\n      .sort()\n      .reduce(\n        (acc, key) => {\n          acc[key] = this.sortKeysDeep((obj as Record<string, unknown>)[key]);\n          return acc;\n        },\n        {} as Record<string, unknown>,\n      );\n  }\n}\n","/**\n * Shell-quote an argument for safe interpolation into a shell command string.\n * Safe characters (alphanumeric, `.`, `_`, `-`, `/`, `=`, `:`, `@`) pass through.\n * Everything else is wrapped in single quotes with embedded quotes escaped.\n */\nexport function shellQuote(arg: string): string {\n  if (/^[a-zA-Z0-9._\\-\\/=:@]+$/.test(arg)) return arg;\n  return `'${arg.replace(/'/g, \"'\\\\''\")}'`;\n}\n","/**\n * MastraSandbox Base Class\n *\n * Abstract base class for sandbox providers that want automatic logger integration.\n * Extends MastraBase to receive the Mastra logger when registered with a Mastra instance.\n *\n * MountManager is automatically created if the subclass implements `mount()`.\n * Use `declare readonly mounts: MountManager` to get non-optional typing.\n *\n * ## Lifecycle Management\n *\n * The base class provides race-condition-safe lifecycle wrappers:\n * - `_start()` - Handles concurrent calls, status management, and mount processing\n * - `_stop()` - Handles concurrent calls and status management\n * - `_destroy()` - Handles concurrent calls and status management\n *\n * Subclasses override the plain `start()`, `stop()`, and `destroy()` methods\n * to provide their implementation. Callers use the `_`-prefixed wrappers\n * (or `callLifecycle()`) which add status tracking and race-condition safety.\n *\n * External providers can extend this class to get logger support, or implement\n * the WorkspaceSandbox interface directly if they don't need logging.\n */\n\nimport { MastraBase } from '../../base';\nimport type { IMastraLogger } from '../../logger';\nimport { RegisteredLogger } from '../../logger/constants';\nimport type { WorkspaceFilesystem } from '../filesystem/filesystem';\nimport type { MountResult } from '../filesystem/mount';\nimport type { ProviderStatus } from '../lifecycle';\nimport { SandboxNotReadyError } from './errors';\nimport { MountManager } from './mount-manager';\nimport type { SandboxProcessManager } from './process-manager';\nimport type { WorkspaceSandbox } from './sandbox';\nimport type { CommandResult, ExecuteCommandOptions, SandboxInfo } from './types';\nimport { shellQuote } from './utils';\n\n/**\n * Lifecycle hook that fires during sandbox state transitions.\n * Receives the sandbox instance so users can call `executeCommand`, read files, etc.\n */\nexport type SandboxLifecycleHook = (args: { sandbox: WorkspaceSandbox }) => void | Promise<void>;\n\n/**\n * Options for the MastraSandbox base class constructor.\n * Providers extend this to add their own options while inheriting lifecycle hooks.\n */\nexport interface MastraSandboxOptions {\n  /** Called after the sandbox reaches 'running' status */\n  onStart?: SandboxLifecycleHook;\n  /** Called before the sandbox stops */\n  onStop?: SandboxLifecycleHook;\n  /** Called before the sandbox is destroyed */\n  onDestroy?: SandboxLifecycleHook;\n\n  /**\n   * Process manager for this sandbox.\n   *\n   * When provided, the base class automatically:\n   * 1. Sets the sandbox back-reference on the process manager\n   * 2. Exposes it via `this.processes`\n   * 3. Creates a default `executeCommand` implementation (spawn + wait)\n   *\n   * @example\n   * ```typescript\n   * class MySandbox extends MastraSandbox {\n   *   constructor() {\n   *     super({\n   *       name: 'MySandbox',\n   *       processes: new MyProcessManager({ env: myEnv }),\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  processes?: SandboxProcessManager;\n}\n\n/**\n * Abstract base class for sandbox providers with logger support.\n *\n * Providers that extend this class automatically receive the Mastra logger\n * when the sandbox is used with a Mastra instance. MountManager is also\n * automatically created if the subclass implements `mount()`.\n *\n * @example\n * ```typescript\n * class MyCustomSandbox extends MastraSandbox {\n *   declare readonly mounts: MountManager;  // Non-optional type\n *   readonly id = 'my-sandbox';\n *   readonly name = 'MyCustomSandbox';\n *   readonly provider = 'custom';\n *   status: ProviderStatus = 'pending';\n *\n *   constructor() {\n *     super({\n *       name: 'MyCustomSandbox',\n *       processes: new MyProcessManager({ env: myEnv }),\n *     });\n *   }\n *\n *   async start(): Promise<void> { /* startup logic *\\/ }\n *   async mount(filesystem, mountPath) { ... }\n *   async unmount(mountPath) { ... }\n * }\n * ```\n */\nexport abstract class MastraSandbox extends MastraBase implements WorkspaceSandbox {\n  /** Unique identifier for this sandbox instance */\n  abstract readonly id: string;\n\n  /** Human-readable name (e.g., 'E2B Sandbox', 'Docker') */\n  abstract readonly name: string;\n\n  /** Provider type identifier */\n  abstract readonly provider: string;\n\n  /** Current status of the sandbox */\n  abstract status: ProviderStatus;\n\n  // ---------------------------------------------------------------------------\n  // Optional WorkspaceSandbox members\n  //\n  // Re-declared here so that variables typed as `MastraSandbox` (not just\n  // `WorkspaceSandbox`) can see them.  TypeScript's `implements` is a\n  // constraint check, not a type merge  optional interface members are\n  // invisible on the class type unless explicitly listed.\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Execute a shell command and wait for completion.\n   *\n   * Method syntax (not property syntax) is intentional  it prevents\n   * `useDefineForClassFields` from emitting `this.executeCommand = undefined`\n   * which would shadow prototype methods defined by subclasses.\n   */\n  executeCommand?(command: string, args?: string[], options?: ExecuteCommandOptions): Promise<CommandResult>;\n\n  /** Process manager */\n  readonly processes?: SandboxProcessManager;\n\n  /** Mount manager - automatically created if subclass implements mount() */\n  readonly mounts?: MountManager;\n\n  /** Optional mount method - implement to enable mounting support */\n  mount?(filesystem: WorkspaceFilesystem, mountPath: string): Promise<MountResult>;\n\n  /** Optional unmount method */\n  unmount?(mountPath: string): Promise<void>;\n\n  /** Get instructions describing how this sandbox works */\n  getInstructions?(): string;\n\n  /** Get sandbox status and metadata */\n  getInfo?(): SandboxInfo | Promise<SandboxInfo>;\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle Promise Tracking (prevents race conditions)\n  // ---------------------------------------------------------------------------\n\n  /** Promise for _start() to prevent race conditions from concurrent calls */\n  protected _startPromise?: Promise<void>;\n\n  /** Promise for _stop() to prevent race conditions from concurrent calls */\n  protected _stopPromise?: Promise<void>;\n\n  /** Promise for _destroy() to prevent race conditions from concurrent calls */\n  protected _destroyPromise?: Promise<void>;\n\n  /** Lifecycle callbacks */\n  private readonly _onStart?: SandboxLifecycleHook;\n  private readonly _onStop?: SandboxLifecycleHook;\n  private readonly _onDestroy?: SandboxLifecycleHook;\n\n  constructor(options: { name: string } & MastraSandboxOptions) {\n    super({ name: options.name, component: RegisteredLogger.WORKSPACE });\n\n    this._onStart = options.onStart;\n    this._onStop = options.onStop;\n    this._onDestroy = options.onDestroy;\n\n    // Automatically create MountManager if subclass implements mount()\n    if (this.mount) {\n      this.mounts = new MountManager({\n        mount: this.mount.bind(this),\n        logger: this.logger,\n      });\n    }\n\n    // Wire up process manager if provided\n    if (options.processes) {\n      const pm = options.processes;\n      // Set the sandbox back-reference. The process manager reads this\n      // lazily (at call time), so it's fine that the subclass constructor\n      // hasn't finished yet.\n      pm.sandbox = this;\n      this.processes = pm;\n\n      // Auto-create executeCommand (spawn + wait) unless the subclass\n      // defines its own implementation.\n      if (!this.executeCommand) {\n        this.executeCommand = async (command: string, args?: string[], opts?: ExecuteCommandOptions) => {\n          const fullCommand = args?.length ? `${command} ${args.map(a => shellQuote(a)).join(' ')}` : command;\n          this.logger.debug(`[${this.name}] Executing: ${fullCommand}`, { cwd: opts?.cwd });\n\n          const handle = await pm.spawn(fullCommand, opts ?? {});\n          const result = await handle.wait();\n\n          this.logger.debug(`[${this.name}] Exit code: ${result.exitCode} (${result.executionTimeMs}ms)`);\n\n          return { ...result, command: fullCommand };\n        };\n      }\n    }\n  }\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle Wrappers (race-condition-safe)\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Start the sandbox (wrapper with status management and race-condition safety).\n   *\n   * This method is race-condition-safe - concurrent calls will return the same promise.\n   * Handles status management and automatically processes pending mounts after startup.\n   *\n   * Subclasses override `start()` to provide their startup logic.\n   */\n  async _start(): Promise<void> {\n    // Already running\n    if (this.status === 'running') {\n      return;\n    }\n\n    // Wait for in-flight stop/destroy before starting.\n    // Intentionally no .catch()  if teardown is failing, _start() should propagate\n    // that error rather than silently starting on top of a broken state.\n    if (this._stopPromise) await this._stopPromise;\n    if (this._destroyPromise) await this._destroyPromise;\n\n    // Cannot start a destroyed sandbox\n    if (this.status === 'destroyed') {\n      throw new Error('Cannot start a destroyed sandbox');\n    }\n\n    // Start already in progress - return existing promise\n    if (this._startPromise) {\n      return this._startPromise;\n    }\n\n    // Create and store the start promise\n    this._startPromise = this._executeStart();\n\n    try {\n      await this._startPromise;\n    } finally {\n      this._startPromise = undefined;\n    }\n  }\n\n  /**\n   * Internal start execution - handles status and mount processing.\n   */\n  private async _executeStart(): Promise<void> {\n    this.status = 'starting';\n\n    try {\n      await this.start();\n      this.status = 'running';\n\n      // Fire onStart callback after sandbox is running  treat failure as non-fatal\n      // so that a bad callback doesn't kill an otherwise healthy sandbox\n      try {\n        await this._onStart?.({ sandbox: this });\n      } catch (error) {\n        this.logger.warn('onStart callback failed', { error });\n      }\n    } catch (error) {\n      this.status = 'error';\n      throw error;\n    }\n\n    // Process any pending mounts after successful start\n    // Mount failures are tracked individually in MountManager and\n    // shouldn't mark the sandbox itself as errored\n    try {\n      await this.mounts?.processPending();\n    } catch (error) {\n      // Mount failures are tracked in MountManager  log but don't affect sandbox status\n      this.logger.warn('Unexpected error processing pending mounts', { error });\n    }\n  }\n\n  /**\n   * Override this method to implement sandbox startup logic.\n   *\n   * Called by `_start()` after status is set to 'starting'.\n   * Status will be set to 'running' on success, 'error' on failure.\n   *\n   * @example\n   * ```typescript\n   * async start(): Promise<void> {\n   *   this._sandbox = await Sandbox.create({ ... });\n   * }\n   * ```\n   */\n  async start(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  /**\n   * Ensure the sandbox is running.\n   *\n   * Calls `_start()` if status is not 'running'. Useful for lazy initialization\n   * where operations should automatically start the sandbox if needed.\n   *\n   * @throws {SandboxNotReadyError} if the sandbox fails to reach 'running' status\n   *\n   * @example\n   * ```typescript\n   * async executeCommand(command: string): Promise<CommandResult> {\n   *   await this.ensureRunning();\n   *   // Now safe to use the sandbox\n   * }\n   * ```\n   */\n  async ensureRunning(): Promise<void> {\n    // Already destroyed  cannot use this sandbox\n    if (this.status === 'destroyed') {\n      throw new SandboxNotReadyError(this.id);\n    }\n    // During teardown the sandbox is still operational (e.g. destroy()\n    // may need to list/kill processes).  Allow operations to proceed\n    // without trying to restart.\n    if (this.status === 'destroying' || this.status === 'stopping') {\n      return;\n    }\n    if (this.status !== 'running') {\n      await this._start();\n    }\n    if (this.status !== 'running') {\n      throw new SandboxNotReadyError(this.id);\n    }\n  }\n\n  /**\n   * Stop the sandbox (wrapper with status management and race-condition safety).\n   *\n   * This method is race-condition-safe - concurrent calls will return the same promise.\n   * Handles status management.\n   *\n   * Subclasses override `stop()` to provide their stop logic.\n   */\n  async _stop(): Promise<void> {\n    // Already stopped\n    if (this.status === 'stopped') {\n      return;\n    }\n\n    // Wait for in-flight start before stopping\n    if (this._startPromise) await this._startPromise.catch(() => {});\n\n    // Stop already in progress - return existing promise\n    if (this._stopPromise) {\n      return this._stopPromise;\n    }\n\n    // Create and store the stop promise\n    this._stopPromise = this._executeStop();\n\n    try {\n      await this._stopPromise;\n    } finally {\n      this._stopPromise = undefined;\n    }\n  }\n\n  /**\n   * Internal stop execution - handles status.\n   */\n  private async _executeStop(): Promise<void> {\n    this.status = 'stopping';\n\n    try {\n      // Fire onStop callback before stopping\n      await this._onStop?.({ sandbox: this });\n\n      await this.stop();\n      this.status = 'stopped';\n    } catch (error) {\n      this.status = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Override this method to implement sandbox stop logic.\n   *\n   * Called by `_stop()` after status is set to 'stopping'.\n   * Status will be set to 'stopped' on success, 'error' on failure.\n   */\n  async stop(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  /**\n   * Destroy the sandbox and clean up all resources (wrapper with status management).\n   *\n   * This method is race-condition-safe - concurrent calls will return the same promise.\n   * Handles status management.\n   *\n   * Subclasses override `destroy()` to provide their destroy logic.\n   */\n  async _destroy(): Promise<void> {\n    // Already destroyed\n    if (this.status === 'destroyed') {\n      return;\n    }\n\n    // Never started  nothing to clean up\n    if (this.status === 'pending') {\n      this.status = 'destroyed';\n      return;\n    }\n\n    // Wait for in-flight start/stop before destroying\n    if (this._startPromise) await this._startPromise.catch(() => {});\n    if (this._stopPromise) await this._stopPromise.catch(() => {});\n\n    // Destroy already in progress - return existing promise\n    if (this._destroyPromise) {\n      return this._destroyPromise;\n    }\n\n    // Create and store the destroy promise\n    this._destroyPromise = this._executeDestroy();\n\n    try {\n      await this._destroyPromise;\n    } finally {\n      this._destroyPromise = undefined;\n    }\n  }\n\n  /**\n   * Internal destroy execution - handles status.\n   */\n  private async _executeDestroy(): Promise<void> {\n    this.status = 'destroying';\n\n    try {\n      // Fire onDestroy callback before destroying\n      await this._onDestroy?.({ sandbox: this });\n\n      await this.destroy();\n      this.status = 'destroyed';\n    } catch (error) {\n      this.status = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Override this method to implement sandbox destroy logic.\n   *\n   * Called by `_destroy()` after status is set to 'destroying'.\n   * Status will be set to 'destroyed' on success, 'error' on failure.\n   */\n  async destroy(): Promise<void> {\n    // Default no-op - subclasses override\n  }\n\n  // ---------------------------------------------------------------------------\n  // Logger Propagation\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Override to propagate logger to MountManager.\n   * @internal\n   */\n  override __setLogger(logger: IMastraLogger): void {\n    super.__setLogger(logger);\n    // Propagate to MountManager if it exists\n    this.mounts?.__setLogger(logger);\n  }\n}\n","/**\n * Line Utilities\n *\n * Utility functions for working with line-based content:\n * - Extract lines by range\n * - Convert character positions to line numbers\n * - Format content with line number prefixes\n */\n\n/**\n * Line range where content was found\n */\nexport interface LineRange {\n  /** Starting line number (1-indexed) */\n  start: number;\n  /** Ending line number (1-indexed, inclusive) */\n  end: number;\n}\n\n/**\n * Extract lines from content by line range.\n *\n * @param content - The document content\n * @param startLine - Starting line number (1-indexed)\n * @param endLine - Ending line number (1-indexed, inclusive)\n * @returns Object with extracted content and metadata\n */\nexport function extractLines(\n  content: string,\n  startLine?: number,\n  endLine?: number,\n): {\n  content: string;\n  lines: { start: number; end: number };\n  totalLines: number;\n} {\n  const allLines = content.split('\\n');\n  const totalLines = allLines.length;\n\n  // Default to full content\n  const start = Math.max(1, startLine ?? 1);\n  const end = Math.min(totalLines, endLine ?? totalLines);\n\n  // Extract the requested range (convert to 0-indexed)\n  const extractedLines = allLines.slice(start - 1, end);\n\n  return {\n    content: extractedLines.join('\\n'),\n    lines: { start, end },\n    totalLines,\n  };\n}\n\n/**\n * Extract lines using offset/limit style parameters (like Claude Code).\n *\n * @param content - The document content\n * @param offset - Line number to start from (1-indexed, default: 1)\n * @param limit - Maximum number of lines to read (default: all remaining)\n * @returns Object with extracted content and metadata\n */\nexport function extractLinesWithLimit(\n  content: string,\n  offset?: number,\n  limit?: number,\n): {\n  content: string;\n  lines: { start: number; end: number };\n  totalLines: number;\n} {\n  const startLine = offset ?? 1;\n  const endLine = limit ? startLine + limit - 1 : undefined;\n  return extractLines(content, startLine, endLine);\n}\n\n/**\n * Format content with line number prefixes.\n * Output format matches Claude Code: \"     1content here\"\n *\n * @param content - The content to format\n * @param startLineNumber - The line number of the first line (1-indexed)\n * @returns Formatted content with line numbers\n */\nexport function formatWithLineNumbers(content: string, startLineNumber: number = 1): string {\n  const lines = content.split('\\n');\n  const maxLineNum = startLineNumber + lines.length - 1;\n  const padWidth = Math.max(6, String(maxLineNum).length + 1);\n\n  return lines\n    .map((line, i) => {\n      const lineNum = startLineNumber + i;\n      return `${String(lineNum).padStart(padWidth)}${line}`;\n    })\n    .join('\\n');\n}\n\n/**\n * Convert a character index to a line number.\n * Useful for converting RAG chunk character offsets to line numbers.\n *\n * @param content - The full document content\n * @param charIndex - The character index (0-indexed)\n * @returns The line number (1-indexed), or undefined if charIndex is out of bounds\n */\nexport function charIndexToLineNumber(content: string, charIndex: number): number | undefined {\n  if (charIndex < 0 || charIndex > content.length) {\n    return undefined;\n  }\n\n  // Count newlines before the character index\n  let lineNumber = 1;\n  for (let i = 0; i < charIndex && i < content.length; i++) {\n    if (content[i] === '\\n') {\n      lineNumber++;\n    }\n  }\n\n  return lineNumber;\n}\n\n/**\n * Convert character range to line range.\n * Useful for converting RAG chunk character offsets to line ranges.\n *\n * @param content - The full document content\n * @param startCharIdx - Start character index (0-indexed)\n * @param endCharIdx - End character index (0-indexed, exclusive)\n * @returns LineRange (1-indexed) or undefined if indices are out of bounds\n */\nexport function charRangeToLineRange(content: string, startCharIdx: number, endCharIdx: number): LineRange | undefined {\n  const startLine = charIndexToLineNumber(content, startCharIdx);\n  // For end, we want the line containing the last character (endCharIdx - 1)\n  const endLine = charIndexToLineNumber(content, Math.max(0, endCharIdx - 1));\n\n  if (startLine === undefined || endLine === undefined) {\n    return undefined;\n  }\n\n  return { start: startLine, end: endLine };\n}\n\n/**\n * Count occurrences of a string in content.\n *\n * @param content - The content to search\n * @param searchString - The string to find\n * @returns Number of occurrences\n */\nexport function countOccurrences(content: string, searchString: string): number {\n  if (!searchString) return 0;\n\n  let count = 0;\n  let position = 0;\n\n  while ((position = content.indexOf(searchString, position)) !== -1) {\n    count++;\n    position += searchString.length;\n  }\n\n  return count;\n}\n\n/**\n * Replace a string in content, with validation for uniqueness.\n *\n * @param content - The content to modify\n * @param oldString - The string to find and replace\n * @param newString - The replacement string\n * @param replaceAll - If true, replace all occurrences; if false, require unique match\n * @returns Object with result content and metadata\n * @throws Error if oldString is not found or not unique (when replaceAll is false)\n */\nexport function replaceString(\n  content: string,\n  oldString: string,\n  newString: string,\n  replaceAll: boolean = false,\n): {\n  content: string;\n  replacements: number;\n} {\n  const count = countOccurrences(content, oldString);\n\n  if (count === 0) {\n    throw new StringNotFoundError(oldString);\n  }\n\n  if (!replaceAll && count > 1) {\n    throw new StringNotUniqueError(oldString, count);\n  }\n\n  if (replaceAll) {\n    // Replace all occurrences\n    const result = content.split(oldString).join(newString);\n    return { content: result, replacements: count };\n  } else {\n    // Replace first (and only) occurrence\n    const result = content.replace(oldString, newString);\n    return { content: result, replacements: 1 };\n  }\n}\n\n/**\n * Error thrown when string is not found during replacement.\n */\nexport class StringNotFoundError extends Error {\n  constructor(public readonly searchString: string) {\n    super(`The specified text was not found. Make sure you use the exact text from the file.`);\n    this.name = 'StringNotFoundError';\n  }\n}\n\n/**\n * Error thrown when string appears multiple times but unique match required.\n */\nexport class StringNotUniqueError extends Error {\n  constructor(\n    public readonly searchString: string,\n    public readonly occurrences: number,\n  ) {\n    super(\n      `The specified text appears ${occurrences} times. Provide more surrounding context to make the match unique, or use replace_all to replace all occurrences.`,\n    );\n    this.name = 'StringNotUniqueError';\n  }\n}\n","/**\n * BM25 (Best Matching 25) implementation for keyword-based search.\n *\n * BM25 is a probabilistic ranking function used for information retrieval.\n * It ranks documents based on the query terms appearing in each document,\n * taking into account term frequency and document length normalization.\n */\n\nimport type { LineRange } from '../line-utils';\n\n/**\n * BM25 configuration parameters\n */\nexport interface BM25Config {\n  /**\n   * Controls term frequency saturation.\n   * Higher values give more weight to term frequency.\n   * Typical range: 1.2 - 2.0\n   * @default 1.5\n   */\n  k1?: number;\n\n  /**\n   * Controls document length normalization.\n   * 0 = no length normalization, 1 = full normalization\n   * @default 0.75\n   */\n  b?: number;\n}\n\n/**\n * Represents a document in the BM25 index\n */\nexport interface BM25Document {\n  /** Document identifier */\n  id: string;\n  /** Document content */\n  content: string;\n  /** Pre-computed tokens for the document */\n  tokens: string[];\n  /** Token frequency map */\n  termFrequencies: Map<string, number>;\n  /** Total number of tokens */\n  length: number;\n  /** Optional metadata */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Result from a BM25 search\n */\nexport interface BM25SearchResult {\n  /** Document identifier */\n  id: string;\n  /** Document content */\n  content: string;\n  /** BM25 score (higher is more relevant) */\n  score: number;\n  /** Optional metadata */\n  metadata?: Record<string, unknown>;\n  /** Line range where query terms were found (if computed) */\n  lineRange?: LineRange;\n}\n\n/**\n * Tokenization options\n */\nexport interface TokenizeOptions {\n  /** Convert to lowercase */\n  lowercase?: boolean;\n  /** Remove punctuation */\n  removePunctuation?: boolean;\n  /** Minimum token length */\n  minLength?: number;\n  /** Custom stopwords to remove */\n  stopwords?: Set<string>;\n  /** Custom split pattern (default: /\\s+/) */\n  splitPattern?: RegExp;\n}\n\n/**\n * Default English stopwords\n */\nexport const DEFAULT_STOPWORDS = new Set([\n  'a',\n  'an',\n  'and',\n  'are',\n  'as',\n  'at',\n  'be',\n  'by',\n  'for',\n  'from',\n  'has',\n  'he',\n  'in',\n  'is',\n  'it',\n  'its',\n  'of',\n  'on',\n  'or',\n  'that',\n  'the',\n  'to',\n  'was',\n  'were',\n  'will',\n  'with',\n]);\n\n/**\n * Default tokenization options\n */\nconst DEFAULT_TOKENIZE_OPTIONS: Required<TokenizeOptions> = {\n  lowercase: true,\n  removePunctuation: true,\n  minLength: 2,\n  stopwords: DEFAULT_STOPWORDS,\n  splitPattern: /\\s+/,\n};\n\n/**\n * Tokenize text into an array of terms\n */\nexport function tokenize(text: string, options: TokenizeOptions = {}): string[] {\n  const opts = { ...DEFAULT_TOKENIZE_OPTIONS, ...options };\n\n  let processed = text;\n\n  // Convert to lowercase if enabled\n  if (opts.lowercase) {\n    processed = processed.toLowerCase();\n  }\n\n  // Remove punctuation if enabled\n  if (opts.removePunctuation) {\n    processed = processed.replace(/[^\\w\\s]/g, ' ');\n  }\n\n  // Split into tokens\n  const tokens = processed.split(opts.splitPattern).filter(token => {\n    // Filter by minimum length\n    if (token.length < opts.minLength) {\n      return false;\n    }\n    // Filter stopwords\n    if (opts.stopwords?.has(token)) {\n      return false;\n    }\n    return true;\n  });\n\n  return tokens;\n}\n\n// Re-export line utilities from line-utils.ts (except findLineRange which is defined here)\nexport {\n  extractLines,\n  extractLinesWithLimit,\n  formatWithLineNumbers,\n  replaceString,\n  StringNotFoundError,\n  StringNotUniqueError,\n} from '../line-utils';\n\n/**\n * Find the line range where query terms appear in content.\n * Returns the range spanning from the first to the last line containing any query term.\n *\n * @param content - The document content\n * @param queryTerms - Tokenized query terms to find\n * @param options - Tokenization options (should match indexing options)\n * @returns LineRange if terms found, undefined otherwise\n */\nexport function findLineRange(\n  content: string,\n  queryTerms: string[],\n  options: TokenizeOptions = {},\n): LineRange | undefined {\n  if (queryTerms.length === 0) return undefined;\n\n  const lines = content.split('\\n');\n\n  // Default tokenize options for matching\n  const defaultOpts = { lowercase: true, removePunctuation: true, minLength: 2 };\n  const opts = { ...defaultOpts, ...options };\n\n  // Normalize query terms for matching\n  const normalizedTerms = new Set(queryTerms.map(t => (opts.lowercase ? t.toLowerCase() : t)));\n\n  let firstMatchLine: number | undefined;\n  let lastMatchLine: number | undefined;\n\n  for (let i = 0; i < lines.length; i++) {\n    const lineTokens = tokenize(lines[i]!, options);\n\n    // Check if any query term appears in this line\n    for (const token of lineTokens) {\n      if (normalizedTerms.has(token)) {\n        const lineNum = i + 1; // 1-indexed\n        if (firstMatchLine === undefined) {\n          firstMatchLine = lineNum;\n        }\n        lastMatchLine = lineNum;\n        break; // Found a match on this line, move to next line\n      }\n    }\n  }\n\n  if (firstMatchLine !== undefined && lastMatchLine !== undefined) {\n    return { start: firstMatchLine, end: lastMatchLine };\n  }\n\n  return undefined;\n}\n\n/**\n * Compute term frequencies for a list of tokens\n */\nfunction computeTermFrequencies(tokens: string[]): Map<string, number> {\n  const frequencies = new Map<string, number>();\n  for (const token of tokens) {\n    frequencies.set(token, (frequencies.get(token) || 0) + 1);\n  }\n  return frequencies;\n}\n\n/**\n * BM25 Index for keyword-based document retrieval\n */\nexport class BM25Index {\n  /** BM25 k1 parameter */\n  readonly k1: number;\n  /** BM25 b parameter */\n  readonly b: number;\n\n  /** Documents in the index */\n  #documents: Map<string, BM25Document> = new Map();\n  /** Inverted index: term -> document IDs containing the term */\n  #invertedIndex: Map<string, Set<string>> = new Map();\n  /** Document frequency: term -> number of documents containing the term */\n  #documentFrequency: Map<string, number> = new Map();\n  /** Average document length */\n  #avgDocLength: number = 0;\n  /** Total number of documents */\n  #docCount: number = 0;\n  /** Tokenization options */\n  #tokenizeOptions: TokenizeOptions;\n\n  constructor(config: BM25Config = {}, tokenizeOptions: TokenizeOptions = {}) {\n    this.k1 = config.k1 ?? 1.5;\n    this.b = config.b ?? 0.75;\n    this.#tokenizeOptions = tokenizeOptions;\n  }\n\n  /**\n   * Add a document to the index\n   */\n  add(id: string, content: string, metadata?: Record<string, unknown>): void {\n    // Remove existing document if it exists\n    if (this.#documents.has(id)) {\n      this.remove(id);\n    }\n\n    const tokens = tokenize(content, this.#tokenizeOptions);\n    const termFrequencies = computeTermFrequencies(tokens);\n\n    const doc: BM25Document = {\n      id,\n      content,\n      tokens,\n      termFrequencies,\n      length: tokens.length,\n      metadata,\n    };\n\n    this.#documents.set(id, doc);\n    this.#docCount++;\n\n    // Update inverted index and document frequency\n    for (const term of termFrequencies.keys()) {\n      if (!this.#invertedIndex.has(term)) {\n        this.#invertedIndex.set(term, new Set());\n      }\n      this.#invertedIndex.get(term)!.add(id);\n      this.#documentFrequency.set(term, (this.#documentFrequency.get(term) || 0) + 1);\n    }\n\n    // Update average document length\n    this.#updateAvgDocLength();\n  }\n\n  /**\n   * Remove a document from the index\n   */\n  remove(id: string): boolean {\n    const doc = this.#documents.get(id);\n    if (!doc) {\n      return false;\n    }\n\n    // Update inverted index and document frequency\n    for (const term of doc.termFrequencies.keys()) {\n      const docIds = this.#invertedIndex.get(term);\n      if (docIds) {\n        docIds.delete(id);\n        if (docIds.size === 0) {\n          this.#invertedIndex.delete(term);\n          this.#documentFrequency.delete(term);\n        } else {\n          this.#documentFrequency.set(term, (this.#documentFrequency.get(term) || 1) - 1);\n        }\n      }\n    }\n\n    this.#documents.delete(id);\n    this.#docCount--;\n\n    // Update average document length\n    this.#updateAvgDocLength();\n\n    return true;\n  }\n\n  /**\n   * Clear all documents from the index\n   */\n  clear(): void {\n    this.#documents.clear();\n    this.#invertedIndex.clear();\n    this.#documentFrequency.clear();\n    this.#docCount = 0;\n    this.#avgDocLength = 0;\n  }\n\n  /**\n   * Search for documents matching the query\n   */\n  search(query: string, topK: number = 10, minScore: number = 0): BM25SearchResult[] {\n    const queryTokens = tokenize(query, this.#tokenizeOptions);\n\n    if (queryTokens.length === 0 || this.#docCount === 0) {\n      return [];\n    }\n\n    const scores = new Map<string, number>();\n\n    // Calculate BM25 scores for each document\n    for (const queryTerm of queryTokens) {\n      const docIds = this.#invertedIndex.get(queryTerm);\n      if (!docIds) {\n        continue;\n      }\n\n      const df = this.#documentFrequency.get(queryTerm) || 0;\n      const idf = this.#computeIDF(df);\n\n      for (const docId of docIds) {\n        const doc = this.#documents.get(docId)!;\n        const tf = doc.termFrequencies.get(queryTerm) || 0;\n        const termScore = this.#computeTermScore(tf, doc.length, idf);\n\n        scores.set(docId, (scores.get(docId) || 0) + termScore);\n      }\n    }\n\n    // Sort by score and return top K results\n    const results: BM25SearchResult[] = [];\n\n    for (const [docId, score] of scores.entries()) {\n      if (score >= minScore) {\n        const doc = this.#documents.get(docId)!;\n        results.push({\n          id: docId,\n          content: doc.content,\n          score,\n          metadata: doc.metadata,\n        });\n      }\n    }\n\n    // Sort by score descending\n    results.sort((a, b) => b.score - a.score);\n\n    return results.slice(0, topK);\n  }\n\n  /**\n   * Get a document by ID\n   */\n  get(id: string): BM25Document | undefined {\n    return this.#documents.get(id);\n  }\n\n  /**\n   * Check if a document exists in the index\n   */\n  has(id: string): boolean {\n    return this.#documents.has(id);\n  }\n\n  /**\n   * Get the number of documents in the index\n   */\n  get size(): number {\n    return this.#docCount;\n  }\n\n  /**\n   * Get all document IDs\n   */\n  get documentIds(): string[] {\n    return Array.from(this.#documents.keys());\n  }\n\n  /**\n   * Serialize the index to a JSON-compatible object\n   */\n  serialize(): BM25IndexData {\n    const documents: SerializedBM25Document[] = [];\n    for (const [id, doc] of this.#documents.entries()) {\n      documents.push({\n        id,\n        content: doc.content,\n        tokens: doc.tokens,\n        termFrequencies: Object.fromEntries(doc.termFrequencies),\n        length: doc.length,\n        metadata: doc.metadata,\n      });\n    }\n\n    return {\n      k1: this.k1,\n      b: this.b,\n      documents,\n      avgDocLength: this.#avgDocLength,\n    };\n  }\n\n  /**\n   * Deserialize an index from a JSON object\n   */\n  static deserialize(data: BM25IndexData, tokenizeOptions: TokenizeOptions = {}): BM25Index {\n    const index = new BM25Index({ k1: data.k1, b: data.b }, tokenizeOptions);\n\n    for (const doc of data.documents) {\n      const termFrequencies = new Map(Object.entries(doc.termFrequencies));\n\n      const document: BM25Document = {\n        id: doc.id,\n        content: doc.content,\n        tokens: doc.tokens,\n        termFrequencies,\n        length: doc.length,\n        metadata: doc.metadata,\n      };\n\n      index.#documents.set(doc.id, document);\n      index.#docCount++;\n\n      // Rebuild inverted index and document frequency\n      for (const term of termFrequencies.keys()) {\n        if (!index.#invertedIndex.has(term)) {\n          index.#invertedIndex.set(term, new Set());\n        }\n        index.#invertedIndex.get(term)!.add(doc.id);\n        index.#documentFrequency.set(term, (index.#documentFrequency.get(term) || 0) + 1);\n      }\n    }\n\n    index.#avgDocLength = data.avgDocLength;\n\n    return index;\n  }\n\n  /**\n   * Update average document length after add/remove operations\n   */\n  #updateAvgDocLength(): void {\n    if (this.#docCount === 0) {\n      this.#avgDocLength = 0;\n      return;\n    }\n\n    let totalLength = 0;\n    for (const doc of this.#documents.values()) {\n      totalLength += doc.length;\n    }\n    this.#avgDocLength = totalLength / this.#docCount;\n  }\n\n  /**\n   * Compute IDF (Inverse Document Frequency) for a term\n   */\n  #computeIDF(df: number): number {\n    // Using Robertson-Sprck Jones IDF formula\n    return Math.log((this.#docCount - df + 0.5) / (df + 0.5) + 1);\n  }\n\n  /**\n   * Compute the BM25 score component for a single term\n   */\n  #computeTermScore(tf: number, docLength: number, idf: number): number {\n    const numerator = tf * (this.k1 + 1);\n    const denominator = tf + this.k1 * (1 - this.b + this.b * (docLength / this.#avgDocLength));\n    return idf * (numerator / denominator);\n  }\n}\n\n/**\n * Serialized document format for persistence\n */\ninterface SerializedBM25Document {\n  id: string;\n  content: string;\n  tokens: string[];\n  termFrequencies: Record<string, number>;\n  length: number;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Serialized index data for persistence\n */\nexport interface BM25IndexData {\n  k1: number;\n  b: number;\n  documents: SerializedBM25Document[];\n  avgDocLength: number;\n}\n","/**\n * SearchEngine - Unified search engine supporting BM25, vector, and hybrid search.\n *\n * Provides search capabilities for Workspace, enabling keyword-based (BM25),\n * semantic (vector), and combined hybrid search across indexed content.\n */\n\nimport type { MastraVector, VectorFilter } from '../../vector';\nimport type { LineRange } from '../line-utils';\n\nimport { BM25Index, tokenize, findLineRange } from './bm25';\nimport type { BM25Config, TokenizeOptions } from './bm25';\n\n/**\n * Search mode options\n */\nexport type SearchMode = 'vector' | 'bm25' | 'hybrid';\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/**\n * Embedder interface - any function that takes text and returns embeddings\n */\nexport interface Embedder {\n  (text: string): Promise<number[]>;\n}\n\n/**\n * Configuration for vector search\n */\nexport interface VectorConfig {\n  /** Vector store for semantic search */\n  vectorStore: MastraVector;\n  /** Embedder function for generating vectors */\n  embedder: Embedder;\n  /** Index name for the vector store */\n  indexName: string;\n}\n\n/**\n * Configuration for BM25 search\n */\nexport interface BM25SearchConfig {\n  /** BM25 algorithm parameters */\n  bm25?: BM25Config;\n  /** Tokenization options */\n  tokenize?: TokenizeOptions;\n}\n\n/**\n * A document to be indexed\n */\nexport interface IndexDocument {\n  /** Unique identifier for this document */\n  id: string;\n  /** Text content to index */\n  content: string;\n  /** Optional metadata to store with the document */\n  metadata?: Record<string, unknown>;\n  /**\n   * For chunked documents: the starting line number of this chunk in the original document.\n   * When provided, lineRange in search results will be adjusted to reflect original document lines.\n   * (1-indexed)\n   */\n  startLineOffset?: number;\n}\n\n/**\n * Base search result with common fields\n */\nexport interface SearchResult {\n  /** Document identifier */\n  id: string;\n  /** Document content */\n  content: string;\n  /** Search score (0-1 for normalized results) */\n  score: number;\n  /** Line range where query terms appear */\n  lineRange?: LineRange;\n  /** Optional metadata */\n  metadata?: Record<string, unknown>;\n  /** Score breakdown by search type */\n  scoreDetails?: {\n    vector?: number;\n    bm25?: number;\n  };\n}\n\n/**\n * Options for searching\n */\nexport interface SearchOptions {\n  /** Maximum number of results to return */\n  topK?: number;\n  /** Minimum score threshold */\n  minScore?: number;\n  /** Search mode: 'bm25', 'vector', or 'hybrid' */\n  mode?: SearchMode;\n  /** Weight for vector scores in hybrid search (0-1, default 0.5) */\n  vectorWeight?: number;\n  /** Filter for vector search */\n  filter?: Record<string, unknown>;\n}\n\n/**\n * Configuration for SearchEngine\n */\nexport interface SearchEngineConfig {\n  /** BM25 configuration (enables BM25 search) */\n  bm25?: BM25SearchConfig;\n  /** Vector configuration (enables vector search) */\n  vector?: VectorConfig;\n  /** Whether to use lazy vector indexing (default: false = eager) */\n  lazyVectorIndex?: boolean;\n}\n\n// =============================================================================\n// SearchEngine\n// =============================================================================\n\n/**\n * Unified search engine supporting BM25, vector, and hybrid search.\n *\n * Used internally by Workspace to provide consistent search functionality.\n *\n * @example\n * ```typescript\n * const engine = new SearchEngine({\n *   bm25: { tokenize: { lowercase: true } },\n *   vector: { vectorStore, embedder, indexName: 'my-index' },\n * });\n *\n * // Index documents\n * await engine.index({ id: 'doc1', content: 'Hello world' });\n *\n * // Search\n * const results = await engine.search('hello', { mode: 'hybrid', topK: 5 });\n * ```\n */\nexport class SearchEngine {\n  /** BM25 index for keyword search */\n  #bm25Index?: BM25Index;\n\n  /** Tokenization options (stored for lineRange computation) */\n  #tokenizeOptions?: TokenizeOptions;\n\n  /** Vector configuration */\n  #vectorConfig?: VectorConfig;\n\n  /** Whether to use lazy vector indexing */\n  #lazyVectorIndex: boolean;\n\n  /** Documents pending vector indexing (for lazy mode) */\n  #pendingVectorDocs: IndexDocument[] = [];\n\n  /** Whether vector index has been built (for lazy mode) */\n  #vectorIndexBuilt: boolean = false;\n\n  constructor(config: SearchEngineConfig = {}) {\n    // Initialize BM25 if configured\n    if (config.bm25 !== undefined) {\n      this.#tokenizeOptions = config.bm25.tokenize;\n      this.#bm25Index = new BM25Index(config.bm25.bm25, this.#tokenizeOptions);\n    }\n\n    // Store vector config if provided\n    if (config.vector) {\n      this.#vectorConfig = config.vector;\n    }\n\n    this.#lazyVectorIndex = config.lazyVectorIndex ?? false;\n  }\n\n  // ===========================================================================\n  // Public API\n  // ===========================================================================\n\n  /**\n   * Index a document for search\n   */\n  async index(doc: IndexDocument): Promise<void> {\n    // Merge startLineOffset into metadata for retrieval at search time\n    const metadata: Record<string, unknown> = {\n      ...doc.metadata,\n    };\n    if (doc.startLineOffset !== undefined) {\n      metadata._startLineOffset = doc.startLineOffset;\n    }\n\n    // BM25 indexing (always synchronous and immediate)\n    if (this.#bm25Index) {\n      this.#bm25Index.add(doc.id, doc.content, metadata);\n    }\n\n    // Vector indexing\n    if (this.#vectorConfig) {\n      const docWithMergedMetadata = { ...doc, metadata };\n      if (this.#lazyVectorIndex) {\n        // Store for later indexing\n        this.#pendingVectorDocs.push(docWithMergedMetadata);\n        this.#vectorIndexBuilt = false;\n      } else {\n        // Index immediately\n        await this.#indexVector(docWithMergedMetadata);\n      }\n    }\n  }\n\n  /**\n   * Index multiple documents\n   */\n  async indexMany(docs: IndexDocument[]): Promise<void> {\n    for (const doc of docs) {\n      await this.index(doc);\n    }\n  }\n\n  /**\n   * Remove a document from the index\n   */\n  async remove(id: string): Promise<void> {\n    // Remove from BM25\n    if (this.#bm25Index) {\n      this.#bm25Index.remove(id);\n    }\n\n    // Remove from vector store\n    if (this.#vectorConfig) {\n      try {\n        await this.#vectorConfig.vectorStore.deleteVector({\n          indexName: this.#vectorConfig.indexName,\n          id,\n        });\n      } catch {\n        // Vector may not exist, ignore\n      }\n\n      // Also remove from pending docs if in lazy mode\n      if (this.#lazyVectorIndex) {\n        this.#pendingVectorDocs = this.#pendingVectorDocs.filter(d => d.id !== id);\n      }\n    }\n  }\n\n  /**\n   * Clear all indexed documents\n   */\n  clear(): void {\n    if (this.#bm25Index) {\n      this.#bm25Index.clear();\n    }\n    this.#pendingVectorDocs = [];\n    this.#vectorIndexBuilt = false;\n    // Note: We don't clear the vector store here as it may be shared\n  }\n\n  /**\n   * Search for documents\n   */\n  async search(query: string, options: SearchOptions = {}): Promise<SearchResult[]> {\n    const { topK = 10, minScore, mode, vectorWeight = 0.5, filter } = options;\n\n    const effectiveMode = this.#determineSearchMode(mode);\n\n    if (effectiveMode === 'bm25') {\n      return this.#searchBM25(query, topK, minScore);\n    }\n\n    if (effectiveMode === 'vector') {\n      return this.#searchVector(query, topK, minScore, filter);\n    }\n\n    // Hybrid search\n    return this.#searchHybrid(query, topK, minScore, vectorWeight, filter);\n  }\n\n  /**\n   * Check if BM25 search is available\n   */\n  get canBM25(): boolean {\n    return !!this.#bm25Index;\n  }\n\n  /**\n   * Check if vector search is available\n   */\n  get canVector(): boolean {\n    return !!this.#vectorConfig;\n  }\n\n  /**\n   * Check if hybrid search is available\n   */\n  get canHybrid(): boolean {\n    return this.canBM25 && this.canVector;\n  }\n\n  /**\n   * Get the BM25 index (for serialization/debugging)\n   */\n  get bm25Index(): BM25Index | undefined {\n    return this.#bm25Index;\n  }\n\n  // ===========================================================================\n  // Private Methods\n  // ===========================================================================\n\n  /**\n   * Determine the effective search mode\n   */\n  #determineSearchMode(requestedMode?: SearchMode): SearchMode {\n    if (requestedMode) {\n      if (requestedMode === 'vector' && !this.canVector) {\n        throw new Error('Vector search requires vector configuration.');\n      }\n      if (requestedMode === 'bm25' && !this.canBM25) {\n        throw new Error('BM25 search requires BM25 configuration.');\n      }\n      if (requestedMode === 'hybrid' && !this.canHybrid) {\n        throw new Error('Hybrid search requires both vector and BM25 configuration.');\n      }\n      return requestedMode;\n    }\n\n    // Auto-determine based on available configuration\n    if (this.canHybrid) {\n      return 'hybrid';\n    }\n    if (this.canVector) {\n      return 'vector';\n    }\n    if (this.canBM25) {\n      return 'bm25';\n    }\n\n    throw new Error('No search configuration available. Provide bm25 or vector config.');\n  }\n\n  /**\n   * Index a single document in the vector store\n   */\n  async #indexVector(doc: IndexDocument): Promise<void> {\n    if (!this.#vectorConfig) return;\n\n    const { vectorStore, embedder, indexName } = this.#vectorConfig;\n\n    const embedding = await embedder(doc.content);\n\n    await vectorStore.upsert({\n      indexName,\n      vectors: [embedding],\n      metadata: [\n        {\n          id: doc.id,\n          text: doc.content,\n          ...doc.metadata,\n        },\n      ],\n      ids: [doc.id],\n    });\n  }\n\n  /**\n   * Ensure vector index is built (for lazy mode)\n   */\n  async #ensureVectorIndex(): Promise<void> {\n    if (!this.#lazyVectorIndex || this.#vectorIndexBuilt || this.#pendingVectorDocs.length === 0) {\n      return;\n    }\n\n    for (const doc of this.#pendingVectorDocs) {\n      await this.#indexVector(doc);\n    }\n\n    this.#pendingVectorDocs = [];\n    this.#vectorIndexBuilt = true;\n  }\n\n  /**\n   * BM25 keyword search\n   */\n  #searchBM25(query: string, topK: number, minScore?: number): SearchResult[] {\n    if (!this.#bm25Index) {\n      throw new Error('BM25 search requires BM25 configuration.');\n    }\n\n    const results = this.#bm25Index.search(query, topK, minScore);\n    const queryTokens = tokenize(query, this.#tokenizeOptions);\n\n    return results.map(result => {\n      const rawLineRange = findLineRange(result.content, queryTokens, this.#tokenizeOptions);\n      const lineRange = this.#adjustLineRange(rawLineRange, result.metadata);\n      const { _startLineOffset, ...cleanMetadata } = result.metadata ?? {};\n\n      return {\n        id: result.id,\n        content: result.content,\n        score: result.score,\n        lineRange,\n        metadata: Object.keys(cleanMetadata).length > 0 ? cleanMetadata : undefined,\n        scoreDetails: { bm25: result.score },\n      };\n    });\n  }\n\n  /**\n   * Vector semantic search\n   */\n  async #searchVector(\n    query: string,\n    topK: number,\n    minScore?: number,\n    filter?: Record<string, unknown>,\n  ): Promise<SearchResult[]> {\n    if (!this.#vectorConfig) {\n      throw new Error('Vector search requires vector configuration.');\n    }\n\n    // Ensure lazy index is built\n    await this.#ensureVectorIndex();\n\n    const { vectorStore, embedder, indexName } = this.#vectorConfig;\n\n    const queryEmbedding = await embedder(query);\n\n    const vectorResults = await vectorStore.query({\n      indexName,\n      queryVector: queryEmbedding,\n      topK,\n      filter: filter as VectorFilter,\n    });\n\n    const queryTokens = tokenize(query, this.#tokenizeOptions);\n    const results: SearchResult[] = [];\n\n    for (const result of vectorResults) {\n      if (minScore !== undefined && result.score < minScore) {\n        continue;\n      }\n\n      const id = (result.metadata?.id as string) ?? result.id;\n      const content = (result.metadata?.text as string) ?? '';\n\n      // Extract metadata, excluding internal fields\n      const { id: _id, text: _text, _startLineOffset, ...restMetadata } = result.metadata ?? {};\n\n      const rawLineRange = findLineRange(content, queryTokens, this.#tokenizeOptions);\n      const lineRange = this.#adjustLineRange(rawLineRange, result.metadata);\n\n      results.push({\n        id,\n        content,\n        score: result.score,\n        lineRange,\n        metadata: Object.keys(restMetadata).length > 0 ? restMetadata : undefined,\n        scoreDetails: { vector: result.score },\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Hybrid search combining vector and BM25 scores\n   */\n  async #searchHybrid(\n    query: string,\n    topK: number,\n    minScore?: number,\n    vectorWeight: number = 0.5,\n    filter?: Record<string, unknown>,\n  ): Promise<SearchResult[]> {\n    // Get more results than requested to account for merging\n    const expandedTopK = Math.min(topK * 2, 50);\n\n    // Perform both searches in parallel\n    const [vectorResults, bm25Results] = await Promise.all([\n      this.#searchVector(query, expandedTopK, undefined, filter),\n      Promise.resolve(this.#searchBM25(query, expandedTopK, undefined)),\n    ]);\n\n    // Normalize BM25 scores to 0-1 range\n    const normalizedBM25 = this.#normalizeBM25Scores(bm25Results);\n\n    // Create score maps by document id\n    const bm25Map = new Map<string, SearchResult>();\n    for (const result of normalizedBM25) {\n      bm25Map.set(result.id, result);\n    }\n\n    const vectorMap = new Map<string, SearchResult>();\n    for (const result of vectorResults) {\n      vectorMap.set(result.id, result);\n    }\n\n    // Combine scores\n    const combinedResults = new Map<string, SearchResult>();\n    const allIds = new Set([...vectorMap.keys(), ...bm25Map.keys()]);\n    const bm25Weight = 1 - vectorWeight;\n\n    for (const id of allIds) {\n      const vectorResult = vectorMap.get(id);\n      const bm25Result = bm25Map.get(id);\n\n      const vectorScore = vectorResult?.scoreDetails?.vector ?? 0;\n      const bm25Score = bm25Result?.score ?? 0; // Already normalized\n\n      const combinedScore = vectorWeight * vectorScore + bm25Weight * bm25Score;\n\n      // Use data from whichever source has it\n      const baseResult = vectorResult ?? bm25Result!;\n\n      combinedResults.set(id, {\n        id,\n        content: baseResult.content,\n        score: combinedScore,\n        lineRange: bm25Result?.lineRange ?? vectorResult?.lineRange,\n        metadata: baseResult.metadata,\n        scoreDetails: {\n          vector: vectorResult?.scoreDetails?.vector,\n          bm25: bm25Result?.scoreDetails?.bm25,\n        },\n      });\n    }\n\n    // Sort by combined score and apply filters\n    let results = Array.from(combinedResults.values());\n    results.sort((a, b) => b.score - a.score);\n\n    if (minScore !== undefined) {\n      results = results.filter(r => r.score >= minScore);\n    }\n\n    return results.slice(0, topK);\n  }\n\n  /**\n   * Normalize BM25 scores to 0-1 range using min-max normalization\n   */\n  #normalizeBM25Scores(results: SearchResult[]): SearchResult[] {\n    if (results.length === 0) return results;\n\n    const scores = results.map(r => r.scoreDetails?.bm25 ?? r.score);\n    const maxScore = Math.max(...scores);\n    const minScore = Math.min(...scores);\n    const range = maxScore - minScore;\n\n    if (range === 0) {\n      return results.map(r => ({ ...r, score: 1 }));\n    }\n\n    return results.map(r => ({\n      ...r,\n      score: ((r.scoreDetails?.bm25 ?? r.score) - minScore) / range,\n    }));\n  }\n\n  /**\n   * Adjust line range for chunked documents.\n   * If the document has a _startLineOffset in metadata, adjust the line range\n   * to reflect the original document's line numbers.\n   */\n  #adjustLineRange(lineRange: LineRange | undefined, metadata?: Record<string, unknown>): LineRange | undefined {\n    if (!lineRange) return undefined;\n\n    const startLineOffset = metadata?._startLineOffset;\n    if (typeof startLineOffset !== 'number') {\n      return lineRange;\n    }\n\n    // Adjust line numbers: chunk lines are 1-indexed relative to chunk,\n    // offset is 1-indexed relative to original document\n    // So line 1 in chunk with offset 10 becomes line 10 in original\n    return {\n      start: lineRange.start + startLineOffset - 1,\n      end: lineRange.end + startLineOffset - 1,\n    };\n  }\n}\n","/**\n * Validation for Skills following the Agent Skills specification.\n * @see https://agentskills.io/specification\n *\n * This module uses plain validation functions instead of Zod to avoid\n * version compatibility issues between Zod 3 and Zod 4.\n */\n\n// =============================================================================\n// Constants\n// =============================================================================\n\n/**\n * Recommended limits from the Agent Skills spec\n */\nexport const SKILL_LIMITS = {\n  /** Recommended max tokens for instructions */\n  MAX_INSTRUCTION_TOKENS: 5000,\n  /** Recommended max lines for SKILL.md */\n  MAX_INSTRUCTION_LINES: 500,\n  /** Max characters for name field */\n  MAX_NAME_LENGTH: 64,\n  /** Max characters for description field */\n  MAX_DESCRIPTION_LENGTH: 1024,\n  /** Max characters for compatibility field */\n  MAX_COMPATIBILITY_LENGTH: 500,\n} as const;\n\n// =============================================================================\n// Types\n// =============================================================================\n\n/**\n * Skill metadata input type (what users provide)\n */\nexport interface SkillMetadataInput {\n  /** Skill name (1-64 chars, lowercase letters/numbers/hyphens only, must match directory name) */\n  name: string;\n  /** Description of what the skill does and when to use it (1-1024 characters) */\n  description: string;\n  /** License for the skill (e.g., \"Apache-2.0\", \"MIT\") */\n  license?: string;\n  /** Environment requirements or compatibility notes (string or object for flexibility) */\n  compatibility?: unknown;\n  /** Arbitrary key-value metadata - values can be strings, arrays, objects, etc. */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Skill metadata output type (after validation)\n */\nexport type SkillMetadataOutput = SkillMetadataInput;\n\n/**\n * Validation result with warnings\n */\nexport interface SkillValidationResult {\n  valid: boolean;\n  errors: string[];\n  warnings: string[];\n}\n\n// =============================================================================\n// Field Validators\n// =============================================================================\n\n/**\n * Validate skill name according to spec:\n * - 1-64 characters\n * - Lowercase letters, numbers, hyphens only\n * - Must not start or end with hyphen\n * - Must not contain consecutive hyphens\n *\n * @param name - The name to validate\n * @returns Array of error messages (empty if valid)\n */\nfunction validateSkillName(name: unknown): string[] {\n  const errors: string[] = [];\n  const fieldPath = 'name';\n\n  // Check type\n  if (typeof name !== 'string') {\n    errors.push(`${fieldPath}: Expected string, received ${typeof name}`);\n    return errors;\n  }\n\n  // Check not empty\n  if (name.length === 0) {\n    errors.push(`${fieldPath}: Skill name cannot be empty`);\n    return errors;\n  }\n\n  // Check max length\n  if (name.length > SKILL_LIMITS.MAX_NAME_LENGTH) {\n    errors.push(`${fieldPath}: Skill name must be ${SKILL_LIMITS.MAX_NAME_LENGTH} characters or less`);\n  }\n\n  // Check allowed characters (lowercase letters, numbers, hyphens only)\n  if (!/^[a-z0-9-]+$/.test(name)) {\n    errors.push(`${fieldPath}: Skill name must contain only lowercase letters, numbers, and hyphens`);\n  }\n\n  // Check not starting or ending with hyphen\n  if (name.startsWith('-') || name.endsWith('-')) {\n    errors.push(`${fieldPath}: Skill name must not start or end with a hyphen`);\n  }\n\n  // Check no consecutive hyphens\n  if (name.includes('--')) {\n    errors.push(`${fieldPath}: Skill name must not contain consecutive hyphens`);\n  }\n\n  return errors;\n}\n\n/**\n * Validate skill description according to spec:\n * - 1-1024 characters\n * - Cannot be empty or only whitespace\n *\n * @param description - The description to validate\n * @returns Array of error messages (empty if valid)\n */\nfunction validateSkillDescription(description: unknown): string[] {\n  const errors: string[] = [];\n  const fieldPath = 'description';\n\n  // Check type\n  if (typeof description !== 'string') {\n    errors.push(`${fieldPath}: Expected string, received ${typeof description}`);\n    return errors;\n  }\n\n  // Check not empty\n  if (description.length === 0) {\n    errors.push(`${fieldPath}: Skill description cannot be empty`);\n    return errors;\n  }\n\n  // Check max length\n  if (description.length > SKILL_LIMITS.MAX_DESCRIPTION_LENGTH) {\n    errors.push(`${fieldPath}: Skill description must be ${SKILL_LIMITS.MAX_DESCRIPTION_LENGTH} characters or less`);\n  }\n\n  // Check not only whitespace\n  if (description.trim().length === 0) {\n    errors.push(`${fieldPath}: Skill description cannot be only whitespace`);\n  }\n\n  return errors;\n}\n\n/**\n * Validate skill license (optional string).\n *\n * @param license - The license to validate\n * @returns Array of error messages (empty if valid)\n */\nfunction validateSkillLicense(license: unknown): string[] {\n  const errors: string[] = [];\n  const fieldPath = 'license';\n\n  // Optional field - undefined/null is valid\n  if (license === undefined || license === null) {\n    return errors;\n  }\n\n  // If provided, must be string\n  if (typeof license !== 'string') {\n    errors.push(`${fieldPath}: Expected string, received ${typeof license}`);\n  }\n\n  return errors;\n}\n\n/**\n * Validate skill compatibility notes (optional).\n * Accepts string or any JSON-serializable value for flexibility with external skills.\n *\n * @param compatibility - The compatibility value to validate\n * @returns Array of error messages (empty if valid)\n */\nfunction validateSkillCompatibility(_compatibility: unknown): string[] {\n  // Optional field - any value is allowed (string, object, array, etc.)\n  // External skills don't always follow the spec strictly\n  return [];\n}\n\n/**\n * Validate skill metadata field (optional Record<string, unknown>).\n * Accepts any values (not just strings) for flexibility with external skills.\n *\n * @param metadata - The metadata object to validate\n * @returns Array of error messages (empty if valid)\n */\nfunction validateSkillMetadataField(metadata: unknown): string[] {\n  const errors: string[] = [];\n  const fieldPath = 'metadata';\n\n  // Optional field - undefined/null is valid\n  if (metadata === undefined || metadata === null) {\n    return errors;\n  }\n\n  // If provided, must be object (but values can be anything)\n  if (typeof metadata !== 'object' || Array.isArray(metadata)) {\n    errors.push(`${fieldPath}: Expected object, received ${Array.isArray(metadata) ? 'array' : typeof metadata}`);\n    return errors;\n  }\n\n  // Allow any values - external skills use arrays, objects, etc.\n  return errors;\n}\n\n// =============================================================================\n// Validation Helpers\n// =============================================================================\n\n/**\n * Rough token estimate (words * 1.3)\n * This is a simple heuristic; actual token counts vary by model\n */\nfunction estimateTokens(text: string): number {\n  const words = text.split(/\\s+/).filter(Boolean).length;\n  return Math.ceil(words * 1.3);\n}\n\n/**\n * Count lines in text\n */\nfunction countLines(text: string): number {\n  return text.split('\\n').length;\n}\n\n// =============================================================================\n// Main Validation Function\n// =============================================================================\n\n/**\n * Validate skill metadata with optional content warnings.\n *\n * @param metadata - The skill metadata to validate\n * @param dirName - The directory name (must match skill name)\n * @param instructions - Optional instructions content for token/line warnings\n * @returns Validation result with errors and warnings\n *\n * @example\n * ```typescript\n * const result = validateSkillMetadata(\n *   { name: 'my-skill', description: 'A helpful skill' },\n *   'my-skill',\n *   '# Instructions\\n...'\n * );\n *\n * if (!result.valid) {\n *   console.error('Validation errors:', result.errors);\n * }\n * if (result.warnings.length > 0) {\n *   console.warn('Warnings:', result.warnings);\n * }\n * ```\n */\nexport function validateSkillMetadata(\n  metadata: unknown,\n  dirName?: string,\n  instructions?: string,\n): SkillValidationResult {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n\n  // Check that metadata is an object\n  if (typeof metadata !== 'object' || metadata === null || Array.isArray(metadata)) {\n    errors.push(\n      `Expected object, received ${metadata === null ? 'null' : Array.isArray(metadata) ? 'array' : typeof metadata}`,\n    );\n    return { valid: false, errors, warnings };\n  }\n\n  const data = metadata as Record<string, unknown>;\n\n  // Validate each field\n  errors.push(...validateSkillName(data.name));\n  errors.push(...validateSkillDescription(data.description));\n  errors.push(...validateSkillLicense(data.license));\n  errors.push(...validateSkillCompatibility(data.compatibility));\n  errors.push(...validateSkillMetadataField(data.metadata));\n\n  // Check directory name match (only if no name errors and name is valid)\n  if (dirName && typeof data.name === 'string' && data.name !== dirName) {\n    errors.push(`Skill name \"${data.name}\" must match directory name \"${dirName}\"`);\n  }\n\n  // Check instruction limits (warnings only)\n  if (instructions) {\n    const lineCount = countLines(instructions);\n    const tokenEstimate = estimateTokens(instructions);\n\n    if (lineCount > SKILL_LIMITS.MAX_INSTRUCTION_LINES) {\n      warnings.push(\n        `Instructions have ${lineCount} lines (recommended: <${SKILL_LIMITS.MAX_INSTRUCTION_LINES}). Consider moving content to references/.`,\n      );\n    }\n\n    if (tokenEstimate > SKILL_LIMITS.MAX_INSTRUCTION_TOKENS) {\n      warnings.push(\n        `Instructions have ~${tokenEstimate} estimated tokens (recommended: <${SKILL_LIMITS.MAX_INSTRUCTION_TOKENS}). Consider moving content to references/.`,\n      );\n    }\n  }\n\n  return {\n    valid: errors.length === 0,\n    errors,\n    warnings,\n  };\n}\n","/**\n * LocalSkillSource - Read-only skill source backed by local filesystem.\n *\n * Uses Node.js fs/promises to read skills directly from disk.\n * This allows skills to be loaded without requiring a full WorkspaceFilesystem.\n *\n * @example\n * ```typescript\n * const source = new LocalSkillSource({\n *   basePath: process.cwd(),\n * });\n *\n * // skills paths are relative to basePath\n * const skillsImpl = new WorkspaceSkillsImpl({\n *   source,\n *   skills: ['./skills', './node_modules/@company/skills'],\n * });\n * ```\n */\n\nimport * as fs from 'node:fs/promises';\nimport * as path from 'node:path';\n\nimport { fsExists, fsStat, isTextFile } from '../filesystem';\nimport type { SkillSource, SkillSourceEntry, SkillSourceStat } from './skill-source';\n\n/**\n * Configuration for LocalSkillSource.\n */\nexport interface LocalSkillSourceOptions {\n  /**\n   * Base path for resolving relative skill paths.\n   * Defaults to process.cwd().\n   */\n  basePath?: string;\n}\n\n/**\n * Read-only skill source that loads skills from the local filesystem.\n *\n * Unlike WorkspaceFilesystem, this doesn't provide write operations.\n * Skills loaded from this source are read-only.\n */\nexport class LocalSkillSource implements SkillSource {\n  readonly #basePath: string;\n\n  constructor(options: LocalSkillSourceOptions = {}) {\n    this.#basePath = options.basePath ?? process.cwd();\n  }\n\n  /**\n   * Resolve a path relative to the base path.\n   * Handles both absolute and relative paths.\n   */\n  #resolvePath(skillPath: string): string {\n    if (path.isAbsolute(skillPath)) {\n      return skillPath;\n    }\n    return path.resolve(this.#basePath, skillPath);\n  }\n\n  async exists(skillPath: string): Promise<boolean> {\n    return fsExists(this.#resolvePath(skillPath));\n  }\n\n  async stat(skillPath: string): Promise<SkillSourceStat> {\n    return fsStat(this.#resolvePath(skillPath), skillPath);\n  }\n\n  async readFile(skillPath: string): Promise<string | Buffer> {\n    const resolved = this.#resolvePath(skillPath);\n    const content = await fs.readFile(resolved);\n    // Convert to string for text files\n    if (isTextFile(skillPath)) {\n      return content.toString('utf-8');\n    }\n    return content;\n  }\n\n  async readdir(skillPath: string): Promise<SkillSourceEntry[]> {\n    const resolved = this.#resolvePath(skillPath);\n    const entries = await fs.readdir(resolved, { withFileTypes: true });\n    // Note: Dirent.isDirectory() returns false for symlinks pointing to directories,\n    // so symlinked directories appear as { type: 'file', isSymlink: true }. This is\n    // intentional  #walkForDirectories skips symlinks to prevent cycles, and treating\n    // them as files ensures they're never recursed into by other consumers either.\n    return entries.map(entry => ({\n      name: entry.name,\n      type: entry.isDirectory() ? 'directory' : 'file',\n      isSymlink: entry.isSymbolicLink() || undefined,\n    }));\n  }\n}\n","import type { BlobStore } from '../../storage/domains/blobs/base';\nimport type { SkillVersionTree } from '../../storage/types';\nimport type { SkillSource, SkillSourceEntry, SkillSourceStat } from './skill-source';\n\n/**\n * A SkillSource implementation that reads skill files from a versioned\n * content-addressable blob store, using a SkillVersionTree manifest.\n *\n * This is used by production agents to read from published skill versions\n * rather than the live filesystem. The SkillVersionTree maps file paths\n * to blob hashes, and the BlobStore provides the actual content.\n */\nexport class VersionedSkillSource implements SkillSource {\n  readonly #tree: SkillVersionTree;\n  readonly #blobStore: BlobStore;\n  readonly #versionCreatedAt: Date;\n\n  /** Computed set of directory paths from the tree entries */\n  readonly #directories: Set<string>;\n\n  constructor(tree: SkillVersionTree, blobStore: BlobStore, versionCreatedAt: Date) {\n    this.#tree = tree;\n    this.#blobStore = blobStore;\n    this.#versionCreatedAt = versionCreatedAt;\n    this.#directories = this.#computeDirectories();\n  }\n\n  /**\n   * Compute all directory paths implied by the file tree.\n   * For a file at \"references/api.md\", this adds \"\" (root), \"references\".\n   */\n  #computeDirectories(): Set<string> {\n    const dirs = new Set<string>();\n    dirs.add(''); // root\n    dirs.add('.'); // root alias\n\n    for (const filePath of Object.keys(this.#tree.entries)) {\n      const parts = filePath.split('/');\n      // Add all parent directories\n      for (let i = 1; i < parts.length; i++) {\n        dirs.add(parts.slice(0, i).join('/'));\n      }\n    }\n    return dirs;\n  }\n\n  /**\n   * Normalize a path by stripping leading/trailing slashes and dots.\n   */\n  #normalizePath(path: string): string {\n    let normalized = path.replace(/^[./\\\\]+|[/\\\\]+$/g, '');\n    if (normalized === '') return '';\n    return normalized;\n  }\n\n  async exists(path: string): Promise<boolean> {\n    const normalized = this.#normalizePath(path);\n    // Check if it's a file\n    if (this.#tree.entries[normalized]) return true;\n    // Check if it's a directory\n    return this.#directories.has(normalized);\n  }\n\n  async stat(path: string): Promise<SkillSourceStat> {\n    const normalized = this.#normalizePath(path);\n    const name = normalized.split('/').pop() || normalized || '.';\n\n    // Check if it's a file in the tree\n    const entry = this.#tree.entries[normalized];\n    if (entry) {\n      return {\n        name,\n        type: 'file',\n        size: entry.size,\n        createdAt: this.#versionCreatedAt,\n        modifiedAt: this.#versionCreatedAt,\n        mimeType: entry.mimeType,\n      };\n    }\n\n    // Check if it's a directory\n    if (this.#directories.has(normalized)) {\n      return {\n        name,\n        type: 'directory',\n        size: 0,\n        createdAt: this.#versionCreatedAt,\n        modifiedAt: this.#versionCreatedAt,\n      };\n    }\n\n    throw new Error(`Path not found in skill version tree: ${path}`);\n  }\n\n  async readFile(path: string): Promise<string | Buffer> {\n    const normalized = this.#normalizePath(path);\n    const entry = this.#tree.entries[normalized];\n\n    if (!entry) {\n      throw new Error(`File not found in skill version tree: ${path}`);\n    }\n\n    const blob = await this.#blobStore.get(entry.blobHash);\n    if (!blob) {\n      throw new Error(`Blob not found for hash ${entry.blobHash} (file: ${path})`);\n    }\n\n    // Decode base64-encoded binary content back to Buffer\n    if (entry.encoding === 'base64') {\n      return Buffer.from(blob.content, 'base64');\n    }\n\n    return blob.content;\n  }\n\n  async readdir(path: string): Promise<SkillSourceEntry[]> {\n    const normalized = this.#normalizePath(path);\n\n    if (!this.#directories.has(normalized)) {\n      throw new Error(`Directory not found in skill version tree: ${path}`);\n    }\n\n    const prefix = normalized === '' ? '' : normalized + '/';\n    const seen = new Set<string>();\n    const entries: SkillSourceEntry[] = [];\n\n    for (const filePath of Object.keys(this.#tree.entries)) {\n      if (!filePath.startsWith(prefix)) continue;\n\n      // Get the next segment after the prefix\n      const remaining = filePath.slice(prefix.length);\n      const nextSegment = remaining.split('/')[0];\n      if (!nextSegment || seen.has(nextSegment)) continue;\n      seen.add(nextSegment);\n\n      // If there's more after the next segment, it's a directory\n      const isDirectory = remaining.includes('/');\n      entries.push({\n        name: nextSegment,\n        type: isDirectory ? 'directory' : 'file',\n      });\n    }\n\n    return entries;\n  }\n}\n","import type { BlobStore } from '../../storage/domains/blobs/base';\nimport type { SkillVersionTree } from '../../storage/types';\nimport type { SkillSource, SkillSourceEntry, SkillSourceStat } from './skill-source';\nimport { VersionedSkillSource } from './versioned-skill-source';\n\n/**\n * A skill entry for the composite source.\n * Each entry represents one skill's versioned tree, mounted under a directory name.\n */\nexport interface VersionedSkillEntry {\n  /** Directory name for this skill (used as the subdirectory under the root) */\n  dirName: string;\n  /** The skill version's file tree manifest */\n  tree: SkillVersionTree;\n  /** When this version was created */\n  versionCreatedAt: Date;\n}\n\n/**\n * A SkillSource that composes multiple versioned skill trees into a virtual directory.\n *\n * Each skill is mounted under a directory name, so the composite source looks like:\n *   /                           (root - virtual)\n *   /brand-guidelines/          (skill 1 root)\n *   /brand-guidelines/SKILL.md  (skill 1 files from blob store)\n *   /tone-of-voice/             (skill 2 root)\n *   /tone-of-voice/SKILL.md     (skill 2 files from blob store)\n *\n * This allows WorkspaceSkillsImpl to discover skills normally by scanning the root\n * for subdirectories containing SKILL.md.\n *\n * Can also include a fallback source for \"live\" skills that read from the filesystem.\n */\nexport class CompositeVersionedSkillSource implements SkillSource {\n  readonly #sources: Map<string, VersionedSkillSource> = new Map();\n  readonly #fallback?: SkillSource;\n  readonly #fallbackSkills: Set<string>;\n\n  constructor(\n    entries: VersionedSkillEntry[],\n    blobStore: BlobStore,\n    options?: {\n      /** Fallback source for \"live\" skills that read from the filesystem */\n      fallback?: SkillSource;\n      /** Skill directory names that should be served from the fallback source */\n      fallbackSkills?: string[];\n    },\n  ) {\n    for (const entry of entries) {\n      this.#sources.set(entry.dirName, new VersionedSkillSource(entry.tree, blobStore, entry.versionCreatedAt));\n    }\n    this.#fallback = options?.fallback;\n    this.#fallbackSkills = new Set(options?.fallbackSkills ?? []);\n  }\n\n  #normalizePath(path: string): string {\n    return path.replace(/^[./\\\\]+|[/\\\\]+$/g, '');\n  }\n\n  /**\n   * Route a path to the correct source.\n   * Returns the source and the remaining path within that source.\n   */\n  #routePath(path: string): { source: SkillSource; subPath: string } | null {\n    const normalized = this.#normalizePath(path);\n\n    // Root: handled by this source directly\n    if (normalized === '') return null;\n\n    const segments = normalized.split('/');\n    const skillDir = segments[0]!;\n    const subPath = segments.slice(1).join('/');\n\n    // Check if this skill should use the fallback source\n    if (this.#fallbackSkills.has(skillDir) && this.#fallback) {\n      return { source: this.#fallback, subPath: normalized };\n    }\n\n    // Check if this skill has a versioned source\n    const versionedSource = this.#sources.get(skillDir);\n    if (versionedSource) {\n      return { source: versionedSource, subPath };\n    }\n\n    // Try the fallback for unknown paths\n    if (this.#fallback) {\n      return { source: this.#fallback, subPath: normalized };\n    }\n\n    return null;\n  }\n\n  async exists(path: string): Promise<boolean> {\n    const normalized = this.#normalizePath(path);\n\n    // Root always exists\n    if (normalized === '') return true;\n\n    const route = this.#routePath(path);\n    if (!route) return false;\n\n    return route.source.exists(route.subPath);\n  }\n\n  async stat(path: string): Promise<SkillSourceStat> {\n    const normalized = this.#normalizePath(path);\n\n    // Root directory\n    if (normalized === '') {\n      return {\n        name: '.',\n        type: 'directory',\n        size: 0,\n        createdAt: new Date(),\n        modifiedAt: new Date(),\n      };\n    }\n\n    const route = this.#routePath(path);\n    if (!route) {\n      throw new Error(`Path not found in composite skill source: ${path}`);\n    }\n\n    return route.source.stat(route.subPath);\n  }\n\n  async readFile(path: string): Promise<string | Buffer> {\n    const route = this.#routePath(path);\n    if (!route) {\n      throw new Error(`File not found in composite skill source: ${path}`);\n    }\n\n    return route.source.readFile(route.subPath);\n  }\n\n  async readdir(path: string): Promise<SkillSourceEntry[]> {\n    const normalized = this.#normalizePath(path);\n\n    // Root: list all mounted skill directories\n    if (normalized === '') {\n      const entries: SkillSourceEntry[] = [];\n      const seen = new Set<string>();\n\n      for (const dirName of this.#sources.keys()) {\n        entries.push({ name: dirName, type: 'directory' });\n        seen.add(dirName);\n      }\n\n      // Also list fallback skills\n      for (const dirName of this.#fallbackSkills) {\n        if (!seen.has(dirName)) {\n          entries.push({ name: dirName, type: 'directory' });\n          seen.add(dirName);\n        }\n      }\n\n      return entries;\n    }\n\n    const route = this.#routePath(path);\n    if (!route) {\n      throw new Error(`Directory not found in composite skill source: ${path}`);\n    }\n\n    return route.source.readdir(route.subPath);\n  }\n}\n","/**\n * WorkspaceSkills - Skills implementation.\n *\n * Provides discovery and search operations for skills stored\n * in skills paths. All operations are async.\n */\n\nimport matter from 'gray-matter';\n\nimport { isGlobPattern, extractGlobBase, createGlobMatcher } from '../glob';\nimport type { IndexDocument, SearchResult } from '../search';\nimport { validateSkillMetadata } from './schemas';\nimport type { SkillSource as SkillSourceInterface } from './skill-source';\nimport type {\n  ContentSource,\n  Skill,\n  SkillMetadata,\n  SkillSearchResult,\n  SkillSearchOptions,\n  WorkspaceSkills,\n  SkillsResolver,\n  SkillsContext,\n} from './types';\n\n// =============================================================================\n// Internal Types\n// =============================================================================\n\n/**\n * Minimal search engine interface - only the methods we actually use.\n * This allows both the real SearchEngine and test mocks to be used.\n */\ninterface SkillSearchEngine {\n  index(doc: IndexDocument): Promise<void>;\n  remove?(id: string): Promise<void>;\n  search(\n    query: string,\n    options?: { topK?: number; minScore?: number; mode?: 'bm25' | 'vector' | 'hybrid' },\n  ): Promise<SearchResult[]>;\n  clear(): void;\n}\n\ninterface InternalSkill extends Skill {\n  /** Content for BM25 indexing (instructions + all references) */\n  indexableContent: string;\n}\n\n// =============================================================================\n// WorkspaceSkillsImpl\n// =============================================================================\n\n/**\n * Configuration for WorkspaceSkillsImpl\n */\nexport interface WorkspaceSkillsImplConfig {\n  /**\n   * Source for loading skills.\n   */\n  source: SkillSourceInterface;\n  /**\n   * Paths to scan for skills.\n   * Can be a static array or a function that returns paths based on context.\n   */\n  skills: SkillsResolver;\n  /** Search engine for skill search (optional) */\n  searchEngine?: SkillSearchEngine;\n  /** Validate skills on load (default: true) */\n  validateOnLoad?: boolean;\n}\n\n/**\n * Implementation of WorkspaceSkills interface.\n */\nexport class WorkspaceSkillsImpl implements WorkspaceSkills {\n  readonly #source: SkillSourceInterface;\n  readonly #skillsResolver: SkillsResolver;\n  readonly #searchEngine?: SkillSearchEngine;\n  readonly #validateOnLoad: boolean;\n\n  /** Map of skill name -> full skill data */\n  #skills: Map<string, InternalSkill> = new Map();\n\n  /** Whether skills have been discovered */\n  #initialized = false;\n\n  /** Promise for ongoing initialization (prevents concurrent discovery) */\n  #initPromise: Promise<void> | null = null;\n\n  /** Timestamp of last skills discovery (for staleness check) */\n  #lastDiscoveryTime = 0;\n\n  /** Currently resolved skills paths (used to detect changes) */\n  #resolvedPaths: string[] = [];\n\n  /** Cached glob-resolved directories and per-pattern resolve timestamps */\n  #globDirCache: Map<string, string[]> = new Map();\n  #globResolveTimes: Map<string, number> = new Map();\n  static readonly GLOB_RESOLVE_INTERVAL = 5_000; // Re-walk glob dirs every 5s\n  static readonly STALENESS_CHECK_COOLDOWN = 2_000; // Skip staleness check for 2s after discovery\n\n  constructor(config: WorkspaceSkillsImplConfig) {\n    this.#source = config.source;\n    this.#skillsResolver = config.skills;\n    this.#searchEngine = config.searchEngine;\n    this.#validateOnLoad = config.validateOnLoad ?? true;\n  }\n\n  // ===========================================================================\n  // Discovery\n  // ===========================================================================\n\n  async list(): Promise<SkillMetadata[]> {\n    await this.#ensureInitialized();\n    return Array.from(this.#skills.values()).map(skill => ({\n      name: skill.name,\n      description: skill.description,\n      license: skill.license,\n      compatibility: skill.compatibility,\n      metadata: skill.metadata,\n    }));\n  }\n\n  async get(name: string): Promise<Skill | null> {\n    await this.#ensureInitialized();\n    const skill = this.#skills.get(name);\n    if (!skill) return null;\n\n    // Return without internal indexableContent field\n    const { indexableContent: _, ...skillData } = skill;\n    return skillData;\n  }\n\n  async has(name: string): Promise<boolean> {\n    await this.#ensureInitialized();\n    return this.#skills.has(name);\n  }\n\n  async refresh(): Promise<void> {\n    this.#skills.clear();\n    this.#searchEngine?.clear();\n    this.#initialized = false;\n    this.#initPromise = null;\n    await this.#discoverSkills();\n    this.#initialized = true;\n  }\n\n  async maybeRefresh(context?: SkillsContext): Promise<void> {\n    // Ensure initial discovery is complete\n    await this.#ensureInitialized();\n\n    // Resolve current paths (may be dynamic based on context)\n    const currentPaths = await this.#resolvePaths(context);\n\n    // Check if paths have changed (for dynamic resolvers)\n    const pathsChanged = !this.#arePathsEqual(this.#resolvedPaths, currentPaths);\n    if (pathsChanged) {\n      // Paths changed - need full refresh with new paths\n      this.#resolvedPaths = currentPaths;\n      await this.refresh();\n      return;\n    }\n\n    // Check if any skills path has been modified since last discovery\n    const isStale = await this.#isSkillsPathStale();\n    if (isStale) {\n      await this.refresh();\n    }\n  }\n\n  async addSkill(skillPath: string): Promise<void> {\n    await this.#ensureInitialized();\n\n    // Determine SKILL.md path and dirName\n    let skillFilePath: string;\n    let dirName: string;\n    if (skillPath.endsWith('/SKILL.md') || skillPath === 'SKILL.md') {\n      skillFilePath = skillPath;\n      dirName = this.#getParentPath(skillPath).split('/').pop() || 'unknown';\n    } else {\n      skillFilePath = this.#joinPath(skillPath, 'SKILL.md');\n      dirName = skillPath.split('/').pop() || 'unknown';\n    }\n\n    // Determine source from existing resolved paths\n    const source = this.#inferSource(skillPath);\n\n    // Parse and add to cache\n    const skill = await this.#parseSkillFile(skillFilePath, dirName, source);\n\n    // Remove old index entries if skill already exists (for update case)\n    const existing = this.#skills.get(skill.name);\n    if (existing) {\n      await this.#removeSkillFromIndex(existing);\n    }\n\n    this.#skills.set(skill.name, skill);\n    await this.#indexSkill(skill);\n\n    // Update discovery time so maybeRefresh() doesn't trigger full scan\n    this.#lastDiscoveryTime = Date.now();\n  }\n\n  async removeSkill(skillName: string): Promise<void> {\n    await this.#ensureInitialized();\n\n    const skill = this.#skills.get(skillName);\n    if (!skill) return;\n\n    // Remove from search index\n    await this.#removeSkillFromIndex(skill);\n\n    // Remove from cache\n    this.#skills.delete(skillName);\n\n    // Update discovery time so maybeRefresh() doesn't trigger full scan\n    this.#lastDiscoveryTime = Date.now();\n  }\n\n  /**\n   * Resolve skills paths from the resolver (static array or function).\n   */\n  async #resolvePaths(context?: SkillsContext): Promise<string[]> {\n    if (Array.isArray(this.#skillsResolver)) {\n      return this.#skillsResolver;\n    }\n    return this.#skillsResolver(context ?? {});\n  }\n\n  /**\n   * Compare two path arrays for equality (order-independent).\n   */\n  #arePathsEqual(a: string[], b: string[]): boolean {\n    if (a.length !== b.length) return false;\n    const sortedA = [...a].sort();\n    const sortedB = [...b].sort();\n    return sortedA.every((path, i) => path === sortedB[i]);\n  }\n\n  // ===========================================================================\n  // Search\n  // ===========================================================================\n\n  async search(query: string, options: SkillSearchOptions = {}): Promise<SkillSearchResult[]> {\n    await this.#ensureInitialized();\n\n    if (!this.#searchEngine) {\n      // Fall back to simple text matching if no search engine\n      return this.#simpleSearch(query, options);\n    }\n\n    const { topK = 5, minScore, skillNames, includeReferences = true, mode } = options;\n\n    // Get more results than needed to filter by skillNames/includeReferences\n    const expandedTopK = skillNames ? topK * 3 : topK;\n\n    // Delegate to SearchEngine\n    const searchResults = await this.#searchEngine.search(query, {\n      topK: expandedTopK,\n      minScore,\n      mode,\n    });\n\n    const results: SkillSearchResult[] = [];\n\n    for (const result of searchResults) {\n      const skillName = result.metadata?.skillName as string;\n      const source = result.metadata?.source as string;\n\n      if (!skillName || !source) continue;\n\n      // Filter by skill names if specified\n      if (skillNames && !skillNames.includes(skillName)) {\n        continue;\n      }\n\n      // Filter out references if not included\n      if (!includeReferences && source !== 'SKILL.md') {\n        continue;\n      }\n\n      results.push({\n        skillName,\n        source,\n        content: result.content,\n        score: result.score,\n        lineRange: result.lineRange,\n        scoreDetails: result.scoreDetails,\n      });\n\n      if (results.length >= topK) break;\n    }\n\n    return results;\n  }\n\n  // ===========================================================================\n  // Single-item Accessors\n  // ===========================================================================\n\n  async getReference(skillName: string, referencePath: string): Promise<string | null> {\n    await this.#ensureInitialized();\n\n    const skill = this.#skills.get(skillName);\n    if (!skill) return null;\n\n    const safeRefPath = this.#assertRelativePath(referencePath, 'reference');\n    const refFilePath = this.#joinPath(skill.path, safeRefPath);\n\n    if (!(await this.#source.exists(refFilePath))) {\n      return null;\n    }\n\n    try {\n      const content = await this.#source.readFile(refFilePath);\n      return typeof content === 'string' ? content : content.toString('utf-8');\n    } catch {\n      return null;\n    }\n  }\n\n  async getScript(skillName: string, scriptPath: string): Promise<string | null> {\n    await this.#ensureInitialized();\n\n    const skill = this.#skills.get(skillName);\n    if (!skill) return null;\n\n    const safeScriptPath = this.#assertRelativePath(scriptPath, 'script');\n    const scriptFilePath = this.#joinPath(skill.path, safeScriptPath);\n\n    if (!(await this.#source.exists(scriptFilePath))) {\n      return null;\n    }\n\n    try {\n      const content = await this.#source.readFile(scriptFilePath);\n      return typeof content === 'string' ? content : content.toString('utf-8');\n    } catch {\n      return null;\n    }\n  }\n\n  async getAsset(skillName: string, assetPath: string): Promise<Buffer | null> {\n    await this.#ensureInitialized();\n\n    const skill = this.#skills.get(skillName);\n    if (!skill) return null;\n\n    const safeAssetPath = this.#assertRelativePath(assetPath, 'asset');\n    const assetFilePath = this.#joinPath(skill.path, safeAssetPath);\n\n    if (!(await this.#source.exists(assetFilePath))) {\n      return null;\n    }\n\n    try {\n      const content = await this.#source.readFile(assetFilePath);\n      return typeof content === 'string' ? Buffer.from(content, 'utf-8') : content;\n    } catch {\n      return null;\n    }\n  }\n\n  // ===========================================================================\n  // Listing Accessors\n  // ===========================================================================\n\n  async listReferences(skillName: string): Promise<string[]> {\n    await this.#ensureInitialized();\n    const skill = this.#skills.get(skillName);\n    return skill?.references ?? [];\n  }\n\n  async listScripts(skillName: string): Promise<string[]> {\n    await this.#ensureInitialized();\n    const skill = this.#skills.get(skillName);\n    return skill?.scripts ?? [];\n  }\n\n  async listAssets(skillName: string): Promise<string[]> {\n    await this.#ensureInitialized();\n    const skill = this.#skills.get(skillName);\n    return skill?.assets ?? [];\n  }\n\n  // ===========================================================================\n  // Private Methods\n  // ===========================================================================\n\n  /**\n   * Ensure skills have been discovered.\n   * Uses a promise to prevent concurrent discovery.\n   */\n  async #ensureInitialized(): Promise<void> {\n    if (this.#initialized) {\n      return;\n    }\n\n    // If initialization is already in progress, wait for it\n    if (this.#initPromise) {\n      await this.#initPromise;\n      return;\n    }\n\n    // Start initialization and store the promise\n    this.#initPromise = (async () => {\n      try {\n        // Resolve paths on first initialization (uses empty context)\n        if (this.#resolvedPaths.length === 0) {\n          this.#resolvedPaths = await this.#resolvePaths();\n        }\n        await this.#discoverSkills();\n        this.#initialized = true;\n      } finally {\n        this.#initPromise = null;\n      }\n    })();\n\n    await this.#initPromise;\n  }\n\n  /**\n   * Discover skills from all skills paths.\n   * Uses currently resolved paths (must be set before calling).\n   *\n   * Paths can be plain directories (e.g., '/skills') or glob patterns\n   * (e.g., '**\\/skills'). Glob patterns resolve to directories that match\n   * the pattern, each of which is then scanned for skills.\n   */\n  async #discoverSkills(): Promise<void> {\n    // Clear glob cache so discovery gets fresh results\n    this.#globDirCache.clear();\n    this.#globResolveTimes.clear();\n\n    for (const skillsPath of this.#resolvedPaths) {\n      const source = this.#determineSource(skillsPath);\n\n      if (isGlobPattern(skillsPath)) {\n        // Glob pattern: resolve to matching directories, then discover in each\n        const matchingDirs = await this.#resolveGlobToDirectories(skillsPath);\n        // Cache for subsequent staleness checks\n        this.#globDirCache.set(skillsPath, matchingDirs);\n        this.#globResolveTimes.set(skillsPath, Date.now());\n        for (const dir of matchingDirs) {\n          await this.#discoverSkillsInPath(dir, source);\n        }\n      } else {\n        // Check if the path is a direct skill reference (directory with SKILL.md or SKILL.md file)\n        const isDirect = await this.#discoverDirectSkill(skillsPath, source);\n        if (!isDirect) {\n          // Plain path: scan subdirectories for skills\n          await this.#discoverSkillsInPath(skillsPath, source);\n        }\n      }\n    }\n    // Track when discovery completed for staleness check\n    this.#lastDiscoveryTime = Date.now();\n  }\n\n  /**\n   * Resolve a glob pattern to a list of matching directories.\n   * Walks from extractGlobBase() and tests each directory against the pattern.\n   *\n   * Note: Broad patterns like `/** /skills` resolve to a walk root of `/`,\n   * scanning the entire workspace tree. This is cached per-pattern with a\n   * TTL (GLOB_RESOLVE_INTERVAL) to limit I/O. For large workspaces, prefer\n   * more specific patterns like `/src/** /skills` to narrow the walk root.\n   */\n  async #resolveGlobToDirectories(pattern: string): Promise<string[]> {\n    const walkRoot = extractGlobBase(pattern);\n    const matcher = createGlobMatcher(pattern, { dot: true });\n    const matchingDirs: string[] = [];\n\n    await this.#walkForDirectories(walkRoot, dirPath => {\n      if (matcher(dirPath)) {\n        matchingDirs.push(dirPath);\n      }\n    });\n\n    return matchingDirs;\n  }\n\n  /**\n   * Walk a directory tree and call callback for each directory found.\n   */\n  async #walkForDirectories(\n    basePath: string,\n    callback: (dirPath: string) => void,\n    depth: number = 0,\n    maxDepth: number = 4,\n  ): Promise<void> {\n    if (depth >= maxDepth) return;\n\n    try {\n      const entries = await this.#source.readdir(basePath);\n      for (const entry of entries) {\n        // Skip symlink directories to prevent infinite recursion from cycles\n        if (entry.type !== 'directory' || entry.isSymlink) continue;\n        // Use explicit path construction to handle root '/' correctly\n        // (#joinPath strips root '/', so we handle it directly)\n        const entryPath = basePath === '/' ? `/${entry.name}` : `${basePath}/${entry.name}`;\n        callback(entryPath);\n        await this.#walkForDirectories(entryPath, callback, depth + 1, maxDepth);\n      }\n    } catch {\n      // Directory doesn't exist or can't be read, skip\n    }\n  }\n\n  /**\n   * Discover skills in a single path\n   */\n  async #discoverSkillsInPath(skillsPath: string, source: ContentSource): Promise<void> {\n    try {\n      if (!(await this.#source.exists(skillsPath))) {\n        return;\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        console.warn(`[WorkspaceSkills] Cannot access skills path \"${skillsPath}\": ${error.message}`);\n      } else {\n        console.warn(`[WorkspaceSkills] Cannot access skills path \"${skillsPath}\": ${String(error)}`);\n      }\n      return;\n    }\n\n    try {\n      const entries = await this.#source.readdir(skillsPath);\n\n      for (const entry of entries) {\n        if (entry.type !== 'directory') continue;\n\n        const entryPath = this.#joinPath(skillsPath, entry.name);\n        const skillFilePath = this.#joinPath(entryPath, 'SKILL.md');\n\n        if (await this.#source.exists(skillFilePath)) {\n          try {\n            const skill = await this.#parseSkillFile(skillFilePath, entry.name, source);\n\n            // Set skill (later discoveries overwrite earlier ones)\n            this.#skills.set(skill.name, skill);\n\n            // Index the skill content for search\n            await this.#indexSkill(skill);\n          } catch (error) {\n            if (error instanceof Error) {\n              console.error(`[WorkspaceSkills] Failed to load skill from ${skillFilePath}:`, error.message);\n            }\n          }\n        }\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        console.error(`[WorkspaceSkills] Failed to scan skills directory ${skillsPath}:`, error.message);\n      }\n    }\n  }\n\n  /**\n   * Attempt to discover a skill from a direct path reference.\n   *\n   * Handles two cases:\n   * - Path ends with `/SKILL.md`  parse directly, extract dirName from parent\n   * - Path is a directory containing `SKILL.md`  parse it as a single skill\n   *\n   * Returns `true` if the path was a direct skill reference (skip subdirectory scan),\n   * `false` to fall through to the normal subdirectory scan.\n   */\n  async #discoverDirectSkill(skillsPath: string, source: ContentSource): Promise<boolean> {\n    try {\n      // Case 1: Path points directly to a SKILL.md file\n      if (skillsPath.endsWith('/SKILL.md') || skillsPath === 'SKILL.md') {\n        if (!(await this.#source.exists(skillsPath))) {\n          return true; // It was a direct reference, just doesn't exist  skip subdirectory scan\n        }\n\n        const skillDir = this.#getParentPath(skillsPath);\n        const dirName = skillDir.split('/').pop() || skillDir;\n\n        try {\n          const skill = await this.#parseSkillFile(skillsPath, dirName, source);\n          this.#skills.set(skill.name, skill);\n          await this.#indexSkill(skill);\n        } catch (error) {\n          if (error instanceof Error) {\n            console.error(`[WorkspaceSkills] Failed to load skill from ${skillsPath}:`, error.message);\n          }\n        }\n        return true;\n      }\n\n      // Case 2: Path is a directory that directly contains SKILL.md\n      if (await this.#source.exists(skillsPath)) {\n        const skillFilePath = this.#joinPath(skillsPath, 'SKILL.md');\n        if (await this.#source.exists(skillFilePath)) {\n          const dirName = skillsPath.split('/').pop() || skillsPath;\n\n          try {\n            const skill = await this.#parseSkillFile(skillFilePath, dirName, source);\n            this.#skills.set(skill.name, skill);\n            await this.#indexSkill(skill);\n          } catch (error) {\n            if (error instanceof Error) {\n              console.error(`[WorkspaceSkills] Failed to load skill from ${skillFilePath}:`, error.message);\n            }\n          }\n          return true;\n        }\n      }\n\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if any skills path directory has been modified since last discovery.\n   * Compares directory mtime to lastDiscoveryTime.\n   * For glob patterns, checks the walk root and expanded directories.\n   */\n  async #isSkillsPathStale(): Promise<boolean> {\n    if (this.#lastDiscoveryTime === 0) {\n      // Never discovered, consider stale\n      return true;\n    }\n\n    // Skip the expensive stat calls if discovery happened very recently\n    // (e.g., right after a surgical addSkill/removeSkill). This avoids\n    // a timing race where the filesystem write updates directory mtime\n    // to the same second as #lastDiscoveryTime, and also avoids slow\n    // stat calls to external mounts immediately after a known-good update.\n    if (Date.now() - this.#lastDiscoveryTime < WorkspaceSkillsImpl.STALENESS_CHECK_COOLDOWN) {\n      return false;\n    }\n\n    for (const skillsPath of this.#resolvedPaths) {\n      let pathsToCheck: string[];\n\n      if (isGlobPattern(skillsPath)) {\n        // Use cached glob dirs, re-resolve periodically to discover new directories\n        const now = Date.now();\n        const lastResolved = this.#globResolveTimes.get(skillsPath) ?? 0;\n        if (now - lastResolved > WorkspaceSkillsImpl.GLOB_RESOLVE_INTERVAL || !this.#globDirCache.has(skillsPath)) {\n          const dirs = await this.#resolveGlobToDirectories(skillsPath);\n          this.#globDirCache.set(skillsPath, dirs);\n          this.#globResolveTimes.set(skillsPath, now);\n        }\n        pathsToCheck = this.#globDirCache.get(skillsPath) ?? [];\n      } else {\n        pathsToCheck = [skillsPath];\n      }\n\n      for (const pathToCheck of pathsToCheck) {\n        try {\n          const stat = await this.#source.stat(pathToCheck);\n          const mtime = stat.modifiedAt.getTime();\n\n          if (mtime > this.#lastDiscoveryTime) {\n            return true;\n          }\n\n          // Skip subdirectory scan for non-directory paths (direct skill references)\n          if (stat.type !== 'directory') {\n            continue;\n          }\n\n          // Also check subdirectories (skill directories) for changes\n          const entries = await this.#source.readdir(pathToCheck);\n          for (const entry of entries) {\n            if (entry.type !== 'directory') continue;\n\n            const entryPath = this.#joinPath(pathToCheck, entry.name);\n            try {\n              const entryStat = await this.#source.stat(entryPath);\n              if (entryStat.modifiedAt.getTime() > this.#lastDiscoveryTime) {\n                return true;\n              }\n            } catch {\n              // Couldn't stat entry, skip it\n            }\n          }\n        } catch {\n          // Couldn't stat path (doesn't exist or error), skip to next\n          continue;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Parse a SKILL.md file\n   */\n  async #parseSkillFile(filePath: string, dirName: string, source: ContentSource): Promise<InternalSkill> {\n    const rawContent = await this.#source.readFile(filePath);\n    const content = typeof rawContent === 'string' ? rawContent : rawContent.toString('utf-8');\n\n    const parsed = matter(content);\n    const frontmatter = parsed.data;\n    const body = parsed.content.trim();\n\n    // Extract required fields\n    const metadata: SkillMetadata = {\n      name: frontmatter.name,\n      description: frontmatter.description,\n      license: frontmatter.license,\n      compatibility: frontmatter.compatibility,\n      metadata: frontmatter.metadata,\n    };\n\n    // Validate if enabled (includes token/line count warnings)\n    if (this.#validateOnLoad) {\n      const validation = this.#validateSkillMetadata(metadata, dirName, body);\n      if (!validation.valid) {\n        throw new Error(`Invalid skill metadata in ${filePath}:\\n${validation.errors.join('\\n')}`);\n      }\n    }\n\n    // Get skill directory path (parent of SKILL.md)\n    const skillPath = this.#getParentPath(filePath);\n\n    // Discover reference, script, and asset files\n    const references = await this.#discoverFilesInSubdir(skillPath, 'references');\n    const scripts = await this.#discoverFilesInSubdir(skillPath, 'scripts');\n    const assets = await this.#discoverFilesInSubdir(skillPath, 'assets');\n\n    // Build indexable content (instructions + references)\n    const indexableContent = await this.#buildIndexableContent(body, skillPath, references);\n\n    return {\n      ...metadata,\n      path: skillPath,\n      instructions: body,\n      source,\n      references,\n      scripts,\n      assets,\n      indexableContent,\n    };\n  }\n\n  /**\n   * Validate skill metadata (delegates to shared validation function)\n   */\n  #validateSkillMetadata(\n    metadata: SkillMetadata,\n    dirName: string,\n    instructions?: string,\n  ): { valid: boolean; errors: string[]; warnings: string[] } {\n    const result = validateSkillMetadata(metadata, dirName, instructions);\n\n    // Log warnings if any\n    if (result.warnings.length > 0) {\n      for (const warning of result.warnings) {\n        console.warn(`[WorkspaceSkills] ${metadata.name}: ${warning}`);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Discover files in a subdirectory of a skill (references/, scripts/, assets/)\n   */\n  async #discoverFilesInSubdir(skillPath: string, subdir: 'references' | 'scripts' | 'assets'): Promise<string[]> {\n    const subdirPath = this.#joinPath(skillPath, subdir);\n    const files: string[] = [];\n\n    if (!(await this.#source.exists(subdirPath))) {\n      return files;\n    }\n\n    try {\n      await this.#walkDirectory(subdirPath, subdirPath, (relativePath: string) => {\n        files.push(relativePath);\n      });\n    } catch {\n      // Failed to read subdirectory\n    }\n\n    return files;\n  }\n\n  /**\n   * Walk a directory recursively and call callback for each file.\n   * Limited to maxDepth (default 20) to prevent stack overflow on deep hierarchies.\n   */\n  async #walkDirectory(\n    basePath: string,\n    dirPath: string,\n    callback: (relativePath: string) => void,\n    depth: number = 0,\n    maxDepth: number = 20,\n  ): Promise<void> {\n    if (depth >= maxDepth) {\n      return;\n    }\n\n    const entries = await this.#source.readdir(dirPath);\n\n    for (const entry of entries) {\n      const entryPath = this.#joinPath(dirPath, entry.name);\n\n      if (entry.type === 'directory' && !entry.isSymlink) {\n        await this.#walkDirectory(basePath, entryPath, callback, depth + 1, maxDepth);\n      } else {\n        // Get relative path from base\n        const relativePath = entryPath.substring(basePath.length + 1);\n        callback(relativePath);\n      }\n    }\n  }\n\n  /**\n   * Build indexable content from instructions and references\n   */\n  async #buildIndexableContent(instructions: string, skillPath: string, references: string[]): Promise<string> {\n    const parts = [instructions];\n\n    for (const refPath of references) {\n      const fullPath = this.#joinPath(skillPath, 'references', refPath);\n      try {\n        const rawContent = await this.#source.readFile(fullPath);\n        const content = typeof rawContent === 'string' ? rawContent : rawContent.toString('utf-8');\n        parts.push(content);\n      } catch {\n        // Skip files that can't be read\n      }\n    }\n\n    return parts.join('\\n\\n');\n  }\n\n  /**\n   * Remove a skill's entries from the search index.\n   */\n  async #removeSkillFromIndex(skill: InternalSkill): Promise<void> {\n    if (!this.#searchEngine?.remove) return;\n\n    const ids = [`skill:${skill.name}:SKILL.md`, ...skill.references.map(r => `skill:${skill.name}:${r}`)];\n    for (const id of ids) {\n      try {\n        await this.#searchEngine.remove(id);\n      } catch {\n        // Best-effort removal; entry may already be gone\n      }\n    }\n  }\n\n  /**\n   * Infer the ContentSource for a skill path by matching against resolved paths.\n   */\n  #inferSource(skillPath: string): ContentSource {\n    for (const rp of this.#resolvedPaths) {\n      if (skillPath === rp || skillPath.startsWith(rp + '/')) {\n        return this.#determineSource(rp);\n      }\n    }\n    return this.#determineSource(skillPath);\n  }\n\n  /**\n   * Index a skill for search\n   */\n  async #indexSkill(skill: InternalSkill): Promise<void> {\n    if (!this.#searchEngine) return;\n\n    // Index the main skill instructions\n    await this.#searchEngine.index({\n      id: `skill:${skill.name}:SKILL.md`,\n      content: skill.instructions,\n      metadata: {\n        skillName: skill.name,\n        source: 'SKILL.md',\n      },\n    });\n\n    // Index each reference file separately\n    for (const refPath of skill.references) {\n      const fullPath = this.#joinPath(skill.path, 'references', refPath);\n      try {\n        const rawContent = await this.#source.readFile(fullPath);\n        const content = typeof rawContent === 'string' ? rawContent : rawContent.toString('utf-8');\n        await this.#searchEngine.index({\n          id: `skill:${skill.name}:${refPath}`,\n          content,\n          metadata: {\n            skillName: skill.name,\n            source: `references/${refPath}`,\n          },\n        });\n      } catch {\n        // Skip files that can't be read\n      }\n    }\n  }\n\n  /**\n   * Simple text search fallback when no search engine is configured\n   */\n  async #simpleSearch(query: string, options: SkillSearchOptions): Promise<SkillSearchResult[]> {\n    const { topK = 5, skillNames, includeReferences = true } = options;\n    const queryLower = query.toLowerCase();\n    const results: SkillSearchResult[] = [];\n\n    for (const skill of this.#skills.values()) {\n      // Filter by skill names if specified\n      if (skillNames && !skillNames.includes(skill.name)) {\n        continue;\n      }\n\n      // Search in instructions\n      if (skill.instructions.toLowerCase().includes(queryLower)) {\n        results.push({\n          skillName: skill.name,\n          source: 'SKILL.md',\n          content: skill.instructions.substring(0, 200),\n          score: 1,\n        });\n      }\n\n      // Search in references if included\n      if (includeReferences) {\n        for (const refPath of skill.references) {\n          if (results.length >= topK) break;\n          const content = await this.getReference(skill.name, `references/${refPath}`);\n          if (content && content.toLowerCase().includes(queryLower)) {\n            results.push({\n              skillName: skill.name,\n              source: `references/${refPath}`,\n              content: content.substring(0, 200),\n              score: 0.8,\n            });\n          }\n        }\n      }\n\n      if (results.length >= topK) break;\n    }\n\n    return results.slice(0, topK);\n  }\n\n  /**\n   * Determine the source type based on the path\n   */\n  #determineSource(skillsPath: string): ContentSource {\n    // Use path segment matching to avoid false positives (e.g., my-node_modules)\n    const segments = skillsPath.split('/');\n    if (segments.includes('node_modules')) {\n      return { type: 'external', packagePath: skillsPath };\n    }\n    if (skillsPath.includes('/.mastra/skills') || skillsPath.startsWith('.mastra/skills')) {\n      return { type: 'managed', mastraPath: skillsPath };\n    }\n    return { type: 'local', projectPath: skillsPath };\n  }\n\n  /**\n   * Join path segments (workspace paths use forward slashes)\n   */\n  #joinPath(...segments: string[]): string {\n    return segments\n      .map((seg, i) => {\n        if (i === 0) return seg.replace(/\\/+$/, '');\n        return seg.replace(/^\\/+|\\/+$/g, '');\n      })\n      .filter(Boolean)\n      .join('/');\n  }\n\n  /**\n   * Validate and normalize a relative path to prevent directory traversal.\n   * Throws if the path contains traversal segments (..) or is absolute.\n   */\n  #assertRelativePath(input: string, label: string): string {\n    const normalized = input.replace(/\\\\/g, '/');\n    const segments = normalized.split('/').filter(seg => Boolean(seg) && seg !== '.');\n    if (normalized.startsWith('/') || segments.some(seg => seg === '..')) {\n      throw new Error(`Invalid ${label} path: ${input}`);\n    }\n    return segments.join('/');\n  }\n\n  /**\n   * Get parent path\n   */\n  #getParentPath(path: string): string {\n    const lastSlash = path.lastIndexOf('/');\n    return lastSlash > 0 ? path.substring(0, lastSlash) : '/';\n  }\n}\n","import { createHash } from 'node:crypto';\nimport matter from 'gray-matter';\nimport type { BlobStore } from '../../storage/domains/blobs/base';\nimport type {\n  SkillVersionTree,\n  SkillVersionTreeEntry,\n  StorageBlobEntry,\n  StorageSkillSnapshotType,\n} from '../../storage/types';\nimport type { SkillSource, SkillSourceEntry } from './skill-source';\n\n/**\n * Result of collecting a skill's filesystem tree.\n * Contains the tree manifest, the blob entries to store, and parsed SKILL.md fields.\n */\nexport interface SkillPublishResult {\n  /** Denormalized snapshot fields parsed from SKILL.md frontmatter */\n  snapshot: Omit<StorageSkillSnapshotType, 'tree'>;\n  /** Content-addressable file tree manifest */\n  tree: SkillVersionTree;\n  /** Blob entries to store (already deduplicated by hash) */\n  blobs: StorageBlobEntry[];\n}\n\n// =============================================================================\n// Internal Helpers\n// =============================================================================\n\n/**\n * Compute SHA-256 hex hash of content (string or Buffer).\n */\nfunction hashContent(content: string | Buffer): string {\n  if (Buffer.isBuffer(content)) {\n    return createHash('sha256').update(content).digest('hex');\n  }\n  return createHash('sha256').update(content, 'utf-8').digest('hex');\n}\n\n/**\n * Simple extension-based MIME type detection.\n */\nfunction detectMimeType(filename: string): string | undefined {\n  const ext = filename.slice(filename.lastIndexOf('.')).toLowerCase();\n  const mimeTypes: Record<string, string> = {\n    '.md': 'text/markdown',\n    '.txt': 'text/plain',\n    '.json': 'application/json',\n    '.yaml': 'text/yaml',\n    '.yml': 'text/yaml',\n    '.sh': 'text/x-shellscript',\n    '.py': 'text/x-python',\n    '.js': 'text/javascript',\n    '.ts': 'text/typescript',\n    '.html': 'text/html',\n    '.css': 'text/css',\n    '.png': 'image/png',\n    '.jpg': 'image/jpeg',\n    '.jpeg': 'image/jpeg',\n    '.svg': 'image/svg+xml',\n  };\n  return mimeTypes[ext];\n}\n\n/**\n * Whether a MIME type represents binary content that cannot be safely stored as UTF-8 text.\n */\nfunction isBinaryMimeType(mimeType: string | undefined): boolean {\n  if (!mimeType) return false;\n  // Text-based types are safe for UTF-8\n  if (mimeType.startsWith('text/')) return false;\n  // JSON and YAML are text-safe\n  if (mimeType === 'application/json') return false;\n  // SVG is XML-based text\n  if (mimeType === 'image/svg+xml') return false;\n  // Everything else (image/png, image/jpeg, application/octet-stream, etc.) is binary\n  return true;\n}\n\ninterface WalkedFile {\n  path: string;\n  /** Text content (UTF-8) or raw binary content (Buffer) */\n  content: string | Buffer;\n  /** Whether this file is binary */\n  isBinary: boolean;\n}\n\n/**\n * Recursively walk a directory in a SkillSource, returning all files\n * with their relative paths and content. Binary files are returned as Buffers.\n */\nasync function walkSkillDirectory(\n  source: SkillSource,\n  basePath: string,\n  currentPath: string = basePath,\n): Promise<WalkedFile[]> {\n  const entries: SkillSourceEntry[] = await source.readdir(currentPath);\n  const files: WalkedFile[] = [];\n\n  for (const entry of entries) {\n    const entryPath = joinPath(currentPath, entry.name);\n\n    if (entry.type === 'directory') {\n      const subFiles = await walkSkillDirectory(source, basePath, entryPath);\n      files.push(...subFiles);\n    } else {\n      const rawContent = await source.readFile(entryPath);\n      const relativePath = entryPath.substring(basePath.length + 1);\n      const mimeType = detectMimeType(entry.name);\n      const isBinary = isBinaryMimeType(mimeType);\n\n      if (isBinary) {\n        // Keep binary content as Buffer\n        const buf = Buffer.isBuffer(rawContent) ? rawContent : Buffer.from(rawContent, 'utf-8');\n        files.push({ path: relativePath, content: buf, isBinary: true });\n      } else {\n        // Text content as string\n        const content = typeof rawContent === 'string' ? rawContent : rawContent.toString('utf-8');\n        files.push({ path: relativePath, content, isBinary: false });\n      }\n    }\n  }\n\n  return files;\n}\n\n/**\n * Join path segments using forward slashes.\n */\nfunction joinPath(...segments: string[]): string {\n  return segments\n    .map((seg, i) => {\n      if (i === 0) return seg.replace(/\\/+$/, '');\n      return seg.replace(/^\\/+|\\/+$/g, '');\n    })\n    .filter(Boolean)\n    .join('/');\n}\n\n/**\n * Collect file paths under a specific subdirectory prefix.\n */\nfunction collectSubdirPaths(allPaths: string[], subdir: string): string[] {\n  const prefix = subdir + '/';\n  return allPaths.filter(p => p.startsWith(prefix)).map(p => p.substring(prefix.length));\n}\n\n// =============================================================================\n// Public API\n// =============================================================================\n\n/**\n * Collect a skill from a SkillSource for publishing.\n * Walks the skill directory, hashes all files, parses SKILL.md frontmatter,\n * and returns everything needed to create a new version.\n *\n * @param source - The SkillSource to read from (live filesystem or any other source)\n * @param skillPath - Path to the skill directory (containing SKILL.md)\n */\nexport async function collectSkillForPublish(source: SkillSource, skillPath: string): Promise<SkillPublishResult> {\n  // 1. Walk the skill directory recursively, reading all files\n  const files = await walkSkillDirectory(source, skillPath);\n\n  // 2. Build tree entries and blob entries, deduplicating blobs by hash\n  const treeEntries: Record<string, SkillVersionTreeEntry> = {};\n  const blobMap = new Map<string, StorageBlobEntry>();\n  const now = new Date();\n\n  for (const file of files) {\n    const hash = hashContent(file.content);\n    const mimeType = detectMimeType(file.path);\n\n    if (file.isBinary) {\n      // Binary file: store as base64-encoded string\n      const buf = Buffer.isBuffer(file.content) ? file.content : Buffer.from(file.content as string);\n      const size = buf.length;\n      const base64Content = buf.toString('base64');\n\n      treeEntries[file.path] = {\n        blobHash: hash,\n        size,\n        mimeType,\n        encoding: 'base64',\n      };\n\n      if (!blobMap.has(hash)) {\n        blobMap.set(hash, {\n          hash,\n          content: base64Content,\n          size,\n          mimeType,\n          createdAt: now,\n        });\n      }\n    } else {\n      // Text file: store as UTF-8 string\n      const content = file.content as string;\n      const size = Buffer.byteLength(content, 'utf-8');\n\n      treeEntries[file.path] = {\n        blobHash: hash,\n        size,\n        mimeType,\n      };\n\n      if (!blobMap.has(hash)) {\n        blobMap.set(hash, {\n          hash,\n          content,\n          size,\n          mimeType,\n          createdAt: now,\n        });\n      }\n    }\n  }\n\n  const tree: SkillVersionTree = { entries: treeEntries };\n  const blobs = Array.from(blobMap.values());\n\n  // 3. Parse SKILL.md with gray-matter for denormalized fields\n  const skillMdFile = files.find(f => f.path === 'SKILL.md');\n  if (!skillMdFile) {\n    throw new Error(`SKILL.md not found in ${skillPath}`);\n  }\n\n  const parsed = matter(skillMdFile.content as string);\n  const frontmatter = parsed.data;\n  const instructions = parsed.content.trim();\n\n  // 4. Discover references/, scripts/, assets/ subdirectories for the path arrays\n  const allPaths = files.map(f => f.path);\n  const references = collectSubdirPaths(allPaths, 'references');\n  const scripts = collectSubdirPaths(allPaths, 'scripts');\n  const assets = collectSubdirPaths(allPaths, 'assets');\n\n  // 5. Build snapshot\n  const snapshot: Omit<StorageSkillSnapshotType, 'tree'> = {\n    name: frontmatter.name,\n    description: frontmatter.description,\n    instructions,\n    license: frontmatter.license,\n    compatibility: frontmatter.compatibility,\n    metadata: frontmatter.metadata,\n    ...(references.length > 0 ? { references } : {}),\n    ...(scripts.length > 0 ? { scripts } : {}),\n    ...(assets.length > 0 ? { assets } : {}),\n  };\n\n  return { snapshot, tree, blobs };\n}\n\n/**\n * Publish a skill: collect files, store blobs, create version.\n * This is the full publish flow.\n *\n * @param source - The SkillSource to read from\n * @param skillPath - Path to the skill directory\n * @param blobStore - Where to store file blobs\n */\nexport async function publishSkillFromSource(\n  source: SkillSource,\n  skillPath: string,\n  blobStore: BlobStore,\n): Promise<SkillPublishResult> {\n  const result = await collectSkillForPublish(source, skillPath);\n  // Store blobs in batch\n  await blobStore.putMany(result.blobs);\n  return result;\n}\n","/**\n * Workspace Class\n *\n * A Workspace combines a Filesystem and a Sandbox to provide agents\n * with a complete environment for storing files and executing code.\n *\n * Users pass provider instances directly to the Workspace constructor.\n *\n * @example\n * ```typescript\n * import { Workspace } from '@mastra/core';\n * import { LocalFilesystem } from '@mastra/workspace-fs-local';\n * import { AgentFS } from '@mastra/workspace-fs-agentfs';\n * import { ComputeSDKSandbox } from '@mastra/workspace-sandbox-computesdk';\n *\n * // Simple workspace with local filesystem\n * const workspace = new Workspace({\n *   filesystem: new LocalFilesystem({ basePath: './workspace' }),\n * });\n *\n * // Full workspace with AgentFS and cloud sandbox\n * const fullWorkspace = new Workspace({\n *   filesystem: new AgentFS({ path: './agent.db' }),\n *   sandbox: new ComputeSDKSandbox({ provider: 'e2b' }),\n * });\n *\n * await fullWorkspace.init();\n * await fullWorkspace.filesystem?.writeFile('/code/app.py', 'print(\"Hello!\")');\n * const result = await fullWorkspace.sandbox?.executeCommand?.('python3', ['app.py'], { cwd: '/code' });\n * ```\n */\n\nimport type { IMastraLogger } from '../logger';\nimport type { RequestContext } from '../request-context';\nimport type { MastraVector } from '../vector';\n\nimport { WorkspaceError, SearchNotAvailableError } from './errors';\nimport { CompositeFilesystem } from './filesystem';\nimport type { WorkspaceFilesystem, FilesystemInfo } from './filesystem';\nimport { MastraFilesystem } from './filesystem/mastra-filesystem';\nimport { isGlobPattern, extractGlobBase, createGlobMatcher } from './glob';\nimport { callLifecycle } from './lifecycle';\nimport { findProjectRoot, isLSPAvailable, LSPManager } from './lsp';\nimport type { LSPConfig } from './lsp/types';\nimport type { WorkspaceSandbox, OnMountHook } from './sandbox';\nimport { MastraSandbox } from './sandbox/mastra-sandbox';\nimport { SearchEngine } from './search';\nimport type { BM25Config, Embedder, SearchOptions, SearchResult, IndexDocument } from './search';\nimport type { WorkspaceSkills, SkillsResolver, SkillSource } from './skills';\nimport { WorkspaceSkillsImpl, LocalSkillSource } from './skills';\nimport type { WorkspaceToolsConfig } from './tools';\nimport type { WorkspaceStatus } from './types';\n\n// =============================================================================\n// Workspace Configuration\n// =============================================================================\n\n/**\n * Configuration for creating a Workspace.\n * Users pass provider instances directly.\n *\n * Generic type parameters allow the workspace to preserve the concrete types\n * of filesystem and sandbox providers, so accessors return the exact type\n * you passed in.\n */\nexport interface WorkspaceConfig<\n  TFilesystem extends WorkspaceFilesystem | undefined = WorkspaceFilesystem | undefined,\n  TSandbox extends WorkspaceSandbox | undefined = WorkspaceSandbox | undefined,\n  TMounts extends Record<string, WorkspaceFilesystem> | undefined = undefined,\n> {\n  /** Unique identifier (auto-generated if not provided) */\n  id?: string;\n\n  /** Human-readable name */\n  name?: string;\n\n  /**\n   * Filesystem provider instance.\n   * Use LocalFilesystem for a folder on disk, or AgentFS for Turso-backed storage.\n   * Extend MastraFilesystem for automatic logger integration.\n   */\n  filesystem?: TFilesystem;\n\n  /**\n   * Sandbox provider instance.\n   * Use ComputeSDKSandbox to access E2B, Modal, Docker, etc.\n   * Extend MastraSandbox for automatic logger integration.\n   */\n  sandbox?: TSandbox;\n\n  /**\n   * Mount multiple filesystems at different paths.\n   * Creates a CompositeFilesystem that routes operations based on path.\n   *\n   * When a sandbox is configured, filesystems are automatically mounted\n   * into the sandbox at their respective paths during init().\n   *\n   * Use the `onMount` hook to skip or customize mounting for specific filesystems.\n   *\n   * The concrete mount types are preserved  use `workspace.filesystem.mounts.get()`\n   * for typed access to individual mounts.\n   *\n   * @example\n   * ```typescript\n   * const workspace = new Workspace({\n   *   sandbox: new E2BSandbox({ timeout: 60000 }),\n   *   mounts: {\n   *     '/data': new S3Filesystem({ bucket: 'my-data', ... }),\n   *     '/skills': new S3Filesystem({ bucket: 'skills', readOnly: true, ... }),\n   *   },\n   * });\n   *\n   * await workspace.init();\n   * workspace.filesystem                    // CompositeFilesystem<{ '/data': S3Filesystem, '/skills': S3Filesystem }>\n   * workspace.filesystem.mounts.get('/data') // S3Filesystem\n   * ```\n   */\n  mounts?: TMounts;\n\n  /**\n   * Hook called before mounting each filesystem into the sandbox.\n   *\n   * Return values:\n   * - `false` - Skip mount entirely (don't mount this filesystem)\n   * - `{ success: true }` - Hook handled the mount successfully\n   * - `{ success: false, error?: string }` - Hook attempted mount but failed\n   * - `undefined` / no return - Use provider's default mount behavior\n   *\n   * This is useful for:\n   * - Skipping specific filesystems (e.g., local filesystems in remote sandbox)\n   * - Custom mount implementations\n   * - Syncing files instead of FUSE mounting\n   *\n   * Note: If your hook handles the mount, you're responsible for the entire\n   * implementation. The sandbox provider won't do any additional tracking.\n   *\n   * @example Skip local filesystems\n   * ```typescript\n   * const workspace = new Workspace({\n   *   sandbox: new E2BSandbox(),\n   *   mounts: {\n   *     '/data': new S3Filesystem({ bucket: 'data', ... }),\n   *     '/local': new LocalFilesystem({ basePath: './data' }),\n   *   },\n   *   onMount: ({ filesystem }) => {\n   *     if (filesystem.provider === 'local') return false;\n   *   },\n   * });\n   * ```\n   *\n   * @example Custom mount implementation\n   * ```typescript\n   * onMount: async ({ filesystem, mountPath, config, sandbox }) => {\n   *   if (config?.type === 's3') {\n   *     await sandbox.executeCommand?.('my-s3-mount', [mountPath]);\n   *     return { success: true };\n   *   }\n   * }\n   * ```\n   */\n  onMount?: OnMountHook;\n\n  // ---------------------------------------------------------------------------\n  // Search Configuration\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Vector store for semantic search.\n   * When provided along with embedder, enables vector and hybrid search.\n   */\n  vectorStore?: MastraVector;\n\n  /**\n   * Embedder function for generating vectors.\n   * Required when vectorStore is provided.\n   */\n  embedder?: Embedder;\n\n  /**\n   * Enable BM25 keyword search.\n   * Pass true for defaults, or a BM25Config object for custom parameters.\n   */\n  bm25?: boolean | BM25Config;\n\n  /**\n   * Custom index name for the vector store.\n   * If not provided, defaults to a sanitized version of `${id}_search`.\n   *\n   * Must be a valid SQL identifier for SQL-based stores (PgVector, LibSQL):\n   * - Start with a letter or underscore\n   * - Contain only letters, numbers, or underscores\n   * - Maximum 63 characters\n   *\n   * @example 'my_workspace_vectors'\n   */\n  searchIndexName?: string;\n\n  /**\n   * Paths to auto-index on init().\n   * Files in these directories will be indexed for search.\n   * @example ['/docs', '/support']\n   */\n  autoIndexPaths?: string[];\n\n  /**\n   * Paths where skills are located.\n   * Workspace will discover SKILL.md files in these directories.\n   *\n   * Can be a static array of paths or a function that returns paths\n   * dynamically based on request context (e.g., user tier, tenant).\n   *\n   * @example Static paths\n   * ```typescript\n   * skills: ['/skills', '/node_modules/@myorg/skills']\n   * ```\n   *\n   * @example Dynamic paths\n   * ```typescript\n   * skills: (ctx) => {\n   *   const tier = ctx.requestContext?.get('userTier');\n   *   return tier === 'premium'\n   *     ? ['/skills/basic', '/skills/premium']\n   *     : ['/skills/basic'];\n   * }\n   * ```\n   */\n  skills?: SkillsResolver;\n\n  /**\n   * Custom SkillSource to use for skill discovery.\n   * When provided, this source is used instead of the workspace filesystem or LocalSkillSource.\n   *\n   * Use `VersionedSkillSource` to read skills from the content-addressable blob store,\n   * serving a specific published version without touching the live filesystem.\n   *\n   * @example\n   * ```typescript\n   * import { VersionedSkillSource } from '@mastra/core/workspace';\n   *\n   * const workspace = new Workspace({\n   *   skills: ['/skills'],\n   *   skillSource: new VersionedSkillSource(tree, blobStore, versionCreatedAt),\n   * });\n   * ```\n   */\n  skillSource?: SkillSource;\n\n  // ---------------------------------------------------------------------------\n  // LSP Configuration\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Enable LSP diagnostics for edit tools.\n   *\n   * When enabled, edit tools (edit_file, write_file, ast_edit) will append\n   * type errors, warnings, and other diagnostics from language servers after edits.\n   *\n   * LSP requires a sandbox with a process manager (`sandbox.processes`) to spawn\n   * language server processes. It works with any sandbox backend (local, E2B, etc.).\n   *\n   * Requires optional peer dependencies: `vscode-jsonrpc`, `vscode-languageserver-protocol`,\n   * and the relevant language server (e.g. `typescript-language-server` for TypeScript).\n   *\n   * - `true`  Enable with defaults\n   * - `LSPConfig` object  Enable with custom timeouts/settings\n   *\n   * @default undefined (disabled)\n   */\n  lsp?: boolean | LSPConfig;\n\n  // ---------------------------------------------------------------------------\n  // Tool Configuration\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Per-tool configuration for workspace tools.\n   * Controls which tools are enabled and their safety settings.\n   *\n   * This replaces the provider-level `requireApproval` and `requireReadBeforeWrite`\n   * settings, allowing more granular control per tool.\n   *\n   * @example\n   * ```typescript\n   * tools: {\n   *   mastra_workspace_read_file: {\n   *     enabled: true,\n   *     requireApproval: false,\n   *   },\n   *   mastra_workspace_write_file: {\n   *     enabled: true,\n   *     requireApproval: true,\n   *     requireReadBeforeWrite: true,\n   *   },\n   *   mastra_workspace_execute_command: {\n   *     enabled: true,\n   *     requireApproval: true,\n   *   },\n   * }\n   * ```\n   */\n  tools?: WorkspaceToolsConfig;\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle Options\n  // ---------------------------------------------------------------------------\n\n  /** Auto-sync between fs and sandbox (default: false) */\n  autoSync?: boolean;\n\n  /** Timeout for individual operations in milliseconds */\n  operationTimeout?: number;\n}\n\n// Re-export WorkspaceStatus from types\nexport type { WorkspaceStatus } from './types';\n\n/**\n * A Workspace with any combination of filesystem, sandbox, and mounts.\n * Use this when you need to accept any Workspace regardless of its generic parameters.\n */\nexport type AnyWorkspace = Workspace<WorkspaceFilesystem | undefined, WorkspaceSandbox | undefined, any>;\n\n/** A workspace entry in the Mastra registry, enriched with source metadata. */\nexport interface RegisteredWorkspace {\n  workspace: Workspace;\n  source: 'mastra' | 'agent';\n  agentId?: string;\n  agentName?: string;\n}\n\n// =============================================================================\n// Path Context Types\n// =============================================================================\n\n/**\n * Information about how filesystem and sandbox paths relate.\n * Used by agents to understand how to access workspace files from sandbox code.\n */\nexport interface PathContext {\n  /** Filesystem details (if available) */\n  filesystem?: {\n    provider: string;\n    /** Absolute base path on disk (for local filesystems) */\n    basePath?: string;\n  };\n\n  /** Sandbox details (if available) */\n  sandbox?: {\n    provider: string;\n    /** Working directory for command execution */\n    workingDirectory?: string;\n  };\n\n  /**\n   * Human-readable instructions for how to access filesystem files from sandbox code.\n   * Combined from filesystem and sandbox provider instructions.\n   */\n  instructions: string;\n}\n\nexport interface WorkspaceInfo {\n  id: string;\n  name: string;\n  status: WorkspaceStatus;\n  createdAt: Date;\n  lastAccessedAt: Date;\n\n  /** Filesystem info (if available) */\n  filesystem?: FilesystemInfo & {\n    totalFiles?: number;\n    totalSize?: number;\n  };\n\n  /** Sandbox info (if available) */\n  sandbox?: {\n    provider: string;\n    status: string;\n    resources?: {\n      memoryMB?: number;\n      memoryUsedMB?: number;\n      cpuCores?: number;\n      cpuPercent?: number;\n      diskMB?: number;\n      diskUsedMB?: number;\n    };\n  };\n}\n\n// =============================================================================\n// Workspace Class\n// =============================================================================\n\n/**\n * Workspace provides agents with filesystem and execution capabilities.\n *\n * At minimum, a workspace has either a filesystem or a sandbox (or both).\n * Users pass instantiated provider objects to the constructor.\n */\nexport class Workspace<\n  TFilesystem extends WorkspaceFilesystem | undefined = WorkspaceFilesystem | undefined,\n  TSandbox extends WorkspaceSandbox | undefined = WorkspaceSandbox | undefined,\n  TMounts extends Record<string, WorkspaceFilesystem> | undefined = undefined,\n> {\n  readonly id: string;\n  readonly name: string;\n  readonly createdAt: Date;\n  lastAccessedAt: Date;\n\n  private _status: WorkspaceStatus = 'pending';\n  private readonly _fs?: WorkspaceFilesystem;\n  private readonly _sandbox?: WorkspaceSandbox;\n  private readonly _config: WorkspaceConfig<TFilesystem, TSandbox, TMounts>;\n  private readonly _searchEngine?: SearchEngine;\n  private _skills?: WorkspaceSkills;\n  private _lsp?: LSPManager;\n\n  constructor(config: WorkspaceConfig<TFilesystem, TSandbox, TMounts>) {\n    this.id = config.id ?? this.generateId();\n    this.name = config.name ?? `workspace-${this.id.slice(0, 8)}`;\n    this.createdAt = new Date();\n    this.lastAccessedAt = new Date();\n\n    this._config = config;\n    this._sandbox = config.sandbox;\n\n    // Setup mounts - creates CompositeFilesystem and informs sandbox\n    if (config.mounts && Object.keys(config.mounts).length > 0) {\n      // Validate: can't use both filesystem and mounts\n      if (config.filesystem) {\n        throw new WorkspaceError('Cannot use both \"filesystem\" and \"mounts\"', 'INVALID_CONFIG');\n      }\n\n      this._fs = new CompositeFilesystem({ mounts: config.mounts });\n      if (this._sandbox?.mounts) {\n        // Inform sandbox about mounts so it can process them on start()\n        this._sandbox.mounts.setContext({ sandbox: this._sandbox, workspace: this as unknown as Workspace });\n        this._sandbox.mounts.add(config.mounts);\n        if (config.onMount) {\n          this._sandbox.mounts.setOnMount(config.onMount);\n        }\n      }\n    } else {\n      this._fs = config.filesystem;\n    }\n\n    // Validate vector search config - embedder is required with vectorStore\n    if (config.vectorStore && !config.embedder) {\n      throw new WorkspaceError('vectorStore requires an embedder', 'INVALID_SEARCH_CONFIG');\n    }\n\n    // Create search engine if search is configured\n    if (config.bm25 || (config.vectorStore && config.embedder)) {\n      const buildIndexName = (): string => {\n        // Sanitize default name: replace all non-alphanumeric chars with underscores\n        const defaultName = `${this.id}_search`.replace(/[^a-zA-Z0-9_]/g, '_');\n        const indexName = config.searchIndexName ?? defaultName;\n\n        // Validate SQL identifier format\n        if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(indexName)) {\n          throw new WorkspaceError(\n            `Invalid searchIndexName: \"${indexName}\". Must start with a letter or underscore, and contain only letters, numbers, or underscores.`,\n            'INVALID_SEARCH_CONFIG',\n            this.id,\n          );\n        }\n        if (indexName.length > 63) {\n          throw new WorkspaceError(\n            `searchIndexName exceeds 63 characters (got ${indexName.length})`,\n            'INVALID_SEARCH_CONFIG',\n            this.id,\n          );\n        }\n        return indexName;\n      };\n\n      this._searchEngine = new SearchEngine({\n        bm25: config.bm25\n          ? {\n              bm25: typeof config.bm25 === 'object' ? config.bm25 : undefined,\n            }\n          : undefined,\n        vector:\n          config.vectorStore && config.embedder\n            ? {\n                vectorStore: config.vectorStore,\n                embedder: config.embedder,\n                indexName: buildIndexName(),\n              }\n            : undefined,\n      });\n    }\n\n    // Initialize LSP if configured and a process manager is available\n    if (config.lsp) {\n      const processes = this._sandbox?.processes;\n      if (!this._sandbox) {\n        console.warn(\n          `[Workspace \"${this.name}\"] lsp: true requires a sandbox with a process manager. No sandbox configured  LSP disabled.`,\n        );\n      } else if (!processes) {\n        console.warn(\n          `[Workspace \"${this.name}\"] lsp: true requires a sandbox with a process manager. Sandbox \"${this._sandbox.name ?? 'unknown'}\" does not provide one  LSP disabled.`,\n        );\n      } else if (!isLSPAvailable()) {\n        console.warn(\n          `[Workspace \"${this.name}\"] lsp: true requires vscode-jsonrpc and vscode-languageserver-protocol packages. Install them to enable LSP diagnostics.`,\n        );\n      } else {\n        const lspConfig = config.lsp === true ? {} : config.lsp;\n        const defaultRoot = lspConfig.root ?? findProjectRoot(process.cwd()) ?? process.cwd();\n        this._lsp = new LSPManager(processes, defaultRoot, lspConfig, this._fs);\n      }\n    }\n\n    // Validate at least one provider is given\n    // Note: skills alone is also valid - uses LocalSkillSource for read-only skills\n    if (!this._fs && !this._sandbox && !this.hasSkillsConfig()) {\n      throw new WorkspaceError('Workspace requires at least a filesystem, sandbox, or skills', 'NO_PROVIDERS');\n    }\n  }\n\n  private generateId(): string {\n    return `ws-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n  }\n\n  private hasSkillsConfig(): boolean {\n    return (\n      this._config.skills !== undefined && (typeof this._config.skills === 'function' || this._config.skills.length > 0)\n    );\n  }\n\n  get status(): WorkspaceStatus {\n    return this._status;\n  }\n\n  /**\n   * The filesystem provider (if configured).\n   *\n   * Returns the concrete type you passed to the constructor.\n   * When `mounts` is used instead of `filesystem`, returns `CompositeFilesystem`\n   * parameterized with the concrete mount types.\n   */\n  get filesystem(): [TMounts] extends [Record<string, WorkspaceFilesystem>]\n    ? CompositeFilesystem<TMounts>\n    : TFilesystem {\n    return this._fs as any;\n  }\n\n  /**\n   * The sandbox provider (if configured).\n   *\n   * Returns the concrete type you passed to the constructor.\n   */\n  get sandbox(): TSandbox {\n    return this._sandbox as any;\n  }\n\n  /**\n   * Get the per-tool configuration for this workspace.\n   * Returns undefined if no tools config was provided.\n   */\n  getToolsConfig(): WorkspaceToolsConfig | undefined {\n    return this._config.tools;\n  }\n\n  /**\n   * The LSP manager (if configured, initialized, and a process manager is available).\n   * Returns undefined if LSP is not configured, deps are missing, or sandbox has no process manager.\n   */\n  get lsp(): LSPManager | undefined {\n    return this._lsp;\n  }\n\n  /**\n   * Update the per-tool configuration for this workspace.\n   * Takes effect on the next `createWorkspaceTools()` call.\n   *\n   * @example\n   * ```typescript\n   * // Disable write tools for read-only mode\n   * workspace.setToolsConfig({\n   *   mastra_workspace_write_file: { enabled: false },\n   *   mastra_workspace_edit_file: { enabled: false },\n   * });\n   *\n   * // Re-enable all tools\n   * workspace.setToolsConfig(undefined);\n   * ```\n   */\n  setToolsConfig(config: WorkspaceToolsConfig | undefined): void {\n    this._config.tools = config;\n  }\n\n  /**\n   * Access skills stored in this workspace.\n   * Skills are SKILL.md files discovered from the configured skillPaths.\n   *\n   * Returns undefined if no skillPaths are configured.\n   *\n   * @example\n   * ```typescript\n   * const skills = await workspace.skills?.list();\n   * const skill = await workspace.skills?.get('brand-guidelines');\n   * const results = await workspace.skills?.search('brand colors');\n   * ```\n   */\n  get skills(): WorkspaceSkills | undefined {\n    // Skills require skills config\n    if (!this.hasSkillsConfig()) {\n      return undefined;\n    }\n\n    // Lazy initialization\n    if (!this._skills) {\n      // Priority: explicit skillSource > workspace filesystem > LocalSkillSource (read-only from local disk)\n      const source = this._config.skillSource ?? this._fs ?? new LocalSkillSource();\n\n      this._skills = new WorkspaceSkillsImpl({\n        source,\n        skills: this._config.skills!,\n        searchEngine: this._searchEngine,\n        validateOnLoad: true,\n      });\n    }\n\n    return this._skills;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Search Capabilities\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Check if BM25 keyword search is available.\n   */\n  get canBM25(): boolean {\n    return this._searchEngine?.canBM25 ?? false;\n  }\n\n  /**\n   * Check if vector semantic search is available.\n   */\n  get canVector(): boolean {\n    return this._searchEngine?.canVector ?? false;\n  }\n\n  /**\n   * Check if hybrid search is available.\n   */\n  get canHybrid(): boolean {\n    return this._searchEngine?.canHybrid ?? false;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Search Operations\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Index content for search.\n   * The path becomes the document ID in search results.\n   *\n   * @param path - File path (used as document ID)\n   * @param content - Text content to index\n   * @param options - Index options (metadata, type hints)\n   * @throws {SearchNotAvailableError} if search is not configured\n   */\n  async index(\n    path: string,\n    content: string,\n    options?: {\n      type?: 'text' | 'image' | 'file';\n      mimeType?: string;\n      metadata?: Record<string, unknown>;\n      startLineOffset?: number;\n    },\n  ): Promise<void> {\n    if (!this._searchEngine) {\n      throw new SearchNotAvailableError();\n    }\n    this.lastAccessedAt = new Date();\n\n    const doc: IndexDocument = {\n      id: path,\n      content,\n      metadata: {\n        type: options?.type,\n        mimeType: options?.mimeType,\n        ...options?.metadata,\n      },\n      startLineOffset: options?.startLineOffset,\n    };\n\n    await this._searchEngine.index(doc);\n  }\n\n  /**\n   * Search indexed content.\n   *\n   * @param query - Search query string\n   * @param options - Search options (topK, mode, filters)\n   * @returns Array of search results\n   * @throws {SearchNotAvailableError} if search is not configured\n   */\n  async search(query: string, options?: SearchOptions): Promise<SearchResult[]> {\n    if (!this._searchEngine) {\n      throw new SearchNotAvailableError();\n    }\n    this.lastAccessedAt = new Date();\n    return this._searchEngine.search(query, options);\n  }\n\n  /**\n   * Rebuild the search index from filesystem paths.\n   * Used internally for auto-indexing on init.\n   *\n   * Paths can be plain directories (e.g., '/docs') or glob patterns\n   * (e.g., '/docs/**\\/*.md'). Glob patterns are resolved to a walk root\n   * via extractGlobBase, then files are filtered by the pattern.\n   */\n  private async rebuildSearchIndex(paths: string[]): Promise<void> {\n    if (!this._searchEngine || !this._fs || paths.length === 0) {\n      return;\n    }\n\n    // Clear existing BM25 index\n    this._searchEngine.clear();\n\n    // Index all files from specified paths\n    for (const pathOrGlob of paths) {\n      try {\n        if (isGlobPattern(pathOrGlob)) {\n          // Glob pattern: walk from the base directory, filter with matcher\n          const walkRoot = extractGlobBase(pathOrGlob);\n          const matcher = createGlobMatcher(pathOrGlob);\n          const files = await this.getAllFiles(walkRoot);\n          for (const filePath of files) {\n            if (!matcher(filePath)) continue;\n            await this.indexFileForSearch(filePath);\n          }\n        } else {\n          // Plain path: recurse everything (existing behavior)\n          const files = await this.getAllFiles(pathOrGlob);\n          for (const filePath of files) {\n            await this.indexFileForSearch(filePath);\n          }\n        }\n      } catch {\n        // Skip paths that don't exist\n      }\n    }\n  }\n\n  /**\n   * Index a single file for search. Skips files that can't be read as text.\n   */\n  private async indexFileForSearch(filePath: string): Promise<void> {\n    try {\n      const content = await this._fs!.readFile(filePath, { encoding: 'utf-8' });\n      await this._searchEngine!.index({\n        id: filePath,\n        content: content as string,\n      });\n    } catch {\n      // Skip files that can't be read as text\n    }\n  }\n\n  private async getAllFiles(dir: string, depth: number = 0, maxDepth: number = 10): Promise<string[]> {\n    if (!this._fs || depth >= maxDepth) return [];\n\n    const files: string[] = [];\n    const entries = await this._fs.readdir(dir);\n\n    for (const entry of entries) {\n      const fullPath = dir === '/' ? `/${entry.name}` : `${dir}/${entry.name}`;\n      if (entry.type === 'file') {\n        files.push(fullPath);\n      } else if (entry.type === 'directory' && !entry.isSymlink) {\n        // Skip symlink directories to prevent infinite recursion from cycles\n        files.push(...(await this.getAllFiles(fullPath, depth + 1, maxDepth)));\n      }\n    }\n\n    return files;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Initialize the workspace.\n   * Starts the sandbox, initializes the filesystem, and auto-mounts filesystems.\n   */\n  async init(): Promise<void> {\n    this._status = 'initializing';\n\n    try {\n      if (this._fs) {\n        await callLifecycle(this._fs, 'init');\n      }\n\n      if (this._sandbox) {\n        await callLifecycle(this._sandbox, 'start');\n      }\n\n      // Auto-index files if autoIndexPaths is configured\n      if (this._searchEngine && this._config.autoIndexPaths && this._config.autoIndexPaths.length > 0) {\n        await this.rebuildSearchIndex(this._config.autoIndexPaths ?? []);\n      }\n\n      this._status = 'ready';\n    } catch (error) {\n      this._status = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Destroy the workspace and clean up all resources.\n   */\n  async destroy(): Promise<void> {\n    this._status = 'destroying';\n\n    try {\n      // Shutdown LSP before sandbox  LSP clients need running processes to send shutdown/exit\n      if (this._lsp) {\n        try {\n          await this._lsp.shutdownAll();\n        } catch {\n          // LSP shutdown errors are non-blocking\n        }\n        this._lsp = undefined;\n      }\n\n      if (this._sandbox) {\n        await callLifecycle(this._sandbox, 'destroy');\n      }\n\n      if (this._fs) {\n        await callLifecycle(this._fs, 'destroy');\n      }\n\n      this._status = 'destroyed';\n    } catch (error) {\n      this._status = 'error';\n      throw error;\n    }\n  }\n\n  /**\n   * Get workspace information.\n   * @param options.includeFileCount - Whether to count total files (can be slow for large workspaces)\n   */\n  async getInfo(options?: { includeFileCount?: boolean }): Promise<WorkspaceInfo> {\n    const info: WorkspaceInfo = {\n      id: this.id,\n      name: this.name,\n      status: this._status,\n      createdAt: this.createdAt,\n      lastAccessedAt: this.lastAccessedAt,\n    };\n\n    if (this._fs) {\n      const fsInfo = await this._fs.getInfo?.();\n      info.filesystem = {\n        id: fsInfo?.id ?? this._fs.id,\n        name: fsInfo?.name ?? this._fs.name,\n        provider: fsInfo?.provider ?? this._fs.provider,\n        readOnly: fsInfo?.readOnly ?? this._fs.readOnly,\n        status: fsInfo?.status,\n        error: fsInfo?.error,\n        icon: fsInfo?.icon,\n        metadata: fsInfo?.metadata,\n      };\n\n      if (options?.includeFileCount) {\n        try {\n          const files = await this.getAllFiles('/');\n          info.filesystem.totalFiles = files.length;\n        } catch {\n          // Ignore errors - filesystem may not support listing\n        }\n      }\n    }\n\n    if (this._sandbox) {\n      const sandboxInfo = await this._sandbox.getInfo?.();\n      info.sandbox = {\n        provider: this._sandbox.provider,\n        status: sandboxInfo?.status ?? this._sandbox.status,\n        resources: sandboxInfo?.resources,\n      };\n    }\n\n    return info;\n  }\n\n  /**\n   * Get human-readable instructions describing the workspace environment.\n   *\n   * When both a sandbox with mounts and a filesystem exist, each mount path\n   * is classified as sandbox-accessible (state === 'mounted') or\n   * workspace-only (pending / mounting / error / unsupported). When there's\n   * no sandbox or no mounts, falls back to provider-level instructions.\n   *\n   * @param opts - Optional options including request context for per-request customisation\n   * @returns Combined instructions string (may be empty)\n   */\n  getInstructions(opts?: { requestContext?: RequestContext }): string {\n    const parts: string[] = [];\n\n    // Sandbox-level instructions (working directory, provider type)\n    const sandboxInstructions = this._sandbox?.getInstructions?.(opts);\n    if (sandboxInstructions) parts.push(sandboxInstructions);\n\n    // Mount state overlay: check actual MountManager state\n    const mountEntries = this._sandbox?.mounts?.entries;\n    if (mountEntries && mountEntries.size > 0) {\n      const sandboxAccessible: string[] = [];\n      const workspaceOnly: string[] = [];\n\n      for (const [mountPath, entry] of mountEntries) {\n        const fsName = entry.filesystem.displayName || entry.filesystem.provider;\n        const access = entry.filesystem.readOnly ? 'read-only' : 'read-write';\n\n        if (entry.state === 'mounted') {\n          sandboxAccessible.push(`  - ${mountPath}: ${fsName} (${access})`);\n        } else {\n          // pending, mounting, error, unsupported  NOT accessible in sandbox\n          workspaceOnly.push(`  - ${mountPath}: ${fsName} (${access})`);\n        }\n      }\n\n      if (sandboxAccessible.length) {\n        parts.push(`Sandbox-mounted filesystems (accessible in shell commands):\\n${sandboxAccessible.join('\\n')}`);\n      }\n      if (workspaceOnly.length) {\n        parts.push(\n          `Workspace-only filesystems (use file tools, NOT available in shell commands):\\n${workspaceOnly.join('\\n')}`,\n        );\n      }\n    } else {\n      // No mounts or no sandbox  fall back to filesystem-level instructions\n      const fsInstructions = this._fs?.getInstructions?.(opts);\n      if (fsInstructions) parts.push(fsInstructions);\n    }\n\n    return parts.join('\\n\\n');\n  }\n\n  /**\n   * Get information about how filesystem and sandbox paths relate.\n   * Useful for understanding how to access workspace files from sandbox code.\n   *\n   * @deprecated Use {@link getInstructions} instead. `getInstructions()` is\n   * mount-state-aware and feeds into the system message via\n   * `WorkspaceInstructionsProcessor`.\n   *\n   * @returns PathContext with paths and instructions from providers\n   */\n  getPathContext(): PathContext {\n    // Get instructions from providers\n    const fsInstructions = this._fs?.getInstructions?.();\n    const sandboxInstructions = this._sandbox?.getInstructions?.();\n\n    // Combine instructions from both providers\n    const instructions = [fsInstructions, sandboxInstructions].filter(Boolean).join(' ');\n\n    return {\n      filesystem: this._fs\n        ? {\n            provider: this._fs.provider,\n            basePath: this._fs.basePath,\n          }\n        : undefined,\n      sandbox: this._sandbox\n        ? {\n            provider: this._sandbox.provider,\n            workingDirectory: this._sandbox.workingDirectory,\n          }\n        : undefined,\n      instructions,\n    };\n  }\n\n  // ---------------------------------------------------------------------------\n  // Logger Integration\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Set the logger for this workspace and propagate to providers.\n   * Called by Mastra when the logger is set.\n   * @internal\n   */\n  __setLogger(logger: IMastraLogger): void {\n    // Propagate logger to filesystem provider if it extends MastraFilesystem\n    if (this._fs instanceof MastraFilesystem) {\n      this._fs.__setLogger(logger);\n    }\n\n    // Propagate logger to sandbox provider if it extends MastraSandbox\n    if (this._sandbox instanceof MastraSandbox) {\n      this._sandbox.__setLogger(logger);\n    }\n  }\n}\n","/**\n * Process Handle (Base Class)\n *\n * Abstract base class for process handles.\n * Manages stdout/stderr callback dispatch and provides lazy\n * reader/writer stream getters  subclasses only implement\n * the platform-specific primitives.\n */\n\nimport { Readable, Writable } from 'node:stream';\n\nimport type { CommandResult } from '../types';\nimport type { SpawnProcessOptions } from './types';\n\n/**\n * Handle to a spawned process.\n *\n * Subclasses implement the platform-specific primitives (kill, sendStdin,\n * wait). The base class handles stdout/stderr accumulation, callback\n * dispatch via `emitStdout`/`emitStderr`, lazy `reader`/`writer` stream\n * getters, and optional streaming callbacks on `wait()`.\n *\n * **For consumers:**\n * - `handle.stdout`  poll accumulated output\n * - `handle.wait()`  wait for exit, optionally with streaming callbacks\n * - `handle.reader` / `handle.writer`  Node.js stream interop (LSP, JSON-RPC, pipes)\n * - `onStdout`/`onStderr` callbacks in {@link SpawnProcessOptions}  stream at spawn time\n *\n * **For implementors:** Call `emitStdout(data)` / `emitStderr(data)` from\n * your transport callback (ChildProcess events, WebSocket messages, etc.)\n * to dispatch data. Pass `options` through to `super(options)` to wire\n * user callbacks automatically.\n *\n * @example\n * ```typescript\n * // Poll model\n * const handle = await sandbox.processes.spawn('node server.js');\n * console.log(handle.stdout);\n *\n * // Stream model  callbacks at spawn time\n * const handle = await sandbox.processes.spawn('npm run dev', {\n *   onStdout: (data) => console.log(data),\n * });\n *\n * // Stream model  callbacks during wait\n * const result = await handle.wait({\n *   onStdout: (data) => process.stdout.write(data),\n *   onStderr: (data) => process.stderr.write(data),\n * });\n *\n * // Stream model  pipe to LSP, JSON-RPC, etc.\n * const handle = await sandbox.processes.spawn('typescript-language-server --stdio');\n * const connection = createMessageConnection(\n *   new StreamMessageReader(handle.reader),\n *   new StreamMessageWriter(handle.writer),\n * );\n * ```\n */\nexport abstract class ProcessHandle {\n  /** Process ID */\n  abstract readonly pid: number;\n  /** Exit code, undefined while the process is still running */\n  abstract readonly exitCode: number | undefined;\n  /** The command that was spawned (set by the process manager) */\n  command?: string;\n  /** Kill the running process (SIGKILL). Returns true if killed, false if not found. */\n  abstract kill(): Promise<boolean>;\n  /** Send data to the process's stdin */\n  abstract sendStdin(data: string): Promise<void>;\n\n  /**\n   * Wait for the process to finish and return the result.\n   *\n   * Optionally pass `onStdout`/`onStderr` callbacks to stream output chunks\n   * while waiting. The callbacks are automatically removed when `wait()`\n   * resolves, so there's no cleanup needed by the caller.\n   *\n   * Subclasses implement `wait()` with platform-specific logic  the base\n   * constructor wraps it to handle the optional streaming callbacks.\n   */\n  async wait(_options?: {\n    onStdout?: (data: string) => void;\n    onStderr?: (data: string) => void;\n  }): Promise<CommandResult> {\n    throw new Error(`${this.constructor.name} must implement wait()`);\n  }\n\n  private _stdout = '';\n  private _stderr = '';\n  private _stdoutListeners = new Set<(data: string) => void>();\n  private _stderrListeners = new Set<(data: string) => void>();\n  private _reader?: Readable;\n  private _writer?: Writable;\n\n  constructor(options?: Pick<SpawnProcessOptions, 'onStdout' | 'onStderr'>) {\n    // Spawn-time callbacks are permanent listeners\n    if (options?.onStdout) this._stdoutListeners.add(options.onStdout);\n    if (options?.onStderr) this._stderrListeners.add(options.onStderr);\n\n    // Capture subclass wait() (via prototype chain) before shadowing\n    // with a wrapper that handles optional streaming callbacks.\n    const implWait = this.wait.bind(this);\n\n    this.wait = async (waitOptions?: { onStdout?: (data: string) => void; onStderr?: (data: string) => void }) => {\n      if (waitOptions?.onStdout) this._stdoutListeners.add(waitOptions.onStdout);\n      if (waitOptions?.onStderr) this._stderrListeners.add(waitOptions.onStderr);\n      try {\n        return await implWait();\n      } finally {\n        if (waitOptions?.onStdout) this._stdoutListeners.delete(waitOptions.onStdout);\n        if (waitOptions?.onStderr) this._stderrListeners.delete(waitOptions.onStderr);\n      }\n    };\n  }\n\n  /** Accumulated stdout so far */\n  get stdout(): string {\n    return this._stdout;\n  }\n\n  /** Accumulated stderr so far */\n  get stderr(): string {\n    return this._stderr;\n  }\n\n  /**\n   * Emit stdout data  accumulates, dispatches to user callback, and pushes to reader stream.\n   * @internal Called by subclasses and process managers to dispatch transport data.\n   */\n  emitStdout(data: string): void {\n    this._stdout += data;\n    for (const listener of this._stdoutListeners) listener(data);\n    this._reader?.push(data);\n  }\n\n  /**\n   * Emit stderr data  accumulates and dispatches to user callback.\n   * @internal Called by subclasses and process managers to dispatch transport data.\n   */\n  emitStderr(data: string): void {\n    this._stderr += data;\n    for (const listener of this._stderrListeners) listener(data);\n  }\n\n  /** Readable stream of stdout (for use with StreamMessageReader, pipes, etc.) */\n  get reader(): Readable {\n    if (!this._reader) {\n      this._reader = new Readable({ read() {} });\n      void this.wait().then(\n        () => this._reader!.push(null),\n        () => this._reader!.push(null),\n      );\n    }\n    return this._reader;\n  }\n\n  /** Writable stream to stdin (for use with StreamMessageWriter, pipes, etc.) */\n  get writer(): Writable {\n    if (!this._writer) {\n      this._writer = new Writable({\n        write: (chunk, _encoding, cb) => {\n          this.sendStdin(chunk.toString()).then(() => cb(), cb);\n        },\n      });\n    }\n    return this._writer;\n  }\n}\n","/**\n * Sandbox Process Manager (Base Class)\n *\n * Abstract base class for sandbox process management.\n * Wraps all methods with ensureRunning() so the sandbox is\n * automatically started before any process operation.\n * Subclasses implement spawn(), list(), get().\n */\n\nimport type { MastraSandbox } from '../mastra-sandbox';\nimport type { ProcessHandle } from './process-handle';\nimport type { ProcessInfo, SpawnProcessOptions } from './types';\n\n// =============================================================================\n// Sandbox Process Manager (Base Class)\n// =============================================================================\n\n/**\n * Abstract base class for process management in sandboxes.\n *\n * Wraps subclass overrides of `spawn()`, `list()`, and `get()` with\n * `sandbox.ensureRunning()` so the sandbox is lazily started before\n * any process operation.\n *\n * Subclasses implement the actual platform-specific logic for all methods.\n *\n * @typeParam TSandbox - The sandbox type. Subclasses narrow this to access\n *   sandbox-specific properties (e.g. `workingDirectory`, `instance`).\n *\n * @example\n * ```typescript\n * const handle = await sandbox.processes.spawn('node server.js');\n * console.log(handle.pid, handle.stdout);\n *\n * const all = await sandbox.processes.list();\n * const proc = await sandbox.processes.get(handle.pid);\n * await proc?.kill();\n * ```\n */\nexport interface ProcessManagerOptions {\n  env?: Record<string, string | undefined>;\n}\n\nexport abstract class SandboxProcessManager<TSandbox extends MastraSandbox = MastraSandbox> {\n  /**\n   * The sandbox this process manager belongs to.\n   * Set automatically by MastraSandbox when processes are passed into the constructor.\n   * @internal\n   */\n  sandbox!: TSandbox;\n\n  protected readonly env: Record<string, string | undefined>;\n\n  /** Tracked process handles keyed by PID. Populated by spawn(), used by get()/kill(). */\n  protected readonly _tracked = new Map<number, ProcessHandle>();\n\n  /** PIDs that have been read after exit and should not be re-discovered by subclass fallbacks. */\n  protected readonly _dismissed = new Set<number>();\n\n  constructor({ env = {} }: ProcessManagerOptions = {}) {\n    this.env = env;\n\n    // Capture subclass overrides (via prototype chain) before shadowing\n    // with wrapped versions that add ensureRunning().\n    const impl = {\n      spawn: this.spawn.bind(this),\n      list: this.list.bind(this),\n      get: this.get.bind(this),\n    };\n\n    this.spawn = async (...args: Parameters<typeof impl.spawn>) => {\n      await this.sandbox.ensureRunning();\n      const handle = await impl.spawn(...args);\n      handle.command = args[0];\n      return handle;\n    };\n\n    this.list = async () => {\n      await this.sandbox.ensureRunning();\n      return impl.list();\n    };\n\n    this.get = async (...args: Parameters<typeof impl.get>) => {\n      await this.sandbox.ensureRunning();\n      // Skip PIDs that were already read after exit and dismissed.\n      if (this._dismissed.has(args[0])) return undefined;\n      const handle = await impl.get(...args);\n      // Prune exited processes when their output is read  this is the\n      // only automatic cleanup path. Keeps output available until the\n      // consumer has seen it at least once.\n      if (handle?.exitCode !== undefined) {\n        this._tracked.delete(handle.pid);\n        this._dismissed.add(handle.pid);\n      }\n      return handle;\n    };\n  }\n\n  /** Spawn a process. */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  async spawn(command: string, options: SpawnProcessOptions = {}): Promise<ProcessHandle> {\n    throw new Error(`${this.constructor.name} must implement spawn()`);\n  }\n\n  /** List all tracked processes. */\n  async list(): Promise<ProcessInfo[]> {\n    throw new Error(`${this.constructor.name} must implement list()`);\n  }\n\n  /** Get a handle to a process by PID. Subclasses can override for fallback behavior. */\n  async get(pid: number): Promise<ProcessHandle | undefined> {\n    return this._tracked.get(pid);\n  }\n\n  /** Kill a process by PID. Returns true if killed, false if not found. */\n  async kill(pid: number): Promise<boolean> {\n    const handle = await this.get(pid);\n    if (!handle) return false;\n    const killed = await handle.kill();\n    if (killed) {\n      // Wait for termination so handle.exitCode is populated before returning.\n      // Without this, a subsequent get() could still report the process as running.\n      await handle.wait().catch(() => {});\n    }\n    // Release tracked handle to free accumulated output buffers.\n    this._tracked.delete(pid);\n    this._dismissed.add(pid);\n    return killed;\n  }\n}\n","/**\n * Local Process Manager\n *\n * Local implementation of SandboxProcessManager using child_process.spawn.\n * Tracks processes in-memory since there's no server to query.\n */\n\nimport * as childProcess from 'node:child_process';\nimport type { ChildProcess } from 'node:child_process';\n\nimport type { LocalSandbox } from './local-sandbox';\nimport { ProcessHandle, SandboxProcessManager } from './process-manager';\nimport type { ProcessInfo, SpawnProcessOptions } from './process-manager';\nimport type { CommandResult } from './types';\n\n// =============================================================================\n// Local Process Handle\n// =============================================================================\n\n/**\n * Local implementation of ProcessHandle wrapping a node ChildProcess.\n * Not exported  internal to this module.\n */\nclass LocalProcessHandle extends ProcessHandle {\n  readonly pid: number;\n  exitCode: number | undefined;\n\n  private proc: ChildProcess;\n  private readonly waitPromise: Promise<CommandResult>;\n  private readonly startTime: number;\n\n  constructor(proc: ChildProcess, startTime: number, options?: SpawnProcessOptions) {\n    super(options);\n    if (!proc.pid) {\n      throw new Error('Process has no PID - it may have failed to spawn');\n    }\n    this.pid = proc.pid;\n    this.proc = proc;\n    this.startTime = startTime;\n\n    let timedOut = false;\n    const timeoutId = options?.timeout\n      ? setTimeout(() => {\n          timedOut = true;\n          // Kill the process group so child processes are also terminated\n          try {\n            process.kill(-this.pid, 'SIGTERM');\n          } catch {\n            proc.kill('SIGTERM');\n          }\n        }, options.timeout)\n      : undefined;\n\n    this.waitPromise = new Promise<CommandResult>(resolve => {\n      proc.on('close', (code, signal) => {\n        if (timeoutId) clearTimeout(timeoutId);\n        if (timedOut) {\n          const timeoutMsg = `\\nProcess timed out after ${options!.timeout}ms`;\n          this.emitStderr(timeoutMsg);\n          this.exitCode = 124;\n        } else {\n          this.exitCode = signal && code === null ? 128 : (code ?? 0);\n        }\n        resolve({\n          success: this.exitCode === 0,\n          exitCode: this.exitCode,\n          stdout: this.stdout,\n          stderr: this.stderr,\n          executionTimeMs: Date.now() - this.startTime,\n          killed: signal !== null,\n          timedOut,\n        });\n      });\n\n      proc.on('error', err => {\n        if (timeoutId) clearTimeout(timeoutId);\n        this.emitStderr(err.message);\n        this.exitCode = 1;\n        resolve({\n          success: false,\n          exitCode: 1,\n          stdout: this.stdout,\n          stderr: this.stderr,\n          executionTimeMs: Date.now() - this.startTime,\n        });\n      });\n    });\n\n    proc.stdout?.on('data', (data: Buffer) => {\n      this.emitStdout(data.toString());\n    });\n\n    proc.stderr?.on('data', (data: Buffer) => {\n      this.emitStderr(data.toString());\n    });\n  }\n\n  async wait(): Promise<CommandResult> {\n    return this.waitPromise;\n  }\n\n  async kill(): Promise<boolean> {\n    if (this.exitCode !== undefined) return false;\n    // Kill the entire process group (negative PID) to ensure child processes\n    // spawned by the shell are also terminated. Without this, commands like\n    // \"echo foo; sleep 60\" would leave orphaned children holding stdio open.\n    try {\n      process.kill(-this.pid, 'SIGKILL');\n      return true;\n    } catch {\n      // Fallback to direct kill if process group kill fails\n      return this.proc.kill('SIGKILL');\n    }\n  }\n\n  async sendStdin(data: string): Promise<void> {\n    if (this.exitCode !== undefined) {\n      throw new Error(`Process ${this.pid} has already exited with code ${this.exitCode}`);\n    }\n    if (!this.proc.stdin) {\n      throw new Error(`Process ${this.pid} does not have stdin available`);\n    }\n    return new Promise<void>((resolve, reject) => {\n      this.proc.stdin!.write(data, err => (err ? reject(err) : resolve()));\n    });\n  }\n}\n\n// =============================================================================\n// Local Process Manager\n// =============================================================================\n\n/**\n * Local implementation of SandboxProcessManager.\n * Spawns processes via child_process.spawn and tracks them in-memory.\n */\nexport class LocalProcessManager extends SandboxProcessManager<LocalSandbox> {\n  async spawn(command: string, options: SpawnProcessOptions = {}): Promise<ProcessHandle> {\n    const cwd = options.cwd ?? this.sandbox.workingDirectory;\n    const env = this.sandbox.buildEnv(options.env);\n    const wrapped = this.sandbox.wrapCommandForIsolation(command);\n\n    // detached: true creates a new process group so we can kill the entire tree.\n    // Non-isolated: use shell mode so the host shell interprets the command string.\n    // Isolated (seatbelt/bwrap): the wrapper already includes `sh -c` inside the\n    // sandbox, so we spawn the wrapper binary directly.\n    const proc = childProcess.spawn(wrapped.command, wrapped.args, {\n      cwd,\n      env,\n      shell: this.sandbox.isolation === 'none',\n      detached: true,\n    });\n    const handle = new LocalProcessHandle(proc, Date.now(), options);\n    this._tracked.set(handle.pid, handle);\n    return handle;\n  }\n\n  async list(): Promise<ProcessInfo[]> {\n    return Array.from(this._tracked.values()).map(handle => ({\n      pid: handle.pid,\n      running: handle.exitCode === undefined,\n      exitCode: handle.exitCode,\n    }));\n  }\n}\n","/**\n * Platform Detection\n *\n * Detects available sandboxing backends for the current platform.\n */\n\nimport { execFileSync } from 'node:child_process';\nimport os from 'node:os';\n\nimport type { IsolationBackend, SandboxDetectionResult } from './types';\n\n/**\n * Check if a command exists on the system.\n */\nfunction commandExists(command: string): boolean {\n  try {\n    // Use 'which' on Unix-like systems\n    execFileSync('which', [command], { stdio: 'ignore' });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Check if seatbelt (sandbox-exec) is available.\n * This is built-in on macOS.\n */\nexport function isSeatbeltAvailable(): boolean {\n  if (os.platform() !== 'darwin') {\n    return false;\n  }\n  return commandExists('sandbox-exec');\n}\n\n/**\n * Check if bubblewrap (bwrap) is available.\n * This must be installed on Linux systems.\n */\nexport function isBwrapAvailable(): boolean {\n  if (os.platform() !== 'linux') {\n    return false;\n  }\n  return commandExists('bwrap');\n}\n\n/**\n * Detect the best available isolation backend for the current platform.\n *\n * @returns The recommended isolation backend and availability info\n *\n * @example\n * ```typescript\n * const result = detectIsolation();\n * if (result.available) {\n *   console.log(`Using ${result.backend} for sandboxing`);\n * } else {\n *   console.warn(result.message);\n * }\n * ```\n */\nexport function detectIsolation(): SandboxDetectionResult {\n  const platform = os.platform();\n\n  if (platform === 'darwin') {\n    const available = isSeatbeltAvailable();\n    return {\n      backend: 'seatbelt',\n      available,\n      message: available\n        ? 'macOS seatbelt (sandbox-exec) is available'\n        : 'macOS seatbelt (sandbox-exec) not found - this is unexpected on macOS',\n    };\n  }\n\n  if (platform === 'linux') {\n    const available = isBwrapAvailable();\n    return {\n      backend: 'bwrap',\n      available,\n      message: available\n        ? 'Linux bubblewrap (bwrap) is available'\n        : 'Linux bubblewrap (bwrap) not found. Install with: apt install bubblewrap (Debian/Ubuntu) or dnf install bubblewrap (Fedora)',\n    };\n  }\n\n  // Windows or other platforms\n  return {\n    backend: 'none',\n    available: false,\n    message: `Native sandboxing is not supported on ${platform}. Commands will run without isolation.`,\n  };\n}\n\n/**\n * Check if a specific isolation backend is available.\n *\n * @param backend - The isolation backend to check\n * @returns Whether the backend is available on this system\n */\nexport function isIsolationAvailable(backend: IsolationBackend): boolean {\n  switch (backend) {\n    case 'seatbelt':\n      return isSeatbeltAvailable();\n    case 'bwrap':\n      return isBwrapAvailable();\n    case 'none':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Get the recommended isolation backend for this platform.\n * Returns 'none' if no sandboxing is available.\n */\nexport function getRecommendedIsolation(): IsolationBackend {\n  const result = detectIsolation();\n  return result.available ? result.backend : 'none';\n}\n","/**\n * Seatbelt (macOS sandbox-exec)\n *\n * macOS built-in sandboxing using sandbox-exec with SBPL profiles.\n *\n * Important: Uses `-p` (inline profile) instead of `-f` (file) because\n * `-f` doesn't work reliably with path filters on modern macOS.\n *\n * Note on macOS sandbox limitations:\n * - `(allow file-read* (subpath ...))` only works WITH a preceding `(allow file-read*)`\n * - So for reads: allow all, then deny specific paths\n * - For writes: allow specific paths with subpath filters\n *\n * Based on the approach used by Claude Code's sandbox-runtime:\n * https://github.com/anthropic-experimental/sandbox-runtime\n */\n\nimport type { NativeSandboxConfig } from './types';\n\n/**\n * Mach services needed for basic operation\n */\nconst MACH_SERVICES = [\n  'com.apple.distributed_notifications@Uv3',\n  'com.apple.logd',\n  'com.apple.system.logger',\n  'com.apple.system.notification_center',\n  'com.apple.system.opendirectoryd.libinfo',\n  'com.apple.system.opendirectoryd.membership',\n  'com.apple.bsd.dirhelper',\n  'com.apple.securityd.xpc',\n  'com.apple.SecurityServer',\n  'com.apple.trustd.agent',\n];\n\n/**\n * Escape a path for use in SBPL profile.\n * Uses JSON.stringify for proper escaping.\n */\nfunction escapePath(pathStr: string): string {\n  return JSON.stringify(pathStr);\n}\n\n/**\n * Generate a seatbelt profile for the given configuration.\n *\n * The profile:\n * - Allows all file reads (can't restrict with subpath on macOS)\n * - Restricts file writes to workspace and temp directories\n * - Blocks network unless explicitly allowed\n *\n * @param workspacePath - The workspace directory to allow write access to\n * @param config - Additional sandbox configuration\n * @returns The generated SBPL profile content\n */\nexport function generateSeatbeltProfile(workspacePath: string, config: NativeSandboxConfig): string {\n  // Fail-closed: seatbelt cannot restrict process-exec, so reject unsupported config\n  if (config.allowSystemBinaries === false) {\n    throw new Error(\n      'allowSystemBinaries: false is not supported by seatbelt (macOS). ' +\n        'Use bubblewrap on Linux or remove this restriction.',\n    );\n  }\n\n  const lines: string[] = [];\n\n  // Version and default deny\n  lines.push('(version 1)');\n  lines.push('(deny default (with message \"mastra-sandbox\"))');\n  lines.push('');\n\n  // Process permissions\n  lines.push('; Process permissions');\n  lines.push('(allow process-exec)');\n  lines.push('(allow process-fork)');\n  lines.push('(allow process-info* (target same-sandbox))');\n  lines.push('(allow signal (target same-sandbox))');\n  lines.push('');\n\n  // Mach IPC\n  lines.push('; Mach IPC');\n  lines.push('(allow mach-lookup');\n  for (const service of MACH_SERVICES) {\n    lines.push(`  (global-name \"${service}\")`);\n  }\n  lines.push(')');\n  lines.push('');\n\n  // IPC\n  lines.push('; IPC');\n  lines.push('(allow ipc-posix-shm)');\n  lines.push('(allow ipc-posix-sem)');\n  lines.push('');\n\n  // User preferences\n  lines.push('; User preferences');\n  lines.push('(allow user-preference-read)');\n  lines.push('');\n\n  // sysctl\n  lines.push('; sysctl');\n  lines.push('(allow sysctl-read)');\n  lines.push('');\n\n  // Device files\n  lines.push('; Device files');\n  lines.push('(allow file-ioctl (literal \"/dev/null\"))');\n  lines.push('(allow file-ioctl (literal \"/dev/zero\"))');\n  lines.push('(allow file-ioctl (literal \"/dev/random\"))');\n  lines.push('(allow file-ioctl (literal \"/dev/urandom\"))');\n  lines.push('(allow file-ioctl (literal \"/dev/tty\"))');\n  lines.push('');\n\n  // File read access - allow all reads (macOS limitation: can't use subpath without this)\n  lines.push('; File read access (allow all - macOS sandbox limitation)');\n  lines.push('(allow file-read*)');\n\n  // Add custom read-only paths as additional allows (technically redundant but explicit)\n  for (const p of config.readOnlyPaths ?? []) {\n    lines.push(`(allow file-read* (subpath ${escapePath(p)}))`);\n  }\n  lines.push('');\n\n  // File write access - restrict to workspace and temp\n  lines.push('; File write access (restricted to workspace and temp)');\n\n  // Workspace\n  lines.push(`(allow file-write* (subpath ${escapePath(workspacePath)}))`);\n\n  // Temp directories (needed for many operations)\n  lines.push('(allow file-write* (subpath \"/private/tmp\"))');\n  lines.push('(allow file-write* (subpath \"/var/folders\"))');\n  lines.push('(allow file-write* (subpath \"/private/var/folders\"))');\n\n  // Custom read-write paths\n  for (const p of config.readWritePaths ?? []) {\n    lines.push(`(allow file-write* (subpath ${escapePath(p)}))`);\n  }\n  lines.push('');\n\n  // Network\n  lines.push('; Network');\n  if (config.allowNetwork) {\n    lines.push('(allow network*)');\n  } else {\n    lines.push('(deny network* (with message \"mastra-sandbox-network\"))');\n  }\n\n  return lines.join('\\n');\n}\n\n/**\n * Build the command arguments for sandbox-exec.\n *\n * Uses `-p` (inline profile) instead of `-f` (file) because\n * `-f` doesn't work reliably with path filters on modern macOS.\n *\n * @param command - The full shell command string to run\n * @param profile - The SBPL profile content (not a file path)\n * @returns Wrapped command and arguments for sandbox-exec\n */\nexport function buildSeatbeltCommand(command: string, profile: string): { command: string; args: string[] } {\n  return {\n    command: 'sandbox-exec',\n    args: ['-p', profile, 'sh', '-c', command],\n  };\n}\n","/**\n * Bubblewrap (Linux bwrap)\n *\n * Linux sandboxing using user namespaces and bind mounts.\n * https://github.com/containers/bubblewrap\n */\n\nimport type { NativeSandboxConfig } from './types';\n\n/**\n * System paths to mount read-only by default.\n * These are needed for basic command execution.\n */\nconst DEFAULT_READONLY_BINDS = [\n  '/usr',\n  '/lib',\n  '/lib64',\n  '/bin',\n  '/sbin',\n  '/etc/alternatives',\n  '/etc/ssl',\n  '/etc/ca-certificates',\n  '/etc/resolv.conf',\n  '/etc/hosts',\n  '/etc/passwd',\n  '/etc/group',\n  '/etc/nsswitch.conf',\n  '/etc/ld.so.cache',\n  '/etc/localtime',\n];\n\n/**\n * Build the bwrap command arguments for the given configuration.\n *\n * @param command - The full shell command string to run inside the sandbox\n * @param workspacePath - The workspace directory (mounted read-write)\n * @param config - Additional sandbox configuration\n * @returns Wrapped command and arguments for bwrap\n */\nexport function buildBwrapCommand(\n  command: string,\n  workspacePath: string,\n  config: NativeSandboxConfig,\n): { command: string; args: string[] } {\n  // If custom bwrap args are provided, use them directly\n  if (config.bwrapArgs && config.bwrapArgs.length > 0) {\n    return {\n      command: 'bwrap',\n      args: [...config.bwrapArgs, '--', 'sh', '-c', command],\n    };\n  }\n\n  const bwrapArgs: string[] = [];\n\n  // Create new namespaces for isolation\n  bwrapArgs.push('--unshare-pid'); // PID namespace (can't see host processes)\n  bwrapArgs.push('--unshare-ipc'); // IPC namespace\n  bwrapArgs.push('--unshare-uts'); // UTS namespace (separate hostname)\n\n  // Network isolation (unless explicitly allowed)\n  if (!config.allowNetwork) {\n    bwrapArgs.push('--unshare-net');\n  }\n\n  // Mount a new /proc for the PID namespace\n  bwrapArgs.push('--proc', '/proc');\n\n  // Mount a tmpfs at /tmp\n  bwrapArgs.push('--tmpfs', '/tmp');\n\n  // Mount system paths read-only\n  for (const path of DEFAULT_READONLY_BINDS) {\n    // Use --ro-bind-try to skip paths that don't exist on this system\n    bwrapArgs.push('--ro-bind-try', path, path);\n  }\n\n  // Mount custom read-only paths\n  for (const path of config.readOnlyPaths ?? []) {\n    bwrapArgs.push('--ro-bind', path, path);\n  }\n\n  // Allow system binaries by default (node, python, etc.)\n  if (config.allowSystemBinaries !== false) {\n    // Include the Node.js binary location\n    const nodePath = process.execPath;\n    const nodeDir = nodePath.substring(0, nodePath.lastIndexOf('/'));\n\n    // Mount the node directory if it's not already covered\n    if (!DEFAULT_READONLY_BINDS.some(p => nodeDir.startsWith(p))) {\n      bwrapArgs.push('--ro-bind', nodeDir, nodeDir);\n    }\n\n    // Also mount common runtime locations\n    bwrapArgs.push('--ro-bind-try', '/opt', '/opt');\n    bwrapArgs.push('--ro-bind-try', '/snap', '/snap');\n  }\n\n  // Mount workspace read-write\n  bwrapArgs.push('--bind', workspacePath, workspacePath);\n\n  // Mount custom read-write paths\n  for (const path of config.readWritePaths ?? []) {\n    bwrapArgs.push('--bind', path, path);\n  }\n\n  // Set the working directory\n  bwrapArgs.push('--chdir', workspacePath);\n\n  // Die with parent (clean up if the parent process dies)\n  bwrapArgs.push('--die-with-parent');\n\n  // Add the command separator and run via sh -c for shell interpretation\n  bwrapArgs.push('--', 'sh', '-c', command);\n\n  return {\n    command: 'bwrap',\n    args: bwrapArgs,\n  };\n}\n","/**\n * Command Wrapper\n *\n * Wraps commands with the appropriate sandbox backend.\n */\n\nimport { buildBwrapCommand } from './bubblewrap';\nimport { buildSeatbeltCommand, generateSeatbeltProfile } from './seatbelt';\nimport type { IsolationBackend, NativeSandboxConfig } from './types';\n\nexport interface WrappedCommand {\n  command: string;\n  args: string[];\n}\n\nexport interface WrapCommandOptions {\n  /** The isolation backend to use */\n  backend: IsolationBackend;\n  /** The workspace directory path */\n  workspacePath: string;\n  /** Pre-generated seatbelt profile content (optional, will be generated if not provided) */\n  seatbeltProfile?: string;\n  /** Native sandbox configuration */\n  config: NativeSandboxConfig;\n}\n\n/**\n * Wrap a command with the appropriate sandbox backend.\n *\n * @param command - The full shell command string to run\n * @param options - Wrapping options\n * @returns The wrapped command and arguments\n *\n * @example\n * ```typescript\n * const wrapped = wrapCommand('node script.js', {\n *   backend: 'seatbelt',\n *   workspacePath: '/workspace',\n *   config: { allowNetwork: false },\n * });\n * // wrapped.command = 'sandbox-exec'\n * // wrapped.args = ['-p', '<profile>', 'sh', '-c', 'node script.js']\n * ```\n */\nexport function wrapCommand(command: string, options: WrapCommandOptions): WrappedCommand {\n  switch (options.backend) {\n    case 'seatbelt': {\n      const profile = options.seatbeltProfile ?? generateSeatbeltProfile(options.workspacePath, options.config);\n      return buildSeatbeltCommand(command, profile);\n    }\n\n    case 'bwrap': {\n      return buildBwrapCommand(command, options.workspacePath, options.config);\n    }\n\n    case 'none':\n    default:\n      return { command, args: [] };\n  }\n}\n","/**\n * Local Sandbox Provider\n *\n * A sandbox implementation that executes commands on the local machine.\n * This is the default sandbox for development and local agents.\n *\n * Supports optional native OS sandboxing:\n * - macOS: Uses seatbelt (sandbox-exec) for filesystem and network isolation\n * - Linux: Uses bubblewrap (bwrap) for namespace isolation\n */\n\nimport * as crypto from 'node:crypto';\nimport * as fs from 'node:fs/promises';\nimport * as os from 'node:os';\nimport * as path from 'node:path';\nimport type { RequestContext } from '../../request-context';\nimport type { ProviderStatus } from '../lifecycle';\nimport type { InstructionsOption } from '../types';\nimport { resolveInstructions } from '../utils';\nimport { IsolationUnavailableError } from './errors';\nimport { LocalProcessManager } from './local-process-manager';\nimport { MastraSandbox } from './mastra-sandbox';\nimport type { MastraSandboxOptions } from './mastra-sandbox';\nimport type { IsolationBackend, NativeSandboxConfig } from './native-sandbox';\nimport { detectIsolation, isIsolationAvailable, generateSeatbeltProfile, wrapCommand } from './native-sandbox';\nimport type { SandboxInfo } from './types';\n\n// =============================================================================\n// Local Sandbox\n// =============================================================================\n\n/**\n * Local sandbox provider configuration.\n */\nexport interface LocalSandboxOptions extends MastraSandboxOptions {\n  /** Unique identifier for this sandbox instance */\n  id?: string;\n  /** Working directory for command execution */\n  workingDirectory?: string;\n  /**\n   * Environment variables to set for command execution.\n   * PATH is included by default unless overridden (needed for finding executables).\n   * Other host environment variables are not inherited unless explicitly passed.\n   *\n   * @example\n   * ```typescript\n   * // Default - only PATH is available\n   * env: undefined\n   *\n   * // Add specific variables\n   * env: { NODE_ENV: 'production', HOME: process.env.HOME }\n   *\n   * // Full host environment (less secure)\n   * env: process.env\n   * ```\n   */\n  env?: NodeJS.ProcessEnv;\n  /** Default timeout for operations in ms (default: 30000) */\n  timeout?: number;\n  /**\n   * Isolation backend for sandboxed execution.\n   * - 'none': No sandboxing (direct execution on host) - default\n   * - 'seatbelt': macOS sandbox-exec (built-in on macOS)\n   * - 'bwrap': Linux bubblewrap (requires installation)\n   *\n   * Use `LocalSandbox.detectIsolation()` to get the recommended backend.\n   * @default 'none'\n   */\n  isolation?: IsolationBackend;\n  /**\n   * Configuration for native sandboxing.\n   * Only used when isolation is 'seatbelt' or 'bwrap'.\n   */\n  nativeSandbox?: NativeSandboxConfig;\n  /**\n   * Custom instructions that override the default instructions\n   * returned by `getInstructions()`.\n   *\n   * - `string`  Fully replaces the default instructions.\n   *   Pass an empty string to suppress instructions entirely.\n   * - `(opts) => string`  Receives the default instructions and\n   *   optional request context so you can extend or customise per-request.\n   */\n  instructions?: InstructionsOption;\n}\n\n/**\n * Local sandbox implementation.\n *\n * Executes commands directly on the host machine.\n * This is the recommended sandbox for development and trusted local execution.\n *\n * @example\n * ```typescript\n * import { Workspace, LocalFilesystem, LocalSandbox } from '@mastra/core';\n *\n * const workspace = new Workspace({\n *   filesystem: new LocalFilesystem({ basePath: './my-workspace' }),\n *   sandbox: new LocalSandbox({ workingDirectory: './my-workspace' }),\n * });\n *\n * await workspace.init();\n * const result = await workspace.executeCommand('node', ['script.js']);\n * ```\n */\nexport class LocalSandbox extends MastraSandbox {\n  readonly id: string;\n  readonly name = 'LocalSandbox';\n  readonly provider = 'local';\n\n  status: ProviderStatus = 'pending';\n\n  readonly workingDirectory: string;\n  readonly isolation: IsolationBackend;\n  declare readonly processes: LocalProcessManager;\n  private readonly env: NodeJS.ProcessEnv;\n  private readonly _nativeSandboxConfig: NativeSandboxConfig;\n  private _seatbeltProfile?: string;\n  private _seatbeltProfilePath?: string;\n  private _sandboxFolderPath?: string;\n  private _userProvidedProfilePath = false;\n  private readonly _createdAt: Date;\n  private readonly _instructionsOverride?: InstructionsOption;\n\n  constructor(options: LocalSandboxOptions = {}) {\n    // Validate isolation backend before super (fail fast)\n    const requestedIsolation = options.isolation ?? 'none';\n    if (requestedIsolation !== 'none' && !isIsolationAvailable(requestedIsolation)) {\n      const detection = detectIsolation();\n      throw new IsolationUnavailableError(requestedIsolation, detection.message);\n    }\n\n    super({\n      ...options,\n      name: 'LocalSandbox',\n      processes: new LocalProcessManager({ env: options.env ?? {} }),\n    });\n\n    this.id = options.id ?? this.generateId();\n    this._createdAt = new Date();\n    this.workingDirectory = options.workingDirectory ?? path.join(process.cwd(), '.sandbox');\n    this.env = options.env ?? {};\n    this._nativeSandboxConfig = options.nativeSandbox ?? {};\n    this.isolation = requestedIsolation;\n    this._instructionsOverride = options.instructions;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Lifecycle\n  // ---------------------------------------------------------------------------\n\n  /**\n   * Start the local sandbox.\n   * Creates working directory and sets up seatbelt profile if using macOS isolation.\n   * Status management is handled by the base class.\n   */\n  async start(): Promise<void> {\n    this.logger.debug('[LocalSandbox] Starting sandbox', {\n      workingDirectory: this.workingDirectory,\n      isolation: this.isolation,\n    });\n\n    await fs.mkdir(this.workingDirectory, { recursive: true });\n\n    // Set up seatbelt profile for macOS sandboxing\n    if (this.isolation === 'seatbelt') {\n      const userProvidedPath = this._nativeSandboxConfig.seatbeltProfilePath;\n\n      if (userProvidedPath) {\n        // User provided a custom path\n        this._seatbeltProfilePath = userProvidedPath;\n        this._userProvidedProfilePath = true;\n\n        // Check if file exists at user's path\n        try {\n          this._seatbeltProfile = await fs.readFile(userProvidedPath, 'utf-8');\n        } catch (err: unknown) {\n          if (err instanceof Error && 'code' in err && (err as NodeJS.ErrnoException).code !== 'ENOENT') {\n            throw err;\n          }\n          // File doesn't exist, generate default and write to user's path\n          this._seatbeltProfile = generateSeatbeltProfile(this.workingDirectory, this._nativeSandboxConfig);\n          // Ensure parent directory exists\n          await fs.mkdir(path.dirname(userProvidedPath), { recursive: true });\n          await fs.writeFile(userProvidedPath, this._seatbeltProfile, 'utf-8');\n        }\n      } else {\n        // No custom path, use default location\n        this._seatbeltProfile = generateSeatbeltProfile(this.workingDirectory, this._nativeSandboxConfig);\n\n        // Generate a deterministic hash from workspace path and config\n        // This allows identical sandboxes to share profiles while preventing collisions\n        const configHash = crypto\n          .createHash('sha256')\n          .update(this.workingDirectory)\n          .update(JSON.stringify(this._nativeSandboxConfig))\n          .digest('hex')\n          .slice(0, 8);\n\n        // Write profile to .sandbox-profiles/ in cwd (outside working directory)\n        // This prevents sandboxed processes from reading/modifying their own security profile\n        this._sandboxFolderPath = path.join(process.cwd(), '.sandbox-profiles');\n        await fs.mkdir(this._sandboxFolderPath, { recursive: true });\n        this._seatbeltProfilePath = path.join(this._sandboxFolderPath, `seatbelt-${configHash}.sb`);\n        await fs.writeFile(this._seatbeltProfilePath, this._seatbeltProfile, 'utf-8');\n      }\n    }\n\n    this.logger.debug('[LocalSandbox] Sandbox started', { workingDirectory: this.workingDirectory });\n  }\n\n  /**\n   * Stop the local sandbox.\n   * Status management is handled by the base class.\n   */\n  async stop(): Promise<void> {\n    this.logger.debug('[LocalSandbox] Stopping sandbox', { workingDirectory: this.workingDirectory });\n  }\n\n  /**\n   * Destroy the local sandbox and clean up resources.\n   * Cleans up seatbelt profile if auto-generated.\n   * Status management is handled by the base class.\n   */\n  async destroy(): Promise<void> {\n    this.logger.debug('[LocalSandbox] Destroying sandbox', { workingDirectory: this.workingDirectory });\n\n    // Kill all background processes\n    const procs = await this.processes.list();\n    await Promise.all(procs.map(p => this.processes.kill(p.pid)));\n\n    // Clean up seatbelt profile only if it was auto-generated (not user-provided)\n    if (this._seatbeltProfilePath && !this._userProvidedProfilePath) {\n      try {\n        await fs.unlink(this._seatbeltProfilePath);\n      } catch {\n        // Ignore errors if file doesn't exist\n      }\n    }\n    this._seatbeltProfilePath = undefined;\n    this._seatbeltProfile = undefined;\n    this._userProvidedProfilePath = false;\n\n    // Try to remove .sandbox folder if empty\n    if (this._sandboxFolderPath) {\n      try {\n        await fs.rmdir(this._sandboxFolderPath);\n      } catch {\n        // Ignore errors - folder may not be empty or may not exist\n      }\n      this._sandboxFolderPath = undefined;\n    }\n  }\n\n  /** @deprecated Use `status === 'running'` instead. */\n  async isReady(): Promise<boolean> {\n    return this.status === 'running';\n  }\n\n  async getInfo(): Promise<SandboxInfo> {\n    return {\n      id: this.id,\n      name: this.name,\n      provider: this.provider,\n      status: this.status,\n      createdAt: this._createdAt,\n      resources: {\n        memoryMB: Math.round(os.totalmem() / 1024 / 1024),\n        cpuCores: os.cpus().length,\n      },\n      metadata: {\n        workingDirectory: this.workingDirectory,\n        platform: os.platform(),\n        nodeVersion: process.version,\n        isolation: this.isolation,\n        isolationConfig:\n          this.isolation !== 'none'\n            ? {\n                allowNetwork: this._nativeSandboxConfig.allowNetwork ?? false,\n                readOnlyPaths: this._nativeSandboxConfig.readOnlyPaths,\n                readWritePaths: this._nativeSandboxConfig.readWritePaths,\n              }\n            : undefined,\n      },\n    };\n  }\n\n  getInstructions(opts?: { requestContext?: RequestContext }): string {\n    return resolveInstructions(this._instructionsOverride, () => this._getDefaultInstructions(), opts?.requestContext);\n  }\n\n  private _getDefaultInstructions(): string {\n    return `Local command execution. Working directory: \"${this.workingDirectory}\".`;\n  }\n\n  // ---------------------------------------------------------------------------\n  // Internal Utils\n  // ---------------------------------------------------------------------------\n\n  private generateId(): string {\n    return `local-sandbox-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;\n  }\n\n  /**\n   * Build the environment object for execution.\n   * Always includes PATH by default (needed for finding executables).\n   * Merges the sandbox's configured env with any additional env from the command.\n   * @internal Used by LocalProcessManager.\n   */\n  buildEnv(additionalEnv?: NodeJS.ProcessEnv): NodeJS.ProcessEnv {\n    return {\n      PATH: process.env.PATH, // Always include PATH for finding executables\n      ...this.env,\n      ...additionalEnv,\n    };\n  }\n\n  /**\n   * Wrap a command with the configured isolation backend.\n   * @internal Used by LocalProcessManager for background process isolation.\n   */\n  wrapCommandForIsolation(command: string): { command: string; args: string[] } {\n    if (this.isolation === 'none') {\n      return { command, args: [] };\n    }\n\n    return wrapCommand(command, {\n      backend: this.isolation,\n      workspacePath: this.workingDirectory,\n      seatbeltProfile: this._seatbeltProfile,\n      config: this._nativeSandboxConfig,\n    });\n  }\n\n  /**\n   * Detect the best available isolation backend for this platform.\n   * Returns detection result with backend recommendation and availability.\n   *\n   * @example\n   * ```typescript\n   * const result = LocalSandbox.detectIsolation();\n   * const sandbox = new LocalSandbox({\n   *   isolation: result.available ? result.backend : 'none',\n   * });\n   * ```\n   */\n  static detectIsolation() {\n    return detectIsolation();\n  }\n}\n","export const WORKSPACE_TOOLS_PREFIX = 'mastra_workspace' as const;\n\n/**\n * Workspace tool name constants.\n * Use these to reference workspace tools by name.\n *\n * @example\n * ```typescript\n * import { WORKSPACE_TOOLS } from '@mastra/core/workspace';\n *\n * if (toolName === WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND) {\n *   // Handle sandbox execution\n * }\n * ```\n */\nexport const WORKSPACE_TOOLS = {\n  FILESYSTEM: {\n    READ_FILE: `${WORKSPACE_TOOLS_PREFIX}_read_file` as const,\n    WRITE_FILE: `${WORKSPACE_TOOLS_PREFIX}_write_file` as const,\n    EDIT_FILE: `${WORKSPACE_TOOLS_PREFIX}_edit_file` as const,\n    LIST_FILES: `${WORKSPACE_TOOLS_PREFIX}_list_files` as const,\n    DELETE: `${WORKSPACE_TOOLS_PREFIX}_delete` as const,\n    FILE_STAT: `${WORKSPACE_TOOLS_PREFIX}_file_stat` as const,\n    MKDIR: `${WORKSPACE_TOOLS_PREFIX}_mkdir` as const,\n    GREP: `${WORKSPACE_TOOLS_PREFIX}_grep` as const,\n    AST_EDIT: `${WORKSPACE_TOOLS_PREFIX}_ast_edit` as const,\n  },\n  SANDBOX: {\n    EXECUTE_COMMAND: `${WORKSPACE_TOOLS_PREFIX}_execute_command` as const,\n    GET_PROCESS_OUTPUT: `${WORKSPACE_TOOLS_PREFIX}_get_process_output` as const,\n    KILL_PROCESS: `${WORKSPACE_TOOLS_PREFIX}_kill_process` as const,\n  },\n  SEARCH: {\n    SEARCH: `${WORKSPACE_TOOLS_PREFIX}_search` as const,\n    INDEX: `${WORKSPACE_TOOLS_PREFIX}_index` as const,\n  },\n} as const;\n\n/**\n * Type representing any workspace tool name.\n */\nexport type WorkspaceToolName =\n  | (typeof WORKSPACE_TOOLS.FILESYSTEM)[keyof typeof WORKSPACE_TOOLS.FILESYSTEM]\n  | (typeof WORKSPACE_TOOLS.SEARCH)[keyof typeof WORKSPACE_TOOLS.SEARCH]\n  | (typeof WORKSPACE_TOOLS.SANDBOX)[keyof typeof WORKSPACE_TOOLS.SANDBOX];\n","/**\n * Workspace Tool Helpers\n *\n * Runtime assertions for extracting workspace resources from tool execution context.\n */\n\nimport path from 'node:path';\n\nimport type { ToolExecutionContext } from '../../tools/types';\nimport { WorkspaceNotAvailableError, FilesystemNotAvailableError, SandboxNotAvailableError } from '../errors';\nimport type { WorkspaceFilesystem } from '../filesystem';\nimport type { LSPDiagnostic, DiagnosticSeverity } from '../lsp/types';\nimport type { WorkspaceSandbox } from '../sandbox';\nimport type { Workspace } from '../workspace';\n\n/**\n * Extract workspace from tool execution context.\n * Throws if workspace is not available.\n */\nexport function requireWorkspace(context: ToolExecutionContext): Workspace {\n  if (!context?.workspace) {\n    throw new WorkspaceNotAvailableError();\n  }\n  return context.workspace;\n}\n\n/**\n * Extract filesystem from workspace in tool execution context.\n * Throws if workspace or filesystem is not available.\n */\nexport function requireFilesystem(context: ToolExecutionContext): {\n  workspace: Workspace;\n  filesystem: WorkspaceFilesystem;\n} {\n  const workspace = requireWorkspace(context);\n  if (!workspace.filesystem) {\n    throw new FilesystemNotAvailableError();\n  }\n  return { workspace, filesystem: workspace.filesystem };\n}\n\n/**\n * Extract sandbox from workspace in tool execution context.\n * Throws if workspace or sandbox is not available.\n */\nexport function requireSandbox(context: ToolExecutionContext): {\n  workspace: Workspace;\n  sandbox: WorkspaceSandbox;\n} {\n  const workspace = requireWorkspace(context);\n  if (!workspace.sandbox) {\n    throw new SandboxNotAvailableError();\n  }\n  return { workspace, sandbox: workspace.sandbox };\n}\n\n/**\n * Emit workspace metadata as a data chunk so the UI can render workspace info immediately.\n * Should be called at the start of every workspace tool's execute function.\n */\nexport async function emitWorkspaceMetadata(context: ToolExecutionContext, toolName: string) {\n  const workspace = requireWorkspace(context);\n  const info = await workspace.getInfo();\n  const toolCallId = context?.agent?.toolCallId;\n  await context?.writer?.custom({\n    type: 'data-workspace-metadata',\n    data: { toolName, toolCallId, ...info },\n  });\n}\n\n/**\n * Get LSP diagnostics text to append to edit tool results.\n * Non-blocking  returns empty string on any failure.\n *\n * LSP is a Workspace-level feature. This helper checks if the workspace\n * has an LSP manager and uses it to get diagnostics for the edited file.\n *\n * @param workspace - The workspace (must have an LSP manager for diagnostics)\n * @param filePath - Relative path within the filesystem (as used by the tool)\n * @param content - The file content after the edit\n * @returns Formatted diagnostics text, or empty string if unavailable\n */\nexport async function getEditDiagnosticsText(workspace: Workspace, filePath: string, content: string): Promise<string> {\n  try {\n    const lspManager = workspace.lsp;\n    if (!lspManager) return '';\n\n    // Use the filesystem's path resolution to get the real disk path.\n    // This correctly handles contained: true (virtual paths  basePath)\n    // and contained: false (absolute paths used as-is).\n    const absolutePath =\n      workspace.filesystem?.resolveAbsolutePath?.(filePath) ??\n      path.resolve(lspManager.root, filePath.replace(/^\\/+/, ''));\n\n    const DIAG_TIMEOUT_MS = 10_000;\n    let diagTimer: ReturnType<typeof setTimeout>;\n    const diagnostics: LSPDiagnostic[] = await Promise.race([\n      lspManager.getDiagnostics(absolutePath, content),\n      new Promise<LSPDiagnostic[]>((_, reject) => {\n        diagTimer = setTimeout(() => reject(new Error('LSP diagnostics timeout')), DIAG_TIMEOUT_MS);\n      }),\n    ]).finally(() => clearTimeout(diagTimer!));\n    if (diagnostics.length === 0) return '';\n\n    // Deduplicate by severity + location + message\n    const seen = new Set<string>();\n    const deduped = diagnostics.filter(d => {\n      const key = `${d.severity}:${d.line}:${d.character}:${d.message}`;\n      if (seen.has(key)) return false;\n      seen.add(key);\n      return true;\n    });\n\n    // Group diagnostics by severity\n    const groups: Record<DiagnosticSeverity, LSPDiagnostic[]> = {\n      error: [],\n      warning: [],\n      info: [],\n      hint: [],\n    };\n\n    for (const d of deduped) {\n      groups[d.severity].push(d);\n    }\n\n    const lines: string[] = ['\\n\\nLSP Diagnostics:'];\n\n    const severityLabels: [DiagnosticSeverity, string][] = [\n      ['error', 'Errors'],\n      ['warning', 'Warnings'],\n      ['info', 'Info'],\n      ['hint', 'Hints'],\n    ];\n\n    for (const [severity, label] of severityLabels) {\n      const items = groups[severity];\n      if (items.length === 0) continue;\n      lines.push(`${label}:`);\n      for (const d of items) {\n        const source = d.source ? ` [${d.source}]` : '';\n        lines.push(`  ${d.line}:${d.character} - ${d.message}${source}`);\n      }\n    }\n\n    let result = lines.join('\\n');\n\n    // Truncate to ~500 tokens (~2000 chars) to avoid bloating tool output\n    const maxChars = 2000;\n    if (result.length > maxChars) {\n      const cutoff = result.lastIndexOf('\\n', maxChars);\n      result = result.slice(0, cutoff > 0 ? cutoff : maxChars) + '\\n  ... (truncated)';\n    }\n\n    return result;\n  } catch {\n    return '';\n  }\n}\n","/**\n * AST Edit Tool\n *\n * Provides AST-aware code transformations for workspace files.\n * Uses @ast-grep/napi for syntax-aware pattern matching and transforms.\n *\n * Requires @ast-grep/napi as an optional peer dependency.\n */\n\nimport { createRequire } from 'node:module';\n\nimport { z } from 'zod';\n\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { FileNotFoundError, WorkspaceReadOnlyError } from '../errors';\nimport { emitWorkspaceMetadata, getEditDiagnosticsText, requireFilesystem } from './helpers';\n\n// =============================================================================\n// Types\n// =============================================================================\n\ninterface Replacement {\n  start: number;\n  end: number;\n  text: string;\n}\n\ninterface TransformResult {\n  content: string;\n  count: number;\n  error?: string;\n}\n\ninterface ImportSpec {\n  module: string;\n  names: string[];\n  isDefault?: boolean;\n}\n\n/**\n * Minimal interface for an ast-grep SgNode.\n * Avoids importing @ast-grep/napi types directly since it's an optional dep.\n */\ninterface SgNode {\n  text(): string;\n  range(): { start: { index: number }; end: { index: number } };\n  findAll(config: { rule: Record<string, unknown> }): SgNode[];\n  getMatch(name: string): SgNode | null;\n}\n\n/** Minimal interface for the ast-grep Lang enum values. */\ntype LangValue = unknown;\n\n/** The subset of @ast-grep/napi we use after dynamic import. */\ninterface AstGrepModule {\n  parse(lang: LangValue, content: string): { root(): SgNode };\n  Lang: Record<string, LangValue>;\n}\n\n// =============================================================================\n// Dynamic Import\n// =============================================================================\n\n// Cache the import result so we only try once\nlet astGrepModule: AstGrepModule | null | undefined;\nlet loadingPromise: Promise<AstGrepModule | null> | undefined;\n\n/**\n * Try to load @ast-grep/napi. Returns null if not available.\n * Uses dynamic import to avoid compile-time dependency.\n * Concurrent callers share the same in-flight promise.\n */\nexport async function loadAstGrep(): Promise<AstGrepModule | null> {\n  if (astGrepModule !== undefined) {\n    return astGrepModule;\n  }\n  if (!loadingPromise) {\n    loadingPromise = (async () => {\n      try {\n        // Dynamic import with string concatenation to prevent bundlers from resolving at build time\n        const moduleName = '@ast-grep' + '/napi';\n        const mod = await import(/* webpackIgnore: true */ moduleName);\n        astGrepModule = { parse: mod.parse, Lang: mod.Lang };\n        return astGrepModule;\n      } catch {\n        astGrepModule = null;\n        return null;\n      }\n    })();\n  }\n  return loadingPromise;\n}\n\n/**\n * Check if @ast-grep/napi is available without importing it.\n * Useful for deciding whether to create the tool at registration time.\n */\nexport function isAstGrepAvailable(): boolean {\n  if (astGrepModule !== undefined) {\n    return astGrepModule !== null;\n  }\n\n  try {\n    const req = createRequire(import.meta.url);\n    req.resolve('@ast-grep/napi');\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n// =============================================================================\n// Language Detection\n// =============================================================================\n\n/**\n * Map file extension to ast-grep Lang enum.\n *\n * Only languages with built-in tree-sitter grammars in @ast-grep/napi are\n * supported. Python, Go, Rust, etc. require separate @ast-grep/lang-* packages\n * which are not currently integrated.\n */\nexport function getLanguageFromPath(filePath: string, Lang: Record<string, LangValue>): LangValue | null {\n  const ext = filePath.split('.').pop()?.toLowerCase();\n  switch (ext) {\n    case 'ts':\n      return Lang.TypeScript;\n    case 'tsx':\n    case 'jsx':\n      return Lang.Tsx;\n    case 'js':\n      return Lang.JavaScript;\n    case 'html':\n      return Lang.Html;\n    case 'css':\n      return Lang.Css;\n    default:\n      return null;\n  }\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\n/** Escape regex metacharacters in a string. */\nfunction escapeRegex(str: string): string {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n/**\n * Rename all identifier occurrences matching `oldName` to `newName`.\n * Not scope-aware: renames all occurrences regardless of scope.\n */\nfunction renameIdentifiers(content: string, root: SgNode, oldName: string, newName: string): TransformResult {\n  let modifiedContent = content;\n  let count = 0;\n\n  const identifiers = root.findAll({\n    rule: {\n      kind: 'identifier',\n      regex: `^${escapeRegex(oldName)}$`,\n    },\n  });\n\n  const replacements: Replacement[] = [];\n  const seen = new Set<number>();\n\n  for (const id of identifiers) {\n    const range = id.range();\n    if (seen.has(range.start.index)) continue;\n    seen.add(range.start.index);\n    replacements.push({ start: range.start.index, end: range.end.index, text: newName });\n    count++;\n  }\n\n  replacements.sort((a, b) => b.start - a.start);\n\n  for (const { start, end, text } of replacements) {\n    modifiedContent = modifiedContent.slice(0, start) + text + modifiedContent.slice(end);\n  }\n\n  return { content: modifiedContent, count };\n}\n\n// =============================================================================\n// Transform Functions\n// =============================================================================\n\n/**\n * Build an import statement string from its parts.\n */\nfunction buildImportStatement(defaultName: string | null, namedImports: string[], moduleStr: string): string {\n  if (defaultName && namedImports.length > 0) {\n    return `import ${defaultName}, { ${namedImports.join(', ')} } from ${moduleStr};`;\n  } else if (defaultName) {\n    return `import ${defaultName} from ${moduleStr};`;\n  } else {\n    return `import { ${namedImports.join(', ')} } from ${moduleStr};`;\n  }\n}\n\n/**\n * Merge new names into an existing import statement.\n * Returns null if nothing needs to change.\n */\nfunction mergeIntoExistingImport(\n  content: string,\n  existingImport: SgNode,\n  names: string[],\n  isDefault?: boolean,\n): string | null {\n  const text = existingImport.text();\n\n  // Namespace imports (import * as X from 'mod') cannot be merged into\n  if (/^import\\s+\\*\\s+as\\s+/.test(text)) return null;\n\n  // Parse existing structure from the import text\n  // Matches: import [default] [, { named }] from 'module'\n  const defaultMatch = text.match(/^import\\s+(?!type\\s)(?!\\{)(\\w+)/);\n  const namedMatch = text.match(/\\{([^}]*)\\}/);\n  const moduleMatch = text.match(/([\"'][^\"']+[\"'])\\s*;?\\s*$/);\n\n  if (!moduleMatch) return null;\n  const moduleStr = moduleMatch[1] ?? '';\n\n  let existingDefault = defaultMatch ? (defaultMatch[1] ?? null) : null;\n  const existingNamed = namedMatch\n    ? (namedMatch[1] ?? '')\n        .split(',')\n        .map((s: string) => s.trim())\n        .filter(Boolean)\n    : [];\n\n  let newDefault = existingDefault;\n  const newNamed = [...existingNamed];\n\n  if (isDefault && names.length > 0) {\n    // First name is the default import\n    if (!existingDefault) {\n      newDefault = names[0] ?? null;\n    }\n    // Remaining names are named imports\n    for (const name of names.slice(1)) {\n      if (!newNamed.includes(name)) {\n        newNamed.push(name);\n      }\n    }\n  } else {\n    for (const name of names) {\n      if (!newNamed.includes(name)) {\n        newNamed.push(name);\n      }\n    }\n  }\n\n  // Check if anything changed\n  const defaultChanged = newDefault !== existingDefault;\n  const namedChanged = newNamed.length !== existingNamed.length;\n  if (!defaultChanged && !namedChanged) return null;\n\n  const importStatement = buildImportStatement(newDefault, newNamed, moduleStr);\n  const range = existingImport.range();\n  return content.slice(0, range.start.index) + importStatement + content.slice(range.end.index);\n}\n\n/**\n * Add an import statement to the file.\n * Inserts after the last existing import, or at the beginning if none exist.\n * If the module is already imported, merges new names into it.\n */\nexport function addImport(content: string, root: SgNode, importSpec: ImportSpec): string {\n  const { module, names, isDefault } = importSpec;\n\n  const imports = root.findAll({ rule: { kind: 'import_statement' } });\n\n  // Check if a mergeable import from this module already exists.\n  // Skip type-only and namespace imports  they can't be merged with value imports.\n  const existingImport = imports.find(imp => {\n    const text = imp.text();\n    if (/^import\\s+type\\s/.test(text)) return false;\n    if (/^import\\s+\\*\\s+as\\s+/.test(text)) return false;\n    return text.includes(`'${module}'`) || text.includes(`\"${module}\"`);\n  });\n\n  if (existingImport) {\n    // Try to merge new names into the existing import\n    return mergeIntoExistingImport(content, existingImport, names, isDefault) ?? content;\n  }\n\n  // Build new import statement\n  const moduleStr = `'${module}'`;\n  const importStatement = buildImportStatement(\n    isDefault ? names[0]! : null,\n    isDefault ? names.slice(1) : names,\n    moduleStr,\n  );\n\n  // Insert after last import or at file start\n  const lastImport = imports.at(-1);\n  if (lastImport) {\n    const pos = lastImport.range().end.index;\n    return content.slice(0, pos) + '\\n' + importStatement + content.slice(pos);\n  } else {\n    return importStatement + '\\n\\n' + content;\n  }\n}\n\n/**\n * Remove an import by module name.\n * Matches against the import source string.\n */\nexport function removeImport(content: string, root: SgNode, targetName: string): string {\n  const imports = root.findAll({ rule: { kind: 'import_statement' } });\n\n  for (const imp of imports) {\n    const text = imp.text();\n    if (text.includes(`'${targetName}'`) || text.includes(`\"${targetName}\"`)) {\n      const range = imp.range();\n      const start = range.start.index;\n      let end = range.end.index;\n      // Remove trailing newline if present\n      if (content[end] === '\\n') end++;\n      return content.slice(0, start) + content.slice(end);\n    }\n  }\n\n  return content;\n}\n\n/**\n * Pattern-based replacement using AST metavariables.\n * Pattern uses $VARNAME placeholders that match any AST node.\n * Replacement substitutes matched text back in.\n */\nexport function patternReplace(content: string, root: SgNode, pattern: string, replacement: string): TransformResult {\n  let modifiedContent = content;\n  let count = 0;\n\n  try {\n    const matches = root.findAll({ rule: { pattern } });\n    const replacements: Replacement[] = [];\n\n    // Extract metavariables from the pattern once (constant across all matches)\n    const metaVars = [...pattern.matchAll(/\\$(\\w+)/g)].map(m => m[1]).filter((v): v is string => v !== undefined);\n\n    for (const match of matches) {\n      const range = match.range();\n\n      // Build replacement text with variable substitution\n      let replacementText = replacement;\n      for (const varName of metaVars) {\n        const matchedNode = match.getMatch(varName);\n        if (matchedNode) {\n          replacementText = replacementText.replace(new RegExp(`\\\\$${varName}`, 'g'), matchedNode.text());\n        }\n      }\n\n      replacements.push({ start: range.start.index, end: range.end.index, text: replacementText });\n      count++;\n    }\n\n    replacements.sort((a, b) => b.start - a.start);\n\n    for (const { start, end, text } of replacements) {\n      modifiedContent = modifiedContent.slice(0, start) + text + modifiedContent.slice(end);\n    }\n  } catch (err) {\n    return {\n      content: modifiedContent,\n      count: 0,\n      error: err instanceof Error ? err.message : 'Pattern matching failed',\n    };\n  }\n\n  return { content: modifiedContent, count };\n}\n\n// =============================================================================\n// Tool Definition\n// =============================================================================\n\nexport const astEditTool = createTool({\n  id: WORKSPACE_TOOLS.FILESYSTEM.AST_EDIT,\n  description: `Edit code using AST-based analysis for intelligent transformations.\n\nUse \\`transform\\` for structured operations (imports, renames). Use \\`pattern\\`/\\`replacement\\` only for general find-and-replace.\n\nTransforms:\n- add-import: Add or merge imports. Skips duplicates. For default imports, put the default name first in \\`names\\`.\n  { transform: \"add-import\", importSpec: { module: \"react\", names: [\"useState\", \"useEffect\"] } }\n  { transform: \"add-import\", importSpec: { module: \"express\", names: [\"express\"], isDefault: true } }\n  { transform: \"add-import\", importSpec: { module: \"express\", names: [\"express\", \"Router\"], isDefault: true } }  import express, { Router } from 'express'\n- remove-import: Remove an import by module name.\n  { transform: \"remove-import\", targetName: \"lodash\" }\n- rename: Rename all occurrences of an identifier (not scope-aware).\n  { transform: \"rename\", targetName: \"oldName\", newName: \"newName\" }\n\nPattern replace (for everything else):\n  { pattern: \"console.log($ARG)\", replacement: \"logger.debug($ARG)\" }`,\n  inputSchema: z.object({\n    path: z.string().describe('The path to the file to edit'),\n    pattern: z\n      .string()\n      .optional()\n      .describe('AST pattern to search for (supports $VARIABLE placeholders, e.g., \"console.log($ARG)\")'),\n    replacement: z\n      .string()\n      .optional()\n      .describe('Replacement pattern (can use captured $VARIABLES, e.g., \"logger.debug($ARG)\")'),\n    transform: z\n      .enum(['add-import', 'remove-import', 'rename'])\n      .optional()\n      .describe('Structured transformation to apply'),\n    targetName: z\n      .string()\n      .optional()\n      .describe('Required for remove-import and rename transforms. The current name to target.'),\n    newName: z.string().optional().describe('Required for rename transform. The new name to replace targetName with.'),\n    importSpec: z\n      .object({\n        module: z.string().describe('Module to import from'),\n        names: z.array(z.string()).min(1).describe('Names to import. For default imports, put the default name first.'),\n        isDefault: z.boolean().optional().describe('Whether the first name is a default import'),\n      })\n      .optional()\n      .describe('Required for add-import transform. Specifies the module and names to import.'),\n  }),\n  execute: async ({ path, pattern, replacement, transform, targetName, newName, importSpec }, context) => {\n    const { workspace, filesystem } = requireFilesystem(context);\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.FILESYSTEM.AST_EDIT);\n\n    if (filesystem.readOnly) {\n      throw new WorkspaceReadOnlyError('ast_edit');\n    }\n\n    // Load ast-grep (cached after first call)\n    const astGrep = await loadAstGrep();\n    if (!astGrep) {\n      return '@ast-grep/napi is not available. Install it to use AST editing.';\n    }\n    const { parse, Lang } = astGrep;\n\n    // Read current content\n    let content: string | Buffer;\n    try {\n      content = await filesystem.readFile(path, { encoding: 'utf-8' });\n    } catch (error) {\n      if (error instanceof FileNotFoundError) {\n        return `File not found: ${path}. Use ${WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE} to create it first.`;\n      }\n      throw error;\n    }\n\n    if (typeof content !== 'string') {\n      return `Cannot perform AST edits on binary files. Use ${WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE} instead.`;\n    }\n\n    // Parse AST\n    const lang = getLanguageFromPath(path, Lang);\n    if (!lang) {\n      return `Unsupported file type for AST editing: ${path}`;\n    }\n    const ast = parse(lang, content);\n    const root = ast.root();\n\n    let modifiedContent = content;\n    const changes: string[] = [];\n\n    if (transform) {\n      switch (transform) {\n        case 'add-import': {\n          if (!importSpec) {\n            return 'Error: importSpec is required for add-import transform';\n          }\n          modifiedContent = addImport(content, root, importSpec);\n          changes.push(`Added import from '${importSpec.module}'`);\n          break;\n        }\n\n        case 'remove-import': {\n          if (!targetName) {\n            return 'Error: targetName is required for remove-import transform';\n          }\n          modifiedContent = removeImport(content, root, targetName);\n          changes.push(`Removed import '${targetName}'`);\n          break;\n        }\n\n        case 'rename': {\n          if (!targetName || !newName) {\n            return 'Error: targetName and newName are required for rename transform';\n          }\n          const renameResult = renameIdentifiers(content, root, targetName, newName);\n          modifiedContent = renameResult.content;\n          changes.push(`Renamed '${targetName}' to '${newName}' (${renameResult.count} occurrences)`);\n          break;\n        }\n      }\n    } else if (pattern && replacement !== undefined) {\n      const result = patternReplace(content, root, pattern, replacement);\n      if (result.error) {\n        return `Error: AST pattern matching failed: ${result.error}`;\n      }\n      modifiedContent = result.content;\n      changes.push(`Replaced ${result.count} occurrences of pattern`);\n    } else if (pattern && replacement === undefined) {\n      return 'Error: replacement is required when pattern is provided';\n    } else if (!pattern && replacement !== undefined) {\n      return 'Error: pattern is required when replacement is provided';\n    } else {\n      return 'Error: Must provide either transform or pattern/replacement';\n    }\n\n    // Write back if modified\n    const wasModified = modifiedContent !== content;\n    if (wasModified) {\n      await filesystem.writeFile(path, modifiedContent, { overwrite: true });\n    }\n\n    if (!wasModified) {\n      return `No changes made to ${path} (${changes.join('; ')})`;\n    }\n\n    let output = `${path}: ${changes.join('; ')}`;\n    output += await getEditDiagnosticsText(workspace, path, modifiedContent);\n    return output;\n  },\n});\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { WorkspaceReadOnlyError } from '../errors';\nimport { emitWorkspaceMetadata, requireFilesystem } from './helpers';\n\nexport const deleteFileTool = createTool({\n  id: WORKSPACE_TOOLS.FILESYSTEM.DELETE,\n  description: 'Delete a file or directory from the workspace filesystem',\n  inputSchema: z.object({\n    path: z.string().describe('The path to the file or directory to delete'),\n    recursive: z\n      .boolean()\n      .optional()\n      .default(false)\n      .describe('If true, delete directories and their contents recursively. Required for non-empty directories.'),\n  }),\n  execute: async ({ path, recursive }, context) => {\n    const { filesystem } = requireFilesystem(context);\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.FILESYSTEM.DELETE);\n\n    if (filesystem.readOnly) {\n      throw new WorkspaceReadOnlyError('delete');\n    }\n\n    const stat = await filesystem.stat(path);\n    if (stat.type === 'directory') {\n      await filesystem.rmdir(path, { recursive, force: recursive });\n    } else {\n      await filesystem.deleteFile(path);\n    }\n\n    return `Deleted ${path}`;\n  },\n});\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { WorkspaceReadOnlyError } from '../errors';\nimport { replaceString, StringNotFoundError, StringNotUniqueError } from '../line-utils';\nimport { emitWorkspaceMetadata, getEditDiagnosticsText, requireFilesystem } from './helpers';\n\nexport const editFileTool = createTool({\n  id: WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE,\n  description: `Edit a file by replacing specific text. The old_string must match exactly and be unique in the file.\n\nUsage:\n- Read the file first to get the exact text to replace.\n- By default, ${WORKSPACE_TOOLS.FILESYSTEM.READ_FILE} output includes line number prefixes (e.g., \"     1\"). Ensure you preserve the exact indentation as it appears AFTER the arrow. Never include any part of the line number prefix in old_string or new_string.\n- Include enough surrounding context (multiple lines) to make old_string unique. If it still isn't unique, include more lines.\n- Use replace_all only when intentionally replacing all occurrences.`,\n  inputSchema: z.object({\n    path: z.string().describe('The path to the file to edit'),\n    old_string: z.string().describe('The exact text to find and replace. Must be unique in the file.'),\n    new_string: z.string().describe('The text to replace old_string with'),\n    replace_all: z\n      .boolean()\n      .optional()\n      .default(false)\n      .describe('If true, replace all occurrences. If false (default), old_string must be unique.'),\n  }),\n  execute: async ({ path, old_string, new_string, replace_all }, context) => {\n    const { workspace, filesystem } = requireFilesystem(context);\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE);\n\n    if (filesystem.readOnly) {\n      throw new WorkspaceReadOnlyError('edit_file');\n    }\n\n    try {\n      const content = await filesystem.readFile(path, { encoding: 'utf-8' });\n\n      if (typeof content !== 'string') {\n        return `Cannot edit binary files. Use ${WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE} instead.`;\n      }\n\n      const result = replaceString(content, old_string, new_string, replace_all);\n      await filesystem.writeFile(path, result.content, { overwrite: true });\n\n      let output = `Replaced ${result.replacements} occurrence${result.replacements !== 1 ? 's' : ''} in ${path}`;\n      output += await getEditDiagnosticsText(workspace, path, result.content);\n      return output;\n    } catch (error) {\n      if (error instanceof StringNotFoundError) {\n        return error.message;\n      }\n      if (error instanceof StringNotUniqueError) {\n        return error.message;\n      }\n      throw error;\n    }\n  },\n});\n","/** Default number of lines to return (tail). */\nexport const DEFAULT_TAIL_LINES = 200;\n\n/** Hard character limit for tool output. Safety net on top of line-based tail. */\nexport const MAX_OUTPUT_CHARS = 30_000;\n\n/**\n * Return the last N lines of output, similar to `tail -n`.\n * - `n > 0`: last N lines\n * - `n === 0`: no limit (return all)\n * - `undefined/null`: use DEFAULT_TAIL_LINES\n */\nexport function applyTail(output: string, tail: number | null | undefined): string {\n  if (!output) return output;\n  const n = Math.abs(tail ?? DEFAULT_TAIL_LINES);\n  if (n === 0) return output; // 0 = no limit\n  // Strip trailing newline before splitting so it doesn't count as a line\n  const trailingNewline = output.endsWith('\\n');\n  const lines = (trailingNewline ? output.slice(0, -1) : output).split('\\n');\n  if (lines.length <= n) return output;\n  const sliced = lines.slice(-n).join('\\n');\n  const body = trailingNewline ? sliced + '\\n' : sliced;\n  return `[showing last ${n} of ${lines.length} lines]\\n${body}`;\n}\n\n/**\n * Hard character limit. Truncates from the start (keeps the end) and\n * prepends a notice so the agent knows data was lost.\n */\nexport function applyCharLimit(output: string, limit: number = MAX_OUTPUT_CHARS): string {\n  if (!output || output.length <= limit) return output;\n  const truncated = output.slice(-limit);\n  return `[output truncated: showing last ${limit} of ${output.length} characters]\\n${truncated}`;\n}\n\n/**\n * Apply both tail (line-based) and char limit (safety net) to output.\n */\nexport function truncateOutput(output: string, tail?: number | null, charLimit?: number): string {\n  return applyCharLimit(applyTail(output, tail), charLimit);\n}\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { SandboxFeatureNotSupportedError } from '../errors';\nimport { emitWorkspaceMetadata, requireSandbox } from './helpers';\nimport { DEFAULT_TAIL_LINES, truncateOutput } from './output-helpers';\n\n/**\n * Base input schema for execute_command (no background param).\n * Extended with `background` in tools.ts when sandbox.processes exists.\n */\nexport const executeCommandInputSchema = z.object({\n  command: z\n    .string()\n    .describe('The shell command to execute (e.g., \"npm install\", \"ls -la src/\", \"cat file.txt | grep error\")'),\n  timeout: z.number().nullish().describe('Maximum execution time in milliseconds. Example: 60000 for 1 minute.'),\n  cwd: z.string().nullish().describe('Working directory for the command'),\n  tail: z\n    .number()\n    .nullish()\n    .describe(\n      `For foreground commands: limit output to the last N lines, similar to tail -n. Defaults to ${DEFAULT_TAIL_LINES}. Use 0 for no limit.`,\n    ),\n});\n\n/** Schema with background param included. */\nexport const executeCommandWithBackgroundSchema = executeCommandInputSchema.extend({\n  background: z\n    .boolean()\n    .optional()\n    .describe(\n      'Run the command in the background. Returns a PID immediately instead of waiting for completion. Use get_process_output to check on it later.',\n    ),\n});\n\n/** Shared execute function used by both foreground-only and background-capable tool variants. */\nasync function executeCommand(input: Record<string, any>, context: any) {\n  const { command, timeout, cwd, tail } = input;\n  const background = input.background as boolean | undefined;\n  const { sandbox } = requireSandbox(context);\n\n  await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND);\n  const toolCallId = context?.agent?.toolCallId;\n\n  // Background mode: spawn via process manager and return immediately\n  if (background) {\n    if (!sandbox.processes) {\n      throw new SandboxFeatureNotSupportedError('processes');\n    }\n\n    const handle = await sandbox.processes.spawn(command, {\n      cwd: cwd ?? undefined,\n      timeout: timeout ?? undefined,\n    });\n\n    return `Started background process (PID: ${handle.pid})`;\n  }\n\n  // Foreground mode: execute and wait for completion\n  if (!sandbox.executeCommand) {\n    throw new SandboxFeatureNotSupportedError('executeCommand');\n  }\n\n  const startedAt = Date.now();\n  let stdout = '';\n  let stderr = '';\n  try {\n    const result = await sandbox.executeCommand(command, [], {\n      timeout: timeout ?? undefined,\n      cwd: cwd ?? undefined,\n      onStdout: async (data: string) => {\n        stdout += data;\n        await context?.writer?.custom({\n          type: 'data-sandbox-stdout',\n          data: { output: data, timestamp: Date.now(), toolCallId },\n        });\n      },\n      onStderr: async (data: string) => {\n        stderr += data;\n        await context?.writer?.custom({\n          type: 'data-sandbox-stderr',\n          data: { output: data, timestamp: Date.now(), toolCallId },\n        });\n      },\n    });\n\n    await context?.writer?.custom({\n      type: 'data-sandbox-exit',\n      data: {\n        exitCode: result.exitCode,\n        success: result.success,\n        executionTimeMs: result.executionTimeMs,\n        toolCallId,\n      },\n    });\n\n    if (!result.success) {\n      const parts = [truncateOutput(result.stdout, tail), truncateOutput(result.stderr, tail)].filter(Boolean);\n      parts.push(`Exit code: ${result.exitCode}`);\n      return parts.join('\\n');\n    }\n\n    return truncateOutput(result.stdout, tail) || '(no output)';\n  } catch (error) {\n    await context?.writer?.custom({\n      type: 'data-sandbox-exit',\n      data: {\n        exitCode: -1,\n        success: false,\n        executionTimeMs: Date.now() - startedAt,\n        toolCallId,\n      },\n    });\n    const parts = [truncateOutput(stdout, tail), truncateOutput(stderr, tail)].filter(Boolean);\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    parts.push(`Error: ${errorMessage}`);\n    return parts.join('\\n');\n  }\n}\n\nconst baseDescription = `Execute a shell command in the workspace sandbox.\n\nExamples:\n  \"npm install && npm run build\"\n  \"ls -la src/\"\n  \"cat config.json | jq '.database'\"\n  \"cd /app && python main.py\"\n\nUsage:\n- Commands run in a shell, so pipes, redirects, and chaining (&&, ||, ;) all work.\n- Always quote file paths that contain spaces (e.g., cd \"/path/with spaces\").\n- Use the timeout parameter to limit execution time. Behavior when omitted depends on the sandbox provider.\n- Optionally use cwd to override the working directory. Commands run from the sandbox default if omitted.`;\n\n/** Foreground-only tool (no background param in schema). */\nexport const executeCommandTool = createTool({\n  id: WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND,\n  description: baseDescription,\n  inputSchema: executeCommandInputSchema,\n  execute: executeCommand,\n});\n\n/** Tool with background param in schema (used when sandbox.processes exists). */\nexport const executeCommandWithBackgroundTool = createTool({\n  id: WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND,\n  description: `${baseDescription}\n\nSet background: true to run long-running commands (dev servers, watchers) without blocking. You'll get a PID to track the process.`,\n  inputSchema: executeCommandWithBackgroundSchema,\n  execute: executeCommand,\n});\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { FileNotFoundError } from '../errors';\nimport { emitWorkspaceMetadata, requireFilesystem } from './helpers';\n\nexport const fileStatTool = createTool({\n  id: WORKSPACE_TOOLS.FILESYSTEM.FILE_STAT,\n  description:\n    'Get file or directory metadata from the workspace. Returns existence, type, size, and modification time.',\n  inputSchema: z.object({\n    path: z.string().describe('The path to check'),\n  }),\n  execute: async ({ path }, context) => {\n    const { filesystem } = requireFilesystem(context);\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.FILESYSTEM.FILE_STAT);\n\n    try {\n      const stat = await filesystem.stat(path);\n      const modifiedAt = stat.modifiedAt.toISOString();\n\n      const parts = [`${path}`, `Type: ${stat.type}`];\n      if (stat.size !== undefined) parts.push(`Size: ${stat.size} bytes`);\n      parts.push(`Modified: ${modifiedAt}`);\n      return parts.join(' ');\n    } catch (error) {\n      if (error instanceof FileNotFoundError) {\n        return `${path}: not found`;\n      }\n      throw error;\n    }\n  },\n});\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { SandboxFeatureNotSupportedError } from '../errors';\nimport { emitWorkspaceMetadata, requireSandbox } from './helpers';\nimport { DEFAULT_TAIL_LINES, truncateOutput } from './output-helpers';\n\nexport const getProcessOutputTool = createTool({\n  id: WORKSPACE_TOOLS.SANDBOX.GET_PROCESS_OUTPUT,\n  description: `Get the current output (stdout, stderr) and status of a background process by its PID.\n\nUse this after starting a background command with execute_command (background: true) to check if the process is still running and read its output.`,\n  inputSchema: z.object({\n    pid: z.number().describe('The process ID returned when the background command was started'),\n    tail: z\n      .number()\n      .optional()\n      .describe(\n        `Number of lines to return, similar to tail -n. Positive or negative returns last N lines from end. Defaults to ${DEFAULT_TAIL_LINES}. Use 0 for no limit.`,\n      ),\n    wait: z\n      .boolean()\n      .optional()\n      .describe(\n        'If true, block until the process exits and return the final output. Useful for short-lived background commands where you want to wait for the result.',\n      ),\n  }),\n  execute: async ({ pid, tail, wait: shouldWait }, context) => {\n    const { sandbox } = requireSandbox(context);\n\n    if (!sandbox.processes) {\n      throw new SandboxFeatureNotSupportedError('processes');\n    }\n\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.SANDBOX.GET_PROCESS_OUTPUT);\n\n    const toolCallId = context?.agent?.toolCallId;\n\n    const handle = await sandbox.processes.get(pid);\n    if (!handle) {\n      return `No background process found with PID ${pid}.`;\n    }\n\n    // Emit process info so the UI can display the command\n    if (handle.command) {\n      await context?.writer?.custom({\n        type: 'data-sandbox-command',\n        data: { command: handle.command, pid, toolCallId },\n      });\n    }\n\n    // If wait requested, block until process exits with streaming callbacks\n    if (shouldWait && handle.exitCode === undefined) {\n      const result = await handle.wait({\n        onStdout: context?.writer\n          ? async (data: string) => {\n              await context.writer!.custom({\n                type: 'data-sandbox-stdout',\n                data: { output: data, timestamp: Date.now(), toolCallId },\n              });\n            }\n          : undefined,\n        onStderr: context?.writer\n          ? async (data: string) => {\n              await context.writer!.custom({\n                type: 'data-sandbox-stderr',\n                data: { output: data, timestamp: Date.now(), toolCallId },\n              });\n            }\n          : undefined,\n      });\n\n      await context?.writer?.custom({\n        type: 'data-sandbox-exit',\n        data: {\n          exitCode: result.exitCode,\n          success: result.success,\n          executionTimeMs: result.executionTimeMs,\n          toolCallId,\n        },\n      });\n    }\n\n    const running = handle.exitCode === undefined;\n\n    const stdout = truncateOutput(handle.stdout, tail);\n    const stderr = truncateOutput(handle.stderr, tail);\n\n    if (!stdout && !stderr) {\n      return '(no output yet)';\n    }\n\n    const parts: string[] = [];\n\n    // Only label stdout/stderr when both are present\n    if (stdout && stderr) {\n      parts.push('stdout:', stdout, '', 'stderr:', stderr);\n    } else if (stdout) {\n      parts.push(stdout);\n    } else {\n      parts.push('stderr:', stderr);\n    }\n\n    if (!running) {\n      parts.push('', `Exit code: ${handle.exitCode}`);\n    }\n\n    return parts.join('\\n');\n  },\n});\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { isTextFile } from '../filesystem/fs-utils';\nimport type { GlobMatcher } from '../glob';\nimport { createGlobMatcher, extractGlobBase, isGlobPattern } from '../glob';\nimport { emitWorkspaceMetadata, requireFilesystem } from './helpers';\n\nexport const grepTool = createTool({\n  id: WORKSPACE_TOOLS.FILESYSTEM.GREP,\n  description: `Search file contents using a regex pattern. Walks the filesystem and returns matching lines with file paths and line numbers.\n\nUsage:\n- Basic search: { pattern: \"TODO\" }\n- Regex: { pattern: \"function\\\\s+\\\\w+\\\\(\" }\n- Multiple terms: { pattern: \"TODO|FIXME|HACK\" }\n- Case-insensitive: { pattern: \"error\", caseSensitive: false }\n- Search in directory: { pattern: \"import\", path: \"./src\" }\n- Filter by glob: { pattern: \"import\", path: \"**/*.ts\" }\n- Combined path + glob: { pattern: \"import\", path: \"src/**/*.ts\" }\n- Multiple file types: { pattern: \"import\", path: \"**/*.{ts,tsx,js}\" }\n- Multiple directories: { pattern: \"TODO\", path: \"{src,lib}/**/*.ts\" }\n- With context: { pattern: \"function\", contextLines: 2 }`,\n  inputSchema: z.object({\n    pattern: z.string().describe('Regex pattern to search for'),\n    path: z\n      .string()\n      .optional()\n      .default('./')\n      .describe(\n        'File, directory, or glob pattern to search within (default: \"./\"). ' +\n          'A plain path searches that file or directory. ' +\n          'A glob pattern (e.g., \"**/*.ts\", \"src/**/*.test.ts\") filters which files to search.',\n      ),\n    contextLines: z\n      .number()\n      .optional()\n      .default(0)\n      .describe('Number of lines of context to include before and after each match (default: 0)'),\n    maxCount: z\n      .number()\n      .optional()\n      .describe(\n        'Maximum matches per file. Moves on to the next file after this many matches. Similar to grep -m flag.',\n      ),\n    caseSensitive: z\n      .boolean()\n      .optional()\n      .default(true)\n      .describe('Whether the search is case-sensitive (default: true)'),\n    includeHidden: z\n      .boolean()\n      .optional()\n      .default(false)\n      .describe('Include hidden files and directories (names starting with \".\") in the search (default: false)'),\n  }),\n  execute: async (\n    { pattern, path: inputPath = './', contextLines = 0, maxCount, caseSensitive = true, includeHidden = false },\n    context,\n  ) => {\n    const { filesystem } = requireFilesystem(context);\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.FILESYSTEM.GREP);\n\n    // Guard against excessively long patterns as a cheap ReDoS heuristic\n    const MAX_PATTERN_LENGTH = 1000;\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n      return `Error: Pattern too long (${pattern.length} chars, max ${MAX_PATTERN_LENGTH}). Use a shorter pattern.`;\n    }\n\n    // Validate regex\n    let regex: RegExp;\n    try {\n      regex = new RegExp(pattern, caseSensitive ? 'g' : 'gi');\n    } catch (e) {\n      return `Error: Invalid regex pattern: ${(e as Error).message}`;\n    }\n\n    // Determine search root and glob filter from the combined path parameter\n    let searchPath: string;\n    let globMatcher: GlobMatcher | undefined;\n\n    if (isGlobPattern(inputPath)) {\n      // Path contains glob characters  extract the static base as search root\n      searchPath = extractGlobBase(inputPath);\n      globMatcher = createGlobMatcher(inputPath, { dot: includeHidden });\n    } else {\n      searchPath = inputPath;\n    }\n\n    // Collect files to search\n    let filePaths: string[];\n\n    // Check if searchPath is a file or directory\n    try {\n      const stat = await filesystem.stat(searchPath);\n      if (stat.type === 'file') {\n        // Single file  search it directly\n        filePaths = isTextFile(searchPath) ? [searchPath] : [];\n      } else {\n        // Directory  walk recursively\n        const collectFiles = async (dir: string): Promise<string[]> => {\n          const files: string[] = [];\n          let entries;\n          try {\n            entries = await filesystem.readdir(dir);\n          } catch {\n            return files;\n          }\n\n          for (const entry of entries) {\n            // Skip hidden files/dirs unless includeHidden is set\n            if (!includeHidden && entry.name.startsWith('.')) continue;\n\n            const fullPath = dir.endsWith('/') ? `${dir}${entry.name}` : `${dir}/${entry.name}`;\n            if (entry.type === 'file') {\n              // Skip non-text files\n              if (!isTextFile(entry.name)) continue;\n              // Apply glob filter (createGlobMatcher normalizes leading slashes)\n              if (globMatcher && !globMatcher(fullPath)) continue;\n              files.push(fullPath);\n            } else if (entry.type === 'directory' && !entry.isSymlink) {\n              files.push(...(await collectFiles(fullPath)));\n            }\n          }\n          return files;\n        };\n        filePaths = await collectFiles(searchPath);\n      }\n    } catch {\n      // Path doesn't exist\n      filePaths = [];\n    }\n\n    const outputLines: string[] = [];\n    const filesWithMatches = new Set<string>();\n    let totalMatchCount = 0;\n    let truncated = false;\n    const MAX_LINE_LENGTH = 500;\n    const GLOBAL_CAP = 1000;\n\n    for (const filePath of filePaths) {\n      if (truncated) break;\n\n      let content: string;\n      try {\n        const raw = await filesystem.readFile(filePath, { encoding: 'utf-8' });\n        if (typeof raw !== 'string') continue;\n        content = raw;\n      } catch {\n        continue;\n      }\n\n      const lines = content.split('\\n');\n      let fileMatchCount = 0;\n\n      for (let i = 0; i < lines.length; i++) {\n        const currentLine = lines[i]!;\n        // Reset regex lastIndex for each line since we use 'g' flag\n        regex.lastIndex = 0;\n        const lineMatch = regex.exec(currentLine);\n        if (!lineMatch) continue;\n\n        filesWithMatches.add(filePath);\n\n        let lineContent = currentLine;\n        if (lineContent.length > MAX_LINE_LENGTH) {\n          lineContent = lineContent.slice(0, MAX_LINE_LENGTH) + '...';\n        }\n\n        // Add context lines before the match\n        if (contextLines > 0) {\n          const beforeStart = Math.max(0, i - contextLines);\n          for (let b = beforeStart; b < i; b++) {\n            outputLines.push(`${filePath}:${b + 1}- ${lines[b]}`);\n          }\n        }\n\n        // Add the matching line\n        outputLines.push(`${filePath}:${i + 1}:${lineMatch.index + 1}: ${lineContent}`);\n\n        // Add context lines after the match\n        if (contextLines > 0) {\n          const afterEnd = Math.min(lines.length - 1, i + contextLines);\n          for (let a = i + 1; a <= afterEnd; a++) {\n            outputLines.push(`${filePath}:${a + 1}- ${lines[a]}`);\n          }\n          // Separator between context groups\n          outputLines.push('--');\n        }\n\n        totalMatchCount++;\n        fileMatchCount++;\n\n        // Per-file limit (like grep -m)\n        if (maxCount !== undefined && fileMatchCount >= maxCount) break;\n\n        // Global cap to protect context window\n        if (totalMatchCount >= GLOBAL_CAP) {\n          truncated = true;\n          break;\n        }\n      }\n    }\n\n    // Summary line\n    outputLines.push('---');\n    const parts = [`${totalMatchCount} match${totalMatchCount !== 1 ? 'es' : ''}`];\n    parts.push(`across ${filesWithMatches.size} file${filesWithMatches.size !== 1 ? 's' : ''}`);\n    if (truncated) {\n      parts.push(`(truncated at ${GLOBAL_CAP})`);\n    }\n    outputLines.push(parts.join(' '));\n\n    return outputLines.join('\\n');\n  },\n});\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { emitWorkspaceMetadata, requireWorkspace } from './helpers';\n\nexport const indexContentTool = createTool({\n  id: WORKSPACE_TOOLS.SEARCH.INDEX,\n  description: 'Index content for search. The path becomes the document ID in search results.',\n  inputSchema: z.object({\n    path: z.string().describe('The document ID/path for search results'),\n    content: z.string().describe('The text content to index'),\n    metadata: z.record(z.unknown()).optional().describe('Optional metadata to store with the document'),\n  }),\n  execute: async ({ path, content, metadata }, context) => {\n    const workspace = requireWorkspace(context);\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.SEARCH.INDEX);\n\n    await workspace.index(path, content, { metadata });\n    return `Indexed ${path}`;\n  },\n});\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { SandboxFeatureNotSupportedError } from '../errors';\nimport { emitWorkspaceMetadata, requireSandbox } from './helpers';\nimport { truncateOutput } from './output-helpers';\n\nconst KILL_TAIL_LINES = 50;\n\nexport const killProcessTool = createTool({\n  id: WORKSPACE_TOOLS.SANDBOX.KILL_PROCESS,\n  description: `Kill a background process by its PID.\n\nUse this to stop a long-running background process that was started with execute_command (background: true). Returns the last ${KILL_TAIL_LINES} lines of output.`,\n  inputSchema: z.object({\n    pid: z.number().describe('The process ID of the background process to kill'),\n  }),\n  execute: async ({ pid }, context) => {\n    const { sandbox } = requireSandbox(context);\n\n    if (!sandbox.processes) {\n      throw new SandboxFeatureNotSupportedError('processes');\n    }\n\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.SANDBOX.KILL_PROCESS);\n    const toolCallId = context?.agent?.toolCallId;\n\n    // Snapshot output before kill\n    const handle = await sandbox.processes.get(pid);\n\n    // Emit command info so the UI can display the original command\n    if (handle?.command) {\n      await context?.writer?.custom({\n        type: 'data-sandbox-command',\n        data: { command: handle.command, pid, toolCallId },\n      });\n    }\n\n    const killed = await sandbox.processes.kill(pid);\n\n    if (!killed) {\n      await context?.writer?.custom({\n        type: 'data-sandbox-exit',\n        data: { exitCode: handle?.exitCode ?? -1, success: false, killed: false, toolCallId },\n      });\n      return `Process ${pid} was not found or had already exited.`;\n    }\n\n    await context?.writer?.custom({\n      type: 'data-sandbox-exit',\n      data: { exitCode: handle?.exitCode ?? 137, success: false, killed: true, toolCallId },\n    });\n\n    const parts: string[] = [`Process ${pid} has been killed.`];\n\n    if (handle) {\n      const stdout = handle.stdout ? truncateOutput(handle.stdout, KILL_TAIL_LINES) : '';\n      const stderr = handle.stderr ? truncateOutput(handle.stderr, KILL_TAIL_LINES) : '';\n\n      if (stdout) {\n        parts.push('', '--- stdout (last output) ---', stdout);\n      }\n      if (stderr) {\n        parts.push('', '--- stderr (last output) ---', stderr);\n      }\n    }\n\n    return parts.join('\\n');\n  },\n});\n","/**\n * Tree Formatter\n *\n * Formats directory structures as ASCII tree output.\n * Works with any WorkspaceFilesystem implementation.\n *\n * @example\n * ```typescript\n * import { formatAsTree } from './tree-formatter';\n *\n * const result = await formatAsTree(filesystem, '/', { maxDepth: 3 });\n * console.log(result.tree);\n * // .\n * //  src\n * //     index.ts\n * //     utils\n * //         helpers.ts\n * //  package.json\n * console.log(result.summary);\n * // \"2 directories, 3 files\"\n * ```\n */\n\nimport type { WorkspaceFilesystem, FileEntry } from '../filesystem';\nimport { createGlobMatcher } from '../glob';\nimport type { GlobMatcher } from '../glob';\n\n// =============================================================================\n// Types\n// =============================================================================\n\nexport interface TreeOptions {\n  /** Maximum recursion depth (default: Infinity). Similar to tree's -L flag. */\n  maxDepth?: number;\n  /** Show hidden files/directories starting with '.' (default: false). Similar to tree's -a flag. */\n  showHidden?: boolean;\n  /** List directories only, no files (default: false). Similar to tree's -d flag. */\n  dirsOnly?: boolean;\n  /** Pattern to exclude from listing (e.g., 'node_modules'). Similar to tree's -I flag. */\n  exclude?: string | string[];\n  /** Filter by file extension (e.g., '.ts'). Similar to tree's -P flag. */\n  extension?: string | string[];\n  /** Glob pattern(s) to filter files. Matches against paths relative to the listed directory. Directories always pass through so their contents can be checked. */\n  pattern?: string | string[];\n}\n\nexport interface TreeResult {\n  /** ASCII tree representation */\n  tree: string;\n  /** Human-readable summary (e.g., \"3 directories, 12 files\") */\n  summary: string;\n  /** Number of directories found */\n  dirCount: number;\n  /** Number of files found */\n  fileCount: number;\n  /** Whether output was truncated due to maxDepth */\n  truncated: boolean;\n}\n\n// =============================================================================\n// Constants\n// =============================================================================\n\nconst BRANCH = ' ';\nconst LAST_BRANCH = ' ';\nconst VERTICAL = '   ';\nconst SPACE = '    ';\n\n// =============================================================================\n// Tree Formatting\n// =============================================================================\n\n/**\n * Format a directory as an ASCII tree.\n *\n * @param fs - WorkspaceFilesystem implementation\n * @param path - Root path to format\n * @param options - Formatting options\n * @returns Tree result with formatted string and counts\n */\nexport async function formatAsTree(fs: WorkspaceFilesystem, path: string, options?: TreeOptions): Promise<TreeResult> {\n  const maxDepth = options?.maxDepth ?? Infinity;\n  const showHidden = options?.showHidden ?? false;\n  const dirsOnly = options?.dirsOnly ?? false;\n  const exclude = options?.exclude;\n  const extension = options?.extension;\n  const pattern = options?.pattern;\n\n  // Compile glob matcher once before the walk (if pattern provided)\n  let globMatcher: GlobMatcher | undefined;\n  if (pattern) {\n    const patterns = Array.isArray(pattern) ? pattern : [pattern];\n    globMatcher = createGlobMatcher(patterns, { dot: showHidden });\n  }\n\n  const lines: string[] = ['.'];\n  let dirCount = 0;\n  let fileCount = 0;\n  let truncated = false;\n\n  /**\n   * Build tree recursively\n   */\n  async function buildTree(currentPath: string, prefix: string, depth: number): Promise<void> {\n    if (depth >= maxDepth) {\n      truncated = true;\n      return;\n    }\n\n    let entries: FileEntry[];\n    try {\n      entries = await fs.readdir(currentPath);\n    } catch (error) {\n      // At root level (depth 0), propagate errors so users see auth/access issues\n      // For subdirectories, silently skip (permission issues on nested dirs are common)\n      if (depth === 0) {\n        throw error;\n      }\n      return;\n    }\n\n    // Filter entries\n    let filtered = entries;\n\n    // Filter hidden files unless showHidden\n    if (!showHidden) {\n      filtered = filtered.filter(e => !e.name.startsWith('.'));\n    }\n\n    // Filter by exclude pattern (like tree's -I flag)\n    if (exclude) {\n      const patterns = Array.isArray(exclude) ? exclude : [exclude];\n      filtered = filtered.filter(e => {\n        return !patterns.some(pattern => e.name.includes(pattern));\n      });\n    }\n\n    // Filter to directories only (like tree's -d flag)\n    if (dirsOnly) {\n      filtered = filtered.filter(e => e.type === 'directory');\n    }\n\n    // Filter by extension (only affects files, directories always pass)\n    if (extension && !dirsOnly) {\n      const extensions = Array.isArray(extension) ? extension : [extension];\n      filtered = filtered.filter(e => {\n        if (e.type === 'directory') return true;\n        return extensions.some(ext => {\n          // Support both '.ts' and 'ts' formats\n          const normalizedExt = ext.startsWith('.') ? ext : `.${ext}`;\n          return e.name.endsWith(normalizedExt);\n        });\n      });\n    }\n\n    // Filter by glob pattern (only affects files, directories always pass)\n    if (globMatcher && !dirsOnly) {\n      filtered = filtered.filter(e => {\n        if (e.type === 'directory') return true;\n        // Build relative path from the root of the tree walk\n        const entryPath = currentPath === path ? e.name : `${currentPath === '/' ? '' : currentPath}/${e.name}`;\n        // Strip the root path prefix to make it relative\n        let relativePath: string;\n        if (path === '/' || path === '') {\n          relativePath = entryPath.startsWith('/') ? entryPath.slice(1) : entryPath;\n        } else {\n          relativePath = entryPath.startsWith(path + '/') ? entryPath.slice(path.length + 1) : entryPath;\n          // If entryPath starts with path but no slash (shouldn't happen), fall back\n          if (!relativePath) relativePath = entryPath;\n        }\n        return globMatcher!(relativePath);\n      });\n    }\n\n    // Sort: directories first, then alphabetically (ASCII order to match native tree's strcmp)\n    filtered.sort((a, b) => {\n      if (a.type === 'directory' && b.type !== 'directory') return -1;\n      if (a.type !== 'directory' && b.type === 'directory') return 1;\n      return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;\n    });\n\n    for (let i = 0; i < filtered.length; i++) {\n      const entry = filtered[i]!;\n      const isLast = i === filtered.length - 1;\n      const connector = isLast ? LAST_BRANCH : BRANCH;\n      const childPrefix = prefix + (isLast ? SPACE : VERTICAL);\n\n      // Format entry name, including symlink target if present\n      const displayName =\n        entry.isSymlink && entry.symlinkTarget ? `${entry.name} -> ${entry.symlinkTarget}` : entry.name;\n\n      lines.push(prefix + connector + displayName);\n\n      if (entry.type === 'directory') {\n        dirCount++;\n        // Don't recurse into symlinks (matches native tree behavior)\n        // This also prevents infinite loops from circular symlinks\n        if (!entry.isSymlink) {\n          const childPath = joinPath(currentPath, entry.name);\n          await buildTree(childPath, childPrefix, depth + 1);\n        }\n      } else {\n        fileCount++;\n      }\n    }\n  }\n\n  await buildTree(path, '', 0);\n\n  // Build summary\n  const dirPart = dirCount === 1 ? '1 directory' : `${dirCount} directories`;\n  const filePart = fileCount === 1 ? '1 file' : `${fileCount} files`;\n  let summary = `${dirPart}, ${filePart}`;\n  if (truncated) {\n    summary += ` (truncated at depth ${maxDepth})`;\n  }\n\n  return {\n    tree: lines.join('\\n'),\n    summary,\n    dirCount,\n    fileCount,\n    truncated,\n  };\n}\n\n/**\n * Format entries directly (without filesystem access).\n * Useful when you already have the entries and want tree output.\n *\n * @param entries - Flat list of entries with path-like names (e.g., \"dir/subdir/file.txt\")\n * @returns Formatted tree string\n */\nexport function formatEntriesAsTree(entries: Array<{ name: string; type: 'file' | 'directory' }>): string {\n  // Build a nested structure from flat paths\n  interface TreeNode {\n    name: string;\n    type: 'file' | 'directory';\n    children: Map<string, TreeNode>;\n  }\n\n  const root: TreeNode = { name: '.', type: 'directory', children: new Map() };\n\n  for (const entry of entries) {\n    const parts = entry.name.split('/');\n    let current = root;\n\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i]!;\n      const isLastPart = i === parts.length - 1;\n\n      if (!current.children.has(part)) {\n        current.children.set(part, {\n          name: part,\n          type: isLastPart ? entry.type : 'directory',\n          children: new Map(),\n        });\n      }\n      current = current.children.get(part)!;\n    }\n  }\n\n  // Render tree\n  const lines: string[] = ['.'];\n\n  function renderNode(node: TreeNode, prefix: string): void {\n    const children = Array.from(node.children.values());\n    // Sort: directories first, then alphabetically (ASCII order to match native tree's strcmp)\n    children.sort((a, b) => {\n      if (a.type === 'directory' && b.type !== 'directory') return -1;\n      if (a.type !== 'directory' && b.type === 'directory') return 1;\n      return a.name < b.name ? -1 : a.name > b.name ? 1 : 0;\n    });\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i]!;\n      const isLast = i === children.length - 1;\n      const connector = isLast ? LAST_BRANCH : BRANCH;\n      const childPrefix = prefix + (isLast ? SPACE : VERTICAL);\n\n      lines.push(prefix + connector + child.name);\n\n      if (child.children.size > 0) {\n        renderNode(child, childPrefix);\n      }\n    }\n  }\n\n  renderNode(root, '');\n  return lines.join('\\n');\n}\n\n// =============================================================================\n// Helpers\n// =============================================================================\n\n/**\n * Join path segments, handling root paths correctly\n */\nfunction joinPath(base: string, name: string): string {\n  if (base === '/' || base === '') {\n    return `/${name}`;\n  }\n  return `${base}/${name}`;\n}\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { emitWorkspaceMetadata, requireFilesystem } from './helpers';\nimport { formatAsTree } from './tree-formatter';\n\nexport const listFilesTool = createTool({\n  id: WORKSPACE_TOOLS.FILESYSTEM.LIST_FILES,\n  description: `List files and directories in the workspace filesystem.\nReturns a tree-style view (like the Unix \"tree\" command) for easy visualization.\nThe output is displayed to the user as a tree-like structure in the tool result.\nOptions mirror common tree command flags for familiarity.\n\nExamples:\n- List root: { path: \"./\" }\n- Deep listing: { path: \"./src\", maxDepth: 5 }\n- Directories only: { path: \"./\", dirsOnly: true }\n- Exclude node_modules: { path: \"./\", exclude: \"node_modules\" }\n- Find TypeScript files: { path: \"./src\", pattern: \"**/*.ts\" }\n- Find config files: { path: \"./\", pattern: \"*.config.{js,ts}\" }\n- Multiple patterns: { path: \"./\", pattern: [\"**/*.ts\", \"**/*.tsx\"] }`,\n  inputSchema: z.object({\n    path: z.string().default('./').describe('Directory path to list'),\n    maxDepth: z\n      .number()\n      .optional()\n      .default(3)\n      .describe('Maximum depth to descend (default: 3). Similar to tree -L flag.'),\n    showHidden: z\n      .boolean()\n      .optional()\n      .default(false)\n      .describe('Show hidden files starting with \".\" (default: false). Similar to tree -a flag.'),\n    dirsOnly: z\n      .boolean()\n      .optional()\n      .default(false)\n      .describe('List directories only, no files (default: false). Similar to tree -d flag.'),\n    exclude: z.string().optional().describe('Pattern to exclude (e.g., \"node_modules\"). Similar to tree -I flag.'),\n    extension: z.string().optional().describe('Filter by file extension (e.g., \".ts\"). Similar to tree -P flag.'),\n    pattern: z\n      .union([z.string(), z.array(z.string())])\n      .optional()\n      .describe(\n        'Glob pattern(s) to filter files. Examples: \"**/*.ts\", \"src/**/*.test.ts\", \"*.config.{js,ts}\". Directories always pass through.',\n      ),\n  }),\n  execute: async ({ path = './', maxDepth = 3, showHidden, dirsOnly, exclude, extension, pattern }, context) => {\n    const { filesystem } = requireFilesystem(context);\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.FILESYSTEM.LIST_FILES);\n\n    const result = await formatAsTree(filesystem, path, {\n      maxDepth,\n      showHidden,\n      dirsOnly,\n      exclude: exclude || undefined,\n      extension: extension || undefined,\n      pattern: pattern || undefined,\n    });\n\n    return `${result.tree}\\n\\n${result.summary}`;\n  },\n});\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { WorkspaceReadOnlyError } from '../errors';\nimport { emitWorkspaceMetadata, requireFilesystem } from './helpers';\n\nexport const mkdirTool = createTool({\n  id: WORKSPACE_TOOLS.FILESYSTEM.MKDIR,\n  description: 'Create a directory in the workspace filesystem',\n  inputSchema: z.object({\n    path: z.string().describe('The path of the directory to create'),\n    recursive: z\n      .boolean()\n      .optional()\n      .default(true)\n      .describe('Whether to create parent directories if they do not exist'),\n  }),\n  execute: async ({ path, recursive }, context) => {\n    const { filesystem } = requireFilesystem(context);\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.FILESYSTEM.MKDIR);\n\n    if (filesystem.readOnly) {\n      throw new WorkspaceReadOnlyError('mkdir');\n    }\n\n    await filesystem.mkdir(path, { recursive });\n    return `Created directory ${path}`;\n  },\n});\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { extractLinesWithLimit, formatWithLineNumbers } from '../line-utils';\nimport { emitWorkspaceMetadata, requireFilesystem } from './helpers';\n\nexport const readFileTool = createTool({\n  id: WORKSPACE_TOOLS.FILESYSTEM.READ_FILE,\n  description:\n    'Read the contents of a file from the workspace filesystem. Use offset/limit parameters to read specific line ranges for large files.',\n  inputSchema: z.object({\n    path: z.string().describe('The path to the file to read (e.g., \"/data/config.json\")'),\n    encoding: z\n      .enum(['utf-8', 'utf8', 'base64', 'hex', 'binary'])\n      .optional()\n      .describe('The encoding to use when reading the file. Defaults to utf-8 for text files.'),\n    offset: z\n      .number()\n      .optional()\n      .describe('Line number to start reading from (1-indexed). If omitted, starts from line 1.'),\n    limit: z.number().optional().describe('Maximum number of lines to read. If omitted, reads to the end of the file.'),\n    showLineNumbers: z\n      .boolean()\n      .optional()\n      .default(true)\n      .describe('Whether to prefix each line with its line number (default: true)'),\n  }),\n  execute: async ({ path, encoding, offset, limit, showLineNumbers }, context) => {\n    const { filesystem } = requireFilesystem(context);\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.FILESYSTEM.READ_FILE);\n\n    const effectiveEncoding = (encoding as BufferEncoding) ?? 'utf-8';\n    const fullContent = await filesystem.readFile(path, { encoding: effectiveEncoding });\n    const stat = await filesystem.stat(path);\n\n    const isTextEncoding = !encoding || encoding === 'utf-8' || encoding === 'utf8';\n\n    if (!isTextEncoding) {\n      return `${stat.path} (${stat.size} bytes, ${effectiveEncoding})\\n${fullContent}`;\n    }\n\n    if (typeof fullContent !== 'string') {\n      return `${stat.path} (${stat.size} bytes, base64)\\n${fullContent.toString('base64')}`;\n    }\n\n    const hasLineRange = offset !== undefined || limit !== undefined;\n    const result = extractLinesWithLimit(fullContent, offset, limit);\n\n    const shouldShowLineNumbers = showLineNumbers !== false;\n    const formattedContent = shouldShowLineNumbers\n      ? formatWithLineNumbers(result.content, result.lines.start)\n      : result.content;\n\n    let header: string;\n    if (hasLineRange) {\n      header = `${stat.path} (lines ${result.lines.start}-${result.lines.end} of ${result.totalLines}, ${stat.size} bytes)`;\n    } else {\n      header = `${stat.path} (${stat.size} bytes)`;\n    }\n\n    return `${header}\\n${formattedContent}`;\n  },\n});\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { emitWorkspaceMetadata, requireWorkspace } from './helpers';\n\nexport const searchTool = createTool({\n  id: WORKSPACE_TOOLS.SEARCH.SEARCH,\n  description:\n    'Search indexed content in the workspace. Supports keyword (BM25), semantic (vector), and hybrid search modes.',\n  inputSchema: z.object({\n    query: z.string().describe('The search query string'),\n    topK: z.number().optional().default(5).describe('Maximum number of results to return'),\n    mode: z\n      .enum(['bm25', 'vector', 'hybrid'])\n      .optional()\n      .describe('Search mode: bm25 for keyword search, vector for semantic search, hybrid for both combined'),\n    minScore: z.number().optional().describe('Minimum score threshold (0-1 for normalized scores)'),\n  }),\n  execute: async ({ query, topK, mode, minScore }, context) => {\n    const workspace = requireWorkspace(context);\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.SEARCH.SEARCH);\n\n    const results = await workspace.search(query, {\n      topK,\n      mode: mode as 'bm25' | 'vector' | 'hybrid' | undefined,\n      minScore,\n    });\n\n    const effectiveMode = mode ?? (workspace.canHybrid ? 'hybrid' : workspace.canVector ? 'vector' : 'bm25');\n\n    const lines = results.map(r => {\n      const lineInfo = r.lineRange ? `:${r.lineRange.start}-${r.lineRange.end}` : '';\n      return `${r.id}${lineInfo}: ${r.content}`;\n    });\n\n    lines.push('---');\n    lines.push(`${results.length} result${results.length !== 1 ? 's' : ''} (${effectiveMode} search)`);\n\n    return lines.join('\\n');\n  },\n});\n","import { z } from 'zod';\nimport { createTool } from '../../tools';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { WorkspaceReadOnlyError } from '../errors';\nimport { emitWorkspaceMetadata, getEditDiagnosticsText, requireFilesystem } from './helpers';\n\nexport const writeFileTool = createTool({\n  id: WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE,\n  description: 'Write content to a file in the workspace filesystem. Creates parent directories if needed.',\n  inputSchema: z.object({\n    path: z.string().describe('The path where to write the file (e.g., \"/data/output.txt\")'),\n    content: z.string().describe('The content to write to the file'),\n    overwrite: z.boolean().optional().default(true).describe('Whether to overwrite the file if it already exists'),\n  }),\n  execute: async ({ path, content, overwrite }, context) => {\n    const { workspace, filesystem } = requireFilesystem(context);\n    await emitWorkspaceMetadata(context, WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE);\n\n    if (filesystem.readOnly) {\n      throw new WorkspaceReadOnlyError('write_file');\n    }\n\n    await filesystem.writeFile(path, content, { overwrite });\n\n    const size = Buffer.byteLength(content, 'utf-8');\n    let output = `Wrote ${size} bytes to ${path}`;\n    output += await getEditDiagnosticsText(workspace, path, content);\n    return output;\n  },\n});\n","/**\n * Workspace Tools  Factory\n *\n * Creates the built-in workspace tools for agents. Individual tools are\n * defined in their own files; this module applies WorkspaceToolsConfig\n * (enabled, requireApproval, requireReadBeforeWrite) and injects workspace\n * into the tool execution context.\n */\n\nimport type { WorkspaceToolName } from '../constants';\nimport { WORKSPACE_TOOLS } from '../constants';\nimport { FileNotFoundError, FileReadRequiredError } from '../errors';\nimport { InMemoryFileReadTracker, InMemoryFileWriteLock } from '../filesystem';\nimport type { FileReadTracker, FileWriteLock } from '../filesystem';\nimport type { Workspace } from '../workspace';\nimport { isAstGrepAvailable, astEditTool } from './ast-edit';\nimport { deleteFileTool } from './delete-file';\nimport { editFileTool } from './edit-file';\nimport { executeCommandTool, executeCommandWithBackgroundTool } from './execute-command';\nimport { fileStatTool } from './file-stat';\nimport { getProcessOutputTool } from './get-process-output';\nimport { grepTool } from './grep';\nimport { indexContentTool } from './index-content';\nimport { killProcessTool } from './kill-process';\nimport { listFilesTool } from './list-files';\nimport { mkdirTool } from './mkdir';\nimport { readFileTool } from './read-file';\nimport { searchTool } from './search';\nimport type { WorkspaceToolsConfig } from './types';\nimport { writeFileTool } from './write-file';\n\n/**\n * Resolves the effective configuration for a specific tool.\n *\n * Resolution order (later overrides earlier):\n * 1. Built-in defaults (enabled: true, requireApproval: false)\n * 2. Top-level config (tools.enabled, tools.requireApproval)\n * 3. Per-tool config (tools[toolName].enabled, tools[toolName].requireApproval)\n */\nexport function resolveToolConfig(\n  toolsConfig: WorkspaceToolsConfig | undefined,\n  toolName: WorkspaceToolName,\n): { enabled: boolean; requireApproval: boolean; requireReadBeforeWrite?: boolean } {\n  let enabled = true;\n  let requireApproval = false;\n  let requireReadBeforeWrite: boolean | undefined;\n\n  if (toolsConfig) {\n    if (toolsConfig.enabled !== undefined) {\n      enabled = toolsConfig.enabled;\n    }\n    if (toolsConfig.requireApproval !== undefined) {\n      requireApproval = toolsConfig.requireApproval;\n    }\n\n    const perToolConfig = toolsConfig[toolName];\n    if (perToolConfig) {\n      if (perToolConfig.enabled !== undefined) {\n        enabled = perToolConfig.enabled;\n      }\n      if (perToolConfig.requireApproval !== undefined) {\n        requireApproval = perToolConfig.requireApproval;\n      }\n      if (perToolConfig.requireReadBeforeWrite !== undefined) {\n        requireReadBeforeWrite = perToolConfig.requireReadBeforeWrite;\n      }\n    }\n  }\n\n  return { enabled, requireApproval, requireReadBeforeWrite };\n}\n\n// ---------------------------------------------------------------------------\n// Wrapper helpers\n// ---------------------------------------------------------------------------\n\n/**\n * Clone a standalone tool with config overrides and inject workspace into context.\n */\nfunction wrapTool(tool: any, workspace: Workspace, config: { requireApproval: boolean }): any {\n  return {\n    ...tool,\n    requireApproval: config.requireApproval,\n    execute: async (input: any, context: any = {}) => {\n      const enrichedContext = { ...context, workspace: context?.workspace ?? workspace };\n      return tool.execute(input, enrichedContext);\n    },\n  };\n}\n\n/**\n * Wrap a tool with read-before-write tracking (readTracker).\n *\n * - mode 'read': records the read after execution\n * - mode 'write': checks before execution, clears after\n */\nfunction wrapWithReadTracker(\n  tool: any,\n  workspace: Workspace,\n  readTracker: FileReadTracker,\n  config: { requireApproval: boolean; requireReadBeforeWrite?: boolean },\n  mode: 'read' | 'write',\n): any {\n  return {\n    ...tool,\n    requireApproval: config.requireApproval,\n    execute: async (input: any, context: any = {}) => {\n      const enrichedContext = { ...context, workspace: context?.workspace ?? workspace };\n\n      // Pre-execution: check read-before-write for write tools\n      if (mode === 'write' && config.requireReadBeforeWrite) {\n        try {\n          const stat = await workspace.filesystem!.stat(input.path);\n          const check = readTracker.needsReRead(input.path, stat.modifiedAt);\n          if (check.needsReRead) {\n            throw new FileReadRequiredError(input.path, check.reason!);\n          }\n        } catch (error) {\n          if (!(error instanceof FileNotFoundError)) {\n            throw error;\n          }\n          // New file  no read required\n        }\n      }\n\n      const result = await tool.execute(input, enrichedContext);\n\n      // Post-execution: track reads / clear write records\n      if (mode === 'read') {\n        try {\n          const stat = await workspace.filesystem!.stat(input.path);\n          readTracker.recordRead(input.path, stat.modifiedAt);\n        } catch {\n          // Ignore stat errors for tracking\n        }\n      } else if (mode === 'write') {\n        readTracker.clearReadRecord(input.path);\n      }\n\n      return result;\n    },\n  };\n}\n\n/**\n * Wrap a tool with a per-file write lock.\n *\n * The lock serializes the entire execute pipeline (including any\n * read-before-write checks) so concurrent calls to the same path\n * run one at a time.\n */\nfunction wrapWithWriteLock(tool: any, writeLock: FileWriteLock): any {\n  return {\n    ...tool,\n    execute: async (input: any, context: any = {}) => {\n      if (!input.path) {\n        throw new Error('wrapWithWriteLock: input.path is required');\n      }\n      return writeLock.withLock(input.path, () => tool.execute(input, context));\n    },\n  };\n}\n\n// ---------------------------------------------------------------------------\n// Factory\n// ---------------------------------------------------------------------------\n\n/**\n * Creates workspace tools that will be auto-injected into agents.\n *\n * @param workspace - The workspace instance to bind tools to\n * @returns Record of workspace tools\n */\nexport function createWorkspaceTools(workspace: Workspace) {\n  const tools: Record<string, any> = {};\n  const toolsConfig = workspace.getToolsConfig();\n  const isReadOnly = workspace.filesystem?.readOnly ?? false;\n\n  // Shared write lock  serializes concurrent writes to the same file path\n  const writeLock: FileWriteLock = new InMemoryFileWriteLock();\n\n  // Shared read tracker for requireReadBeforeWrite\n  let readTracker: FileReadTracker | undefined;\n  const writeFileConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE);\n  const editFileConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE);\n  const astEditConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.FILESYSTEM.AST_EDIT);\n  if (\n    writeFileConfig.requireReadBeforeWrite ||\n    editFileConfig.requireReadBeforeWrite ||\n    astEditConfig.requireReadBeforeWrite\n  ) {\n    readTracker = new InMemoryFileReadTracker();\n  }\n\n  // Helper: add a tool with config-driven filtering\n  const addTool = (\n    name: WorkspaceToolName,\n    tool: any,\n    opts?: { requireWrite?: boolean; readTrackerMode?: 'read' | 'write'; useWriteLock?: boolean },\n  ) => {\n    const config = resolveToolConfig(toolsConfig, name);\n    if (!config.enabled) return;\n    if (opts?.requireWrite && isReadOnly) return;\n\n    let wrapped: any;\n    if (readTracker && opts?.readTrackerMode) {\n      wrapped = wrapWithReadTracker(tool, workspace, readTracker, config, opts.readTrackerMode);\n    } else {\n      wrapped = wrapTool(tool, workspace, config);\n    }\n\n    // Write lock is outermost  serializes the entire enriched execute pipeline\n    if (opts?.useWriteLock) {\n      wrapped = wrapWithWriteLock(wrapped, writeLock);\n    }\n\n    tools[name] = wrapped;\n  };\n\n  // Filesystem tools\n  if (workspace.filesystem) {\n    addTool(WORKSPACE_TOOLS.FILESYSTEM.READ_FILE, readFileTool, { readTrackerMode: 'read' });\n    addTool(WORKSPACE_TOOLS.FILESYSTEM.WRITE_FILE, writeFileTool, {\n      requireWrite: true,\n      readTrackerMode: 'write',\n      useWriteLock: true,\n    });\n    addTool(WORKSPACE_TOOLS.FILESYSTEM.EDIT_FILE, editFileTool, {\n      requireWrite: true,\n      readTrackerMode: 'write',\n      useWriteLock: true,\n    });\n    addTool(WORKSPACE_TOOLS.FILESYSTEM.LIST_FILES, listFilesTool);\n    addTool(WORKSPACE_TOOLS.FILESYSTEM.DELETE, deleteFileTool, { requireWrite: true, useWriteLock: true });\n    addTool(WORKSPACE_TOOLS.FILESYSTEM.FILE_STAT, fileStatTool);\n    addTool(WORKSPACE_TOOLS.FILESYSTEM.MKDIR, mkdirTool, { requireWrite: true });\n    addTool(WORKSPACE_TOOLS.FILESYSTEM.GREP, grepTool);\n\n    // AST edit tool (only if @ast-grep/napi is available at runtime)\n    if (isAstGrepAvailable()) {\n      addTool(WORKSPACE_TOOLS.FILESYSTEM.AST_EDIT, astEditTool, {\n        requireWrite: true,\n        readTrackerMode: 'write',\n        useWriteLock: true,\n      });\n    }\n  }\n\n  // Search tools\n  if (workspace.canBM25 || workspace.canVector) {\n    addTool(WORKSPACE_TOOLS.SEARCH.SEARCH, searchTool);\n    addTool(WORKSPACE_TOOLS.SEARCH.INDEX, indexContentTool, { requireWrite: true });\n  }\n\n  // Sandbox tools\n  if (workspace.sandbox) {\n    const executeCommandConfig = resolveToolConfig(toolsConfig, WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND);\n    if (workspace.sandbox.executeCommand && executeCommandConfig.enabled) {\n      // Pick the right tool variant based on whether processes are available\n      const baseTool = workspace.sandbox.processes ? executeCommandWithBackgroundTool : executeCommandTool;\n      tools[WORKSPACE_TOOLS.SANDBOX.EXECUTE_COMMAND] = wrapTool(baseTool, workspace, executeCommandConfig);\n    }\n\n    // Background process tools (only when process manager is available)\n    if (workspace.sandbox.processes) {\n      addTool(WORKSPACE_TOOLS.SANDBOX.GET_PROCESS_OUTPUT, getProcessOutputTool);\n      addTool(WORKSPACE_TOOLS.SANDBOX.KILL_PROCESS, killProcessTool);\n    }\n  }\n\n  return tools;\n}\n"]}