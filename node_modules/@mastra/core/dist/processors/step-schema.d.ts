import type { LanguageModelV2 } from '@ai-sdk/provider-v5';
import type { CallSettings, StepResult, ToolChoice, ToolSet } from '../_types/@internal_ai-sdk-v5/dist/index.js';
import { z } from 'zod';
import type { MastraMessageContentV2, MessageList } from '../agent/message-list/index.js';
import type { ModelRouterModelId } from '../llm/model/index.js';
import type { MastraLanguageModel, OpenAICompatibleConfig, SharedProviderOptions } from '../llm/model/shared.types.js';
import type { OutputSchema } from '../stream/index.js';
import type { InferSchemaOutput } from '../stream/base/schema.js';
import type { StructuredOutputOptions } from './processors/index.js';
export type TextPartType = {
    type: 'text';
    text: string;
};
export type ImagePartType = {
    type: 'image';
    image: string | URL | Uint8Array;
    mimeType?: string;
};
export type FilePartType = {
    type: 'file';
    data: string | URL | Uint8Array;
    mimeType: string;
};
export type ToolInvocationPartType = {
    type: 'tool-invocation';
    toolInvocation: {
        toolCallId: string;
        toolName: string;
        args?: unknown;
        state: 'partial-call' | 'call' | 'result';
        result?: unknown;
    };
};
export type ReasoningPartType = {
    type: 'reasoning';
    reasoning: string;
    details: Array<{
        type: 'text' | 'redacted';
        text?: string;
        data?: string;
    }>;
};
export type SourcePartType = {
    type: 'source';
    source: {
        sourceType: string;
        id: string;
        url?: string;
        title?: string;
    };
};
export type StepStartPartType = {
    type: 'step-start';
};
export type DataPartType = {
    type: string;
    id?: string;
    data?: unknown;
};
export type MessagePartType = TextPartType | ImagePartType | FilePartType | ToolInvocationPartType | ReasoningPartType | SourcePartType | StepStartPartType | DataPartType;
export type MessageContentType = {
    format: 2;
    parts: MessagePartType[];
    content?: string;
    metadata?: Record<string, unknown>;
    providerMetadata?: Record<string, unknown>;
};
type SystemMessageTextPartType = {
    type: 'text';
    text: string;
};
export type SystemMessageType = {
    role: 'system';
    content: string | Array<SystemMessageTextPartType>;
    experimental_providerMetadata?: Record<string, unknown>;
};
type CoreMessageType = {
    role: 'system' | 'user' | 'assistant' | 'tool';
    content?: unknown;
};
export type ProcessorMessageType = {
    id: string;
    role: 'user' | 'assistant' | 'system' | 'tool';
    createdAt: Date;
    threadId?: string;
    resourceId?: string;
    type?: string;
    content: MessageContentType;
};
/**
 * Model type for processor step schema.
 * In workflows, model configs may not yet be resolved, so we accept both resolved and unresolved types.
 */
export type ProcessorStepModelConfig = LanguageModelV2 | ModelRouterModelId | OpenAICompatibleConfig | MastraLanguageModel;
/**
 * Tools type for processor step schema.
 * Accepts both AI SDK ToolSet and generic Record for flexibility.
 */
export type ProcessorStepToolsConfig = ToolSet | Record<string, unknown>;
export type ProcessorInputPhaseType = {
    phase: 'input';
    messages: ProcessorMessageType[];
    messageList: MessageList;
    systemMessages?: CoreMessageType[];
    retryCount?: number;
};
export type ProcessorInputStepPhaseType = {
    phase: 'inputStep';
    messages: ProcessorMessageType[];
    messageList: MessageList;
    stepNumber: number;
    systemMessages?: CoreMessageType[];
    retryCount?: number;
    model?: ProcessorStepModelConfig;
    tools?: ProcessorStepToolsConfig;
    toolChoice?: ToolChoice<ToolSet>;
    activeTools?: string[];
    providerOptions?: SharedProviderOptions;
    modelSettings?: Omit<CallSettings, 'abortSignal'>;
    structuredOutput?: StructuredOutputOptions<InferSchemaOutput<OutputSchema>>;
    steps?: Array<StepResult<ToolSet>>;
};
export type ProcessorOutputStreamPhaseType = {
    phase: 'outputStream';
    part?: unknown | null;
    streamParts: unknown[];
    state: Record<string, unknown>;
    messageList?: MessageList;
    retryCount?: number;
};
export type ProcessorOutputResultPhaseType = {
    phase: 'outputResult';
    messages: ProcessorMessageType[];
    messageList: MessageList;
    retryCount?: number;
};
export type ProcessorOutputStepPhaseType = {
    phase: 'outputStep';
    messages: ProcessorMessageType[];
    messageList: MessageList;
    stepNumber: number;
    finishReason?: string;
    toolCalls?: Array<{
        toolName: string;
        toolCallId: string;
        args?: unknown;
    }>;
    text?: string;
    systemMessages?: CoreMessageType[];
    retryCount?: number;
};
export type ProcessorStepInputType = ProcessorInputPhaseType | ProcessorInputStepPhaseType | ProcessorOutputStreamPhaseType | ProcessorOutputResultPhaseType | ProcessorOutputStepPhaseType;
export type ProcessorStepOutputType = {
    phase: 'input' | 'inputStep' | 'outputStream' | 'outputResult' | 'outputStep';
    messages?: ProcessorMessageType[];
    messageList?: MessageList;
    systemMessages?: CoreMessageType[];
    stepNumber?: number;
    part?: unknown | null;
    streamParts?: unknown[];
    state?: Record<string, unknown>;
    finishReason?: string;
    toolCalls?: Array<{
        toolName: string;
        toolCallId: string;
        args?: unknown;
    }>;
    text?: string;
    retryCount?: number;
    model?: MastraLanguageModel;
    tools?: ProcessorStepToolsConfig;
    toolChoice?: ToolChoice<ToolSet>;
    activeTools?: string[];
    providerOptions?: SharedProviderOptions;
    modelSettings?: Omit<CallSettings, 'abortSignal'>;
    structuredOutput?: StructuredOutputOptions<InferSchemaOutput<OutputSchema>>;
    steps?: Array<StepResult<ToolSet>>;
};
/**
 * Text part in a message
 */
export declare const TextPartSchema: z.ZodType<TextPartType>;
/**
 * Image part in a message
 */
export declare const ImagePartSchema: z.ZodType<ImagePartType>;
/**
 * File part in a message
 */
export declare const FilePartSchema: z.ZodType<FilePartType>;
/**
 * Tool invocation part in a message (covers tool-call states)
 */
export declare const ToolInvocationPartSchema: z.ZodType<ToolInvocationPartType>;
/**
 * Reasoning part in a message (for models that support reasoning)
 */
export declare const ReasoningPartSchema: z.ZodType<ReasoningPartType>;
/**
 * Source part in a message (for citations/references)
 */
export declare const SourcePartSchema: z.ZodType<SourcePartType>;
/**
 * Step start part (marks the beginning of a step in multi-step responses)
 */
export declare const StepStartPartSchema: z.ZodType<StepStartPartType>;
/**
 * Custom data part (for data-* custom parts from AI SDK writer.custom())
 * This uses a regex to match any type starting with "data-"
 */
export declare const DataPartSchema: z.ZodType<DataPartType>;
/**
 * Union of all message part types.
 * Uses passthrough to allow additional fields from the AI SDK.
 * Note: We can't use discriminatedUnion here because DataPartSchema uses a regex pattern.
 */
export declare const MessagePartSchema: z.ZodType<MessagePartType>;
/**
 * Message content structure (MastraMessageContentV2 format)
 * This is a documentation-friendly schema with properly typed parts.
 */
export declare const MessageContentSchema: z.ZodType<MessageContentType>;
/**
 * Schema for message content in processor workflows.
 * Uses the MessagePartSchema discriminated union for proper UI rendering.
 */
export declare const ProcessorMessageContentSchema: z.ZodType<MessageContentType>;
/**
 * Schema for a message in the processor workflow.
 * This represents MastraDBMessage with properly typed fields for UI usage.
 *
 * Key fields:
 * - id: string - Unique message identifier
 * - role: 'user' | 'assistant' | 'system' - Message role
 * - createdAt: Date - When the message was created
 * - threadId?: string - Thread identifier for conversation grouping
 * - resourceId?: string - Resource identifier
 * - type?: string - Message type
 * - content: Message content with parts array
 */
export declare const ProcessorMessageSchema: z.ZodType<ProcessorMessageType>;
/**
 * Type for a processor message - inferred from schema for consistency.
 * Use this type when working with processor messages in TypeScript.
 */
export type ProcessorMessage = ProcessorMessageType;
/**
 * Type for message content
 */
export type MessageContent = MastraMessageContentV2;
/**
 * Type for message parts - union of all possible part types.
 * Common part types:
 * - { type: 'text', text: string }
 * - { type: 'tool-invocation', toolInvocation: { toolCallId, toolName, args, state, result? } }
 * - { type: 'reasoning', reasoning: string, details: [...] }
 * - { type: 'source', source: { sourceType, id, url?, title? } }
 * - { type: 'file', data, mimeType }
 * - { type: 'step-start' }
 */
export type MessagePart = MessagePartType;
/**
 * Schema for a system message (CoreSystemMessage from AI SDK)
 * System messages provide context/instructions to the model.
 *
 * Note: This is exported for documentation purposes in the UI.
 * The actual systemMessages array in processor args may contain
 * other CoreMessage types depending on the context.
 */
export declare const SystemMessageSchema: z.ZodType<SystemMessageType>;
/**
 * Schema for 'input' phase - processInput
 * Processes input messages before they are sent to the LLM (once at the start)
 */
export declare const ProcessorInputPhaseSchema: z.ZodObject<{
    phase: z.ZodLiteral<"input">;
    messages: z.ZodArray<z.ZodType<ProcessorMessageType, z.ZodTypeDef, ProcessorMessageType>, "many">;
    messageList: z.ZodType<MessageList, z.ZodTypeDef, MessageList>;
    systemMessages: z.ZodOptional<z.ZodArray<z.ZodType<CoreMessageType, z.ZodTypeDef, CoreMessageType>, "many">>;
    retryCount: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    messages: ProcessorMessageType[];
    messageList: MessageList;
    phase: "input";
    systemMessages?: CoreMessageType[] | undefined;
    retryCount?: number | undefined;
}, {
    messages: ProcessorMessageType[];
    messageList: MessageList;
    phase: "input";
    systemMessages?: CoreMessageType[] | undefined;
    retryCount?: number | undefined;
}>;
/**
 * Schema for 'inputStep' phase - processInputStep
 * Processes input messages at each step of the agentic loop.
 * Includes model/tools configuration that can be modified per-step.
 */
export declare const ProcessorInputStepPhaseSchema: z.ZodObject<{
    phase: z.ZodLiteral<"inputStep">;
    messages: z.ZodArray<z.ZodType<ProcessorMessageType, z.ZodTypeDef, ProcessorMessageType>, "many">;
    messageList: z.ZodType<MessageList, z.ZodTypeDef, MessageList>;
    stepNumber: z.ZodNumber;
    systemMessages: z.ZodOptional<z.ZodArray<z.ZodType<CoreMessageType, z.ZodTypeDef, CoreMessageType>, "many">>;
    retryCount: z.ZodOptional<z.ZodNumber>;
    model: z.ZodOptional<z.ZodType<ProcessorStepModelConfig, z.ZodTypeDef, ProcessorStepModelConfig>>;
    tools: z.ZodOptional<z.ZodType<ProcessorStepToolsConfig, z.ZodTypeDef, ProcessorStepToolsConfig>>;
    toolChoice: z.ZodOptional<z.ZodType<ToolChoice<ToolSet>, z.ZodTypeDef, ToolChoice<ToolSet>>>;
    activeTools: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    providerOptions: z.ZodOptional<z.ZodType<SharedProviderOptions, z.ZodTypeDef, SharedProviderOptions>>;
    modelSettings: z.ZodOptional<z.ZodType<Omit<CallSettings, "abortSignal">, z.ZodTypeDef, Omit<CallSettings, "abortSignal">>>;
    structuredOutput: z.ZodOptional<z.ZodType<StructuredOutputOptions<any>, z.ZodTypeDef, StructuredOutputOptions<any>>>;
    steps: z.ZodOptional<z.ZodType<StepResult<ToolSet>[], z.ZodTypeDef, StepResult<ToolSet>[]>>;
}, "strip", z.ZodTypeAny, {
    messages: ProcessorMessageType[];
    messageList: MessageList;
    stepNumber: number;
    phase: "inputStep";
    providerOptions?: SharedProviderOptions | undefined;
    tools?: ProcessorStepToolsConfig | undefined;
    toolChoice?: ToolChoice<ToolSet> | undefined;
    activeTools?: string[] | undefined;
    structuredOutput?: StructuredOutputOptions<any> | undefined;
    model?: ProcessorStepModelConfig | undefined;
    modelSettings?: Omit<CallSettings, "abortSignal"> | undefined;
    steps?: StepResult<ToolSet>[] | undefined;
    systemMessages?: CoreMessageType[] | undefined;
    retryCount?: number | undefined;
}, {
    messages: ProcessorMessageType[];
    messageList: MessageList;
    stepNumber: number;
    phase: "inputStep";
    providerOptions?: SharedProviderOptions | undefined;
    tools?: ProcessorStepToolsConfig | undefined;
    toolChoice?: ToolChoice<ToolSet> | undefined;
    activeTools?: string[] | undefined;
    structuredOutput?: StructuredOutputOptions<any> | undefined;
    model?: ProcessorStepModelConfig | undefined;
    modelSettings?: Omit<CallSettings, "abortSignal"> | undefined;
    steps?: StepResult<ToolSet>[] | undefined;
    systemMessages?: CoreMessageType[] | undefined;
    retryCount?: number | undefined;
}>;
/**
 * Schema for 'outputStream' phase - processOutputStream
 * Processes output stream chunks with built-in state management
 */
export declare const ProcessorOutputStreamPhaseSchema: z.ZodObject<{
    phase: z.ZodLiteral<"outputStream">;
    part: z.ZodNullable<z.ZodUnknown>;
    streamParts: z.ZodArray<z.ZodUnknown, "many">;
    state: z.ZodRecord<z.ZodString, z.ZodUnknown>;
    messageList: z.ZodOptional<z.ZodType<MessageList, z.ZodTypeDef, MessageList>>;
    retryCount: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    state: Record<string, unknown>;
    streamParts: unknown[];
    phase: "outputStream";
    part?: unknown;
    messageList?: MessageList | undefined;
    retryCount?: number | undefined;
}, {
    state: Record<string, unknown>;
    streamParts: unknown[];
    phase: "outputStream";
    part?: unknown;
    messageList?: MessageList | undefined;
    retryCount?: number | undefined;
}>;
/**
 * Schema for 'outputResult' phase - processOutputResult
 * Processes the complete output result after streaming/generate is finished
 */
export declare const ProcessorOutputResultPhaseSchema: z.ZodObject<{
    phase: z.ZodLiteral<"outputResult">;
    messages: z.ZodArray<z.ZodType<ProcessorMessageType, z.ZodTypeDef, ProcessorMessageType>, "many">;
    messageList: z.ZodType<MessageList, z.ZodTypeDef, MessageList>;
    retryCount: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    messages: ProcessorMessageType[];
    messageList: MessageList;
    phase: "outputResult";
    retryCount?: number | undefined;
}, {
    messages: ProcessorMessageType[];
    messageList: MessageList;
    phase: "outputResult";
    retryCount?: number | undefined;
}>;
/**
 * Schema for 'outputStep' phase - processOutputStep
 * Processes output after each LLM response in the agentic loop, before tool execution
 */
export declare const ProcessorOutputStepPhaseSchema: z.ZodObject<{
    phase: z.ZodLiteral<"outputStep">;
    messages: z.ZodArray<z.ZodType<ProcessorMessageType, z.ZodTypeDef, ProcessorMessageType>, "many">;
    messageList: z.ZodType<MessageList, z.ZodTypeDef, MessageList>;
    stepNumber: z.ZodNumber;
    finishReason: z.ZodOptional<z.ZodString>;
    toolCalls: z.ZodOptional<z.ZodArray<z.ZodObject<{
        toolName: z.ZodString;
        toolCallId: z.ZodString;
        args: z.ZodUnknown;
    }, "strip", z.ZodTypeAny, {
        toolCallId: string;
        toolName: string;
        args?: unknown;
    }, {
        toolCallId: string;
        toolName: string;
        args?: unknown;
    }>, "many">>;
    text: z.ZodOptional<z.ZodString>;
    systemMessages: z.ZodOptional<z.ZodArray<z.ZodType<CoreMessageType, z.ZodTypeDef, CoreMessageType>, "many">>;
    retryCount: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    messages: ProcessorMessageType[];
    messageList: MessageList;
    stepNumber: number;
    phase: "outputStep";
    text?: string | undefined;
    toolCalls?: {
        toolCallId: string;
        toolName: string;
        args?: unknown;
    }[] | undefined;
    finishReason?: string | undefined;
    systemMessages?: CoreMessageType[] | undefined;
    retryCount?: number | undefined;
}, {
    messages: ProcessorMessageType[];
    messageList: MessageList;
    stepNumber: number;
    phase: "outputStep";
    text?: string | undefined;
    toolCalls?: {
        toolCallId: string;
        toolName: string;
        args?: unknown;
    }[] | undefined;
    finishReason?: string | undefined;
    systemMessages?: CoreMessageType[] | undefined;
    retryCount?: number | undefined;
}>;
/**
 * Discriminated union schema for processor step input in workflows.
 *
 * This schema uses a discriminated union based on the `phase` field,
 * which determines what other fields are required/available.
 * This makes it much clearer what data is needed for each phase
 * and provides better UX in the playground UI.
 *
 * Phases:
 * - 'input': Process input messages before LLM (once at start)
 * - 'inputStep': Process input messages at each agentic loop step
 * - 'outputStream': Process streaming chunks
 * - 'outputResult': Process complete output after streaming
 * - 'outputStep': Process output after each LLM response (before tools)
 */
export declare const ProcessorStepInputSchema: z.ZodType<ProcessorStepInputType>;
/**
 * Output schema for processor step data in workflows.
 *
 * This is a more flexible schema that allows all fields to be optional
 * since the output from one phase may need to be passed to another.
 * The workflow engine handles the type narrowing internally.
 */
export declare const ProcessorStepOutputSchema: z.ZodType<ProcessorStepOutputType>;
/**
 * Combined schema that works for both input and output.
 * Uses the discriminated union for better type inference.
 */
export declare const ProcessorStepSchema: z.ZodType<ProcessorStepInputType>;
/**
 * Type for processor step data - discriminated union based on phase.
 * Use this for external APIs where type safety is important.
 */
export type ProcessorStepData = ProcessorStepInputType;
/**
 * Flexible type for internal processor code that needs to access all fields.
 * This is useful when you need to pass data through without knowing the exact phase.
 */
export type ProcessorStepDataFlexible = ProcessorStepOutputType;
/**
 * Input type alias for processor steps.
 */
export type ProcessorStepInput = ProcessorStepData;
/**
 * Output type alias for processor steps.
 * Uses the flexible schema since outputs may be passed between phases.
 */
export type ProcessorStepOutput = ProcessorStepDataFlexible;
export {};
//# sourceMappingURL=step-schema.d.ts.map