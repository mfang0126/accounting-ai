/**
 * LSP Manager
 *
 * Per-workspace manager that owns LSP server clients.
 * NOT a singleton â€” each Workspace instance creates its own LSPManager.
 *
 * Resolves the project root per-file by walking up from the file's directory
 * using language-specific markers defined on each server (e.g. tsconfig.json
 * for TypeScript, go.mod for Go). Falls back to the default root when
 * walkup finds nothing.
 */
import type { SandboxProcessManager } from '../sandbox/process-manager/index.js';
import { LSPClient } from './client.js';
import type { LSPConfig, LSPDiagnostic } from './types.js';
export declare class LSPManager {
    private clients;
    private initPromises;
    private fileLocks;
    private processManager;
    private _root;
    private config;
    private filesystem?;
    constructor(processManager: SandboxProcessManager, root: string, config?: LSPConfig, filesystem?: {
        exists(path: string): Promise<boolean>;
    });
    /** Default project root (fallback when per-file walkup finds nothing). */
    get root(): string;
    /**
     * Resolve the project root for a given file path using the server's markers.
     * Uses the workspace filesystem when available (supports remote filesystems),
     * falls back to sync walkUp (local disk) otherwise.
     */
    private resolveRoot;
    /**
     * Acquire a per-file lock so that concurrent getDiagnostics calls for the
     * same file are serialized (preventing interleaved open/change/close).
     * Different files can run in parallel.
     */
    private acquireFileLock;
    /**
     * Initialize an LSP client for the given server definition and project root.
     * Handles timeout, deduplication of concurrent init calls, and caching.
     */
    private initClient;
    /**
     * Get or create an LSP client for a file path.
     * Resolves the project root per-file using the server's markers.
     * Returns null if no server is available.
     */
    getClient(filePath: string): Promise<LSPClient | null>;
    /**
     * Convenience method: open file, send content, wait for diagnostics, return normalized results.
     * Returns an empty array on any failure (non-blocking).
     * Uses a per-file lock to serialize concurrent calls for the same file.
     */
    getDiagnostics(filePath: string, content: string): Promise<LSPDiagnostic[]>;
    /**
     * Get diagnostics from ALL matching language servers for a file.
     * Deduplicates results by (line, character, message).
     * Individual server failures don't block other servers.
     */
    getDiagnosticsMulti(filePath: string, content: string): Promise<LSPDiagnostic[]>;
    /**
     * Collect diagnostics from a single client for a file.
     */
    private collectDiagnostics;
    /**
     * Shutdown all managed LSP clients.
     */
    shutdownAll(): Promise<void>;
}
//# sourceMappingURL=manager.d.ts.map