import { getAgentFromSystem } from './chunk-GIR6HLCQ.js';
import { voiceSpeakersResponseSchema, agentIdPathParams, speakResponseSchema, generateSpeechBodySchema, transcribeSpeechResponseSchema, transcribeSpeechBodySchema, getListenerResponseSchema } from './chunk-5NT3IMUR.js';
import { validateBody } from './chunk-USR6JK77.js';
import { handleError } from './chunk-ONN5EA7E.js';
import { createRoute } from './chunk-D5VCL56B.js';
import { HTTPException } from './chunk-6QWQZI4Q.js';
import { __export } from './chunk-PR4QN5HX.js';
import { Readable } from 'stream';
import { MastraError } from '@mastra/core/error';

// src/server/handlers/voice.ts
var voice_exports = {};
__export(voice_exports, {
  GENERATE_SPEECH_DEPRECATED_ROUTE: () => GENERATE_SPEECH_DEPRECATED_ROUTE,
  GENERATE_SPEECH_ROUTE: () => GENERATE_SPEECH_ROUTE,
  GET_LISTENER_ROUTE: () => GET_LISTENER_ROUTE,
  GET_SPEAKERS_DEPRECATED_ROUTE: () => GET_SPEAKERS_DEPRECATED_ROUTE,
  GET_SPEAKERS_ROUTE: () => GET_SPEAKERS_ROUTE,
  TRANSCRIBE_SPEECH_DEPRECATED_ROUTE: () => TRANSCRIBE_SPEECH_DEPRECATED_ROUTE,
  TRANSCRIBE_SPEECH_ROUTE: () => TRANSCRIBE_SPEECH_ROUTE
});
var GET_SPEAKERS_ROUTE = createRoute({
  method: "GET",
  path: "/agents/:agentId/voice/speakers",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  responseSchema: voiceSpeakersResponseSchema,
  summary: "Get voice speakers",
  description: "Returns available voice speakers for the specified agent",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, requestContext }) => {
    try {
      if (!agentId) {
        throw new HTTPException(400, { message: "Agent ID is required" });
      }
      const agent = await getAgentFromSystem({ mastra, agentId });
      const voice = await agent.getVoice({ requestContext });
      const speakers = await Promise.resolve().then(() => voice.getSpeakers()).catch((err) => {
        if (err instanceof MastraError) {
          return [];
        }
        throw err;
      });
      return speakers;
    } catch (error) {
      return handleError(error, "Error getting speakers");
    }
  }
});
var GET_SPEAKERS_DEPRECATED_ROUTE = createRoute({
  method: "GET",
  path: "/agents/:agentId/speakers",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  responseSchema: voiceSpeakersResponseSchema,
  summary: "Get available speakers for an agent",
  description: "[DEPRECATED] Use /agents/:agentId/voice/speakers instead. Get available speakers for an agent",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: GET_SPEAKERS_ROUTE.handler
});
var GENERATE_SPEECH_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/voice/speak",
  responseType: "stream",
  pathParamSchema: agentIdPathParams,
  bodySchema: generateSpeechBodySchema,
  responseSchema: speakResponseSchema,
  summary: "Generate speech",
  description: "Generates speech audio from text using the agent voice configuration",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, text, speakerId, requestContext }) => {
    try {
      if (!agentId) {
        throw new HTTPException(400, { message: "Agent ID is required" });
      }
      validateBody({ text });
      const agent = await getAgentFromSystem({ mastra, agentId });
      const voice = await agent.getVoice({ requestContext });
      if (!voice) {
        throw new HTTPException(400, { message: "Agent does not have voice capabilities" });
      }
      const audioStream = await Promise.resolve().then(() => voice.speak(text, { speaker: speakerId })).catch((err) => {
        if (err instanceof MastraError) {
          throw new HTTPException(400, { message: err.message });
        }
        throw err;
      });
      if (!audioStream) {
        throw new HTTPException(500, { message: "Failed to generate speech" });
      }
      return audioStream;
    } catch (error) {
      return handleError(error, "Error generating speech");
    }
  }
});
var GENERATE_SPEECH_DEPRECATED_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/speak",
  responseType: "stream",
  pathParamSchema: agentIdPathParams,
  bodySchema: generateSpeechBodySchema,
  responseSchema: speakResponseSchema,
  summary: "Convert text to speech",
  description: "[DEPRECATED] Use /agents/:agentId/voice/speak instead. Convert text to speech using the agent's voice provider",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: GENERATE_SPEECH_ROUTE.handler
});
var TRANSCRIBE_SPEECH_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/voice/listen",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: transcribeSpeechBodySchema,
  responseSchema: transcribeSpeechResponseSchema,
  summary: "Transcribe speech",
  description: "Transcribes speech audio to text using the agent voice configuration",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, audio, options, requestContext }) => {
    try {
      if (!agentId) {
        throw new HTTPException(400, { message: "Agent ID is required" });
      }
      if (!audio) {
        throw new HTTPException(400, { message: "Audio data is required" });
      }
      const agent = await getAgentFromSystem({ mastra, agentId });
      const voice = await agent.getVoice({ requestContext });
      if (!voice) {
        throw new HTTPException(400, { message: "Agent does not have voice capabilities" });
      }
      const audioStream = new Readable();
      audioStream.push(audio);
      audioStream.push(null);
      const text = await voice.listen(audioStream, options);
      return { text };
    } catch (error) {
      return handleError(error, "Error transcribing speech");
    }
  }
});
var TRANSCRIBE_SPEECH_DEPRECATED_ROUTE = createRoute({
  method: "POST",
  path: "/agents/:agentId/listen",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  bodySchema: transcribeSpeechBodySchema,
  responseSchema: transcribeSpeechResponseSchema,
  summary: "Convert speech to text",
  description: "[DEPRECATED] Use /agents/:agentId/voice/listen instead. Convert speech to text using the agent's voice provider. Additional provider-specific options can be passed as query parameters.",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: TRANSCRIBE_SPEECH_ROUTE.handler
});
var GET_LISTENER_ROUTE = createRoute({
  method: "GET",
  path: "/agents/:agentId/voice/listener",
  responseType: "json",
  pathParamSchema: agentIdPathParams,
  responseSchema: getListenerResponseSchema,
  summary: "Get voice listener",
  description: "Returns the voice listener configuration for the agent",
  tags: ["Agents", "Voice"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, requestContext }) => {
    try {
      if (!agentId) {
        throw new HTTPException(400, { message: "Agent ID is required" });
      }
      const agent = mastra.getAgentById(agentId);
      if (!agent) {
        throw new HTTPException(404, { message: "Agent not found" });
      }
      const voice = await agent.getVoice({ requestContext });
      const listeners = await Promise.resolve().then(() => voice.getListener()).catch((err) => {
        if (err instanceof MastraError) {
          return { enabled: false };
        }
        throw err;
      });
      return listeners;
    } catch (error) {
      return handleError(error, "Error getting listeners");
    }
  }
});

export { GENERATE_SPEECH_DEPRECATED_ROUTE, GENERATE_SPEECH_ROUTE, GET_LISTENER_ROUTE, GET_SPEAKERS_DEPRECATED_ROUTE, GET_SPEAKERS_ROUTE, TRANSCRIBE_SPEECH_DEPRECATED_ROUTE, TRANSCRIBE_SPEECH_ROUTE, voice_exports };
//# sourceMappingURL=chunk-4IEJOSXX.js.map
//# sourceMappingURL=chunk-4IEJOSXX.js.map