'use strict';

var chunk5JH2BJPC_cjs = require('./chunk-5JH2BJPC.cjs');
var chunkWAQHLUSX_cjs = require('./chunk-WAQHLUSX.cjs');
var chunkHHE6BWUK_cjs = require('./chunk-HHE6BWUK.cjs');
var chunkZKMVCV4G_cjs = require('./chunk-ZKMVCV4G.cjs');
var chunkRWLJZWDL_cjs = require('./chunk-RWLJZWDL.cjs');
var chunkSUKFO7UM_cjs = require('./chunk-SUKFO7UM.cjs');
var chunk4LVJBXI2_cjs = require('./chunk-4LVJBXI2.cjs');
var chunk64ITUOXI_cjs = require('./chunk-64ITUOXI.cjs');
var chunkO7I5CWRX_cjs = require('./chunk-O7I5CWRX.cjs');
var tools = require('@mastra/core/tools');
var zodToJson = require('@mastra/core/utils/zod-to-json');

// src/server/handlers/tools.ts
var tools_exports = {};
chunkO7I5CWRX_cjs.__export(tools_exports, {
  EXECUTE_AGENT_TOOL_ROUTE: () => EXECUTE_AGENT_TOOL_ROUTE,
  EXECUTE_TOOL_ROUTE: () => EXECUTE_TOOL_ROUTE,
  GET_AGENT_TOOL_ROUTE: () => GET_AGENT_TOOL_ROUTE,
  GET_TOOL_BY_ID_ROUTE: () => GET_TOOL_BY_ID_ROUTE,
  LIST_TOOLS_ROUTE: () => LIST_TOOLS_ROUTE
});
function resolveSchema(schema) {
  if (typeof schema === "function") {
    try {
      return schema();
    } catch {
      return void 0;
    }
  }
  return schema;
}
function serializeTool(tool) {
  if (tools.isProviderDefinedTool(tool)) {
    const resolvedInput = resolveSchema(tool.inputSchema);
    const resolvedOutput = resolveSchema(tool.outputSchema);
    return {
      ...tool,
      inputSchema: resolvedInput && typeof resolvedInput === "object" && "jsonSchema" in resolvedInput ? chunkHHE6BWUK_cjs.stringify(resolvedInput.jsonSchema) : void 0,
      outputSchema: resolvedOutput && typeof resolvedOutput === "object" && "jsonSchema" in resolvedOutput ? chunkHHE6BWUK_cjs.stringify(resolvedOutput.jsonSchema) : void 0
    };
  }
  return {
    ...tool,
    inputSchema: tool.inputSchema ? chunkHHE6BWUK_cjs.stringify(zodToJson.zodToJsonSchema(tool.inputSchema)) : void 0,
    outputSchema: tool.outputSchema ? chunkHHE6BWUK_cjs.stringify(zodToJson.zodToJsonSchema(tool.outputSchema)) : void 0,
    requestContextSchema: tool.requestContextSchema ? chunkHHE6BWUK_cjs.stringify(zodToJson.zodToJsonSchema(tool.requestContextSchema)) : void 0
  };
}
var LIST_TOOLS_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/tools",
  responseType: "json",
  responseSchema: chunkWAQHLUSX_cjs.listToolsResponseSchema,
  summary: "List all tools",
  description: "Returns a list of all available tools in the system",
  tags: ["Tools"],
  requiresAuth: true,
  handler: async ({ mastra, registeredTools }) => {
    try {
      const allTools = registeredTools && Object.keys(registeredTools).length > 0 ? registeredTools : mastra.listTools() || {};
      const serializedTools = Object.entries(allTools).reduce(
        (acc, [id, _tool]) => {
          acc[id] = serializeTool(_tool);
          return acc;
        },
        {}
      );
      return serializedTools;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting tools");
    }
  }
});
var GET_TOOL_BY_ID_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/tools/:toolId",
  responseType: "json",
  pathParamSchema: chunkWAQHLUSX_cjs.toolIdPathParams,
  responseSchema: chunkWAQHLUSX_cjs.serializedToolSchema,
  summary: "Get tool by ID",
  description: "Returns details for a specific tool including its schema and configuration",
  tags: ["Tools"],
  requiresAuth: true,
  handler: async ({ mastra, registeredTools, toolId }) => {
    try {
      let tool;
      if (registeredTools && Object.keys(registeredTools).length > 0) {
        tool = Object.values(registeredTools).find((t) => t.id === toolId);
      } else {
        tool = mastra.getToolById(toolId);
      }
      if (!tool) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Tool not found" });
      }
      return serializeTool(tool);
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting tool");
    }
  }
});
var EXECUTE_TOOL_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/tools/:toolId/execute",
  responseType: "json",
  pathParamSchema: chunkWAQHLUSX_cjs.toolIdPathParams,
  queryParamSchema: chunkRWLJZWDL_cjs.optionalRunIdSchema,
  bodySchema: chunkWAQHLUSX_cjs.executeToolContextBodySchema,
  responseSchema: chunkWAQHLUSX_cjs.executeToolResponseSchema,
  summary: "Execute tool",
  description: "Executes a specific tool with the provided input data",
  tags: ["Tools"],
  requiresAuth: true,
  handler: async ({ mastra, runId, toolId, registeredTools, requestContext, ...bodyParams }) => {
    try {
      if (!toolId) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Tool ID is required" });
      }
      let tool;
      if (registeredTools && Object.keys(registeredTools).length > 0) {
        tool = Object.values(registeredTools).find((t) => t.id === toolId);
      } else {
        tool = mastra.getToolById(toolId);
      }
      if (!tool) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Tool not found" });
      }
      if (!tool?.execute) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Tool is not executable" });
      }
      const { data } = bodyParams;
      chunkZKMVCV4G_cjs.validateBody({ data });
      if (tools.isVercelTool(tool)) {
        const result2 = await tool.execute(data);
        return result2;
      }
      const result = await tool.execute(data, {
        mastra,
        requestContext,
        // TODO: Pass proper tracing context when server API supports tracing
        tracingContext: { currentSpan: void 0 },
        ...runId ? {
          workflow: {
            runId,
            suspend: async () => {
            }
          }
        } : {}
      });
      return result;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error executing tool");
    }
  }
});
var GET_AGENT_TOOL_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/agents/:agentId/tools/:toolId",
  responseType: "json",
  pathParamSchema: chunkWAQHLUSX_cjs.agentToolPathParams,
  responseSchema: chunkWAQHLUSX_cjs.serializedToolSchema,
  summary: "Get agent tool",
  description: "Returns details for a specific tool assigned to the agent",
  tags: ["Agents", "Tools"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, toolId, requestContext }) => {
    try {
      if (!agentId) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Agent ID is required" });
      }
      const agent = await chunk5JH2BJPC_cjs.getAgentFromSystem({ mastra, agentId });
      const agentTools = await agent.listTools({ requestContext });
      const tool = Object.values(agentTools || {}).find((tool2) => tool2.id === toolId);
      if (!tool) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Tool not found" });
      }
      return serializeTool(tool);
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting agent tool");
    }
  }
});
var EXECUTE_AGENT_TOOL_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/agents/:agentId/tools/:toolId/execute",
  responseType: "json",
  pathParamSchema: chunkWAQHLUSX_cjs.agentToolPathParams,
  bodySchema: chunkWAQHLUSX_cjs.executeToolBodySchema,
  responseSchema: chunkWAQHLUSX_cjs.executeToolResponseSchema,
  summary: "Execute agent tool",
  description: "Executes a specific tool assigned to the agent with the provided input data",
  tags: ["Agents", "Tools"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, toolId, data, requestContext }) => {
    try {
      if (!agentId) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Agent ID is required" });
      }
      const agent = await chunk5JH2BJPC_cjs.getAgentFromSystem({ mastra, agentId });
      const agentTools = await agent.listTools({ requestContext });
      const tool = Object.values(agentTools || {}).find((tool2) => tool2.id === toolId);
      if (!tool) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Tool not found" });
      }
      if (!tool?.execute) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Tool is not executable" });
      }
      const result = await tool.execute(data, {
        mastra,
        requestContext,
        // TODO: Pass proper tracing context when server API supports tracing
        tracingContext: { currentSpan: void 0 }
      });
      return result;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error executing agent tool");
    }
  }
});

exports.EXECUTE_AGENT_TOOL_ROUTE = EXECUTE_AGENT_TOOL_ROUTE;
exports.EXECUTE_TOOL_ROUTE = EXECUTE_TOOL_ROUTE;
exports.GET_AGENT_TOOL_ROUTE = GET_AGENT_TOOL_ROUTE;
exports.GET_TOOL_BY_ID_ROUTE = GET_TOOL_BY_ID_ROUTE;
exports.LIST_TOOLS_ROUTE = LIST_TOOLS_ROUTE;
exports.tools_exports = tools_exports;
//# sourceMappingURL=chunk-RU5PL7RD.cjs.map
//# sourceMappingURL=chunk-RU5PL7RD.cjs.map