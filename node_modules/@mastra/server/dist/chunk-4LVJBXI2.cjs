'use strict';

var zodToJson = require('@mastra/core/utils/zod-to-json');
var zod = require('zod');

// src/server/server-adapter/openapi-utils.ts
function generateRouteOpenAPI({
  method,
  path,
  summary,
  description,
  tags = [],
  pathParamSchema,
  queryParamSchema,
  bodySchema,
  responseSchema,
  deprecated
}) {
  const route = {
    summary: summary || `${method} ${path}`,
    description,
    tags,
    deprecated,
    responses: {
      200: {
        description: "Successful response"
      }
    }
  };
  if (pathParamSchema || queryParamSchema) {
    route.requestParams = {};
    if (pathParamSchema) {
      route.requestParams.path = pathParamSchema;
    }
    if (queryParamSchema) {
      route.requestParams.query = queryParamSchema;
    }
  }
  if (bodySchema) {
    route.requestBody = {
      content: {
        "application/json": {
          schema: bodySchema
        }
      }
    };
  }
  if (responseSchema) {
    route.responses[200] = {
      description: "Successful response",
      content: {
        "application/json": {
          schema: responseSchema
        }
      }
    };
  }
  return route;
}
function convertZodToJsonSchema(spec) {
  const converted = {
    summary: spec.summary,
    description: spec.description,
    tags: spec.tags,
    responses: {}
  };
  const parameters = [];
  if (spec.requestParams?.path) {
    const pathSchema = zodToJson.zodToJsonSchema(spec.requestParams.path, "openApi3", "none");
    const properties = pathSchema.properties || {};
    Object.entries(properties).forEach(([name, schema]) => {
      parameters.push({
        name,
        in: "path",
        required: true,
        description: schema.description || `The ${name} parameter`,
        schema
      });
    });
  }
  if (spec.requestParams?.query) {
    const querySchema = zodToJson.zodToJsonSchema(spec.requestParams.query, "openApi3", "none");
    const properties = querySchema.properties || {};
    const required = querySchema.required || [];
    Object.entries(properties).forEach(([name, schema]) => {
      parameters.push({
        name,
        in: "query",
        required: required.includes(name),
        description: schema.description || `Query parameter: ${name}`,
        schema
      });
    });
  }
  if (parameters.length > 0) {
    converted.parameters = parameters;
  }
  if (spec.requestBody?.content?.["application/json"]?.schema) {
    converted.requestBody = {
      required: true,
      content: {
        "application/json": {
          schema: zodToJson.zodToJsonSchema(spec.requestBody.content["application/json"].schema, "openApi3", "none")
        }
      }
    };
  }
  Object.entries(spec.responses).forEach(([statusCode, response]) => {
    converted.responses[statusCode] = {
      description: response.description
    };
    if (response.content?.["application/json"]?.schema) {
      converted.responses[statusCode].content = {
        "application/json": {
          schema: zodToJson.zodToJsonSchema(response.content["application/json"].schema, "openApi3", "none")
        }
      };
    }
  });
  return converted;
}
function generateOpenAPIDocument(routes, info) {
  const paths = {};
  routes.forEach((route) => {
    if (!route.openapi) return;
    const openapiPath = route.path.replace(/:(\w+)/g, "{$1}");
    if (!paths[openapiPath]) {
      paths[openapiPath] = {};
    }
    paths[openapiPath][route.method.toLowerCase()] = convertZodToJsonSchema(route.openapi);
  });
  return {
    openapi: "3.1.0",
    info: {
      title: info.title,
      version: info.version,
      description: info.description
    },
    paths
  };
}
function convertCustomRoutesToOpenAPIPaths(routes) {
  const paths = {};
  for (const route of routes) {
    if (!route.openapi || route.openapi.hide) {
      continue;
    }
    if (route.method === "ALL") {
      continue;
    }
    const openapiPath = route.path.replace(/:(\w+)/g, "{$1}");
    if (!paths[openapiPath]) {
      paths[openapiPath] = {};
    }
    const method = route.method.toLowerCase();
    const openapi = route.openapi;
    const operation = {
      summary: openapi.summary || `${route.method} ${route.path}`,
      description: openapi.description,
      tags: openapi.tags || ["custom"],
      deprecated: openapi.deprecated,
      externalDocs: openapi.externalDocs,
      security: openapi.security,
      servers: openapi.servers
    };
    if (openapi.parameters && Array.isArray(openapi.parameters)) {
      operation.parameters = openapi.parameters.map((param) => {
        if (param.schema && typeof param.schema === "object" && "_def" in param.schema) {
          return {
            ...param,
            schema: zodToJson.zodToJsonSchema(param.schema, "openApi3", "none")
          };
        }
        return param;
      });
    }
    if (openapi.requestBody) {
      const requestBody = openapi.requestBody;
      operation.requestBody = { ...requestBody };
      if (requestBody.content) {
        operation.requestBody.content = {};
        for (const [mediaType, mediaContent] of Object.entries(requestBody.content)) {
          if (mediaContent?.schema && typeof mediaContent.schema === "object" && "_def" in mediaContent.schema) {
            operation.requestBody.content[mediaType] = {
              ...mediaContent,
              schema: zodToJson.zodToJsonSchema(mediaContent.schema, "openApi3", "none")
            };
          } else {
            operation.requestBody.content[mediaType] = mediaContent;
          }
        }
      }
    }
    if (openapi.responses) {
      operation.responses = {};
      for (const [statusCode, response] of Object.entries(openapi.responses)) {
        if (!response) continue;
        if ("$ref" in response) {
          operation.responses[statusCode] = response;
          continue;
        }
        operation.responses[statusCode] = { ...response };
        if (response.content) {
          operation.responses[statusCode].content = {};
          for (const [mediaType, mediaContent] of Object.entries(response.content)) {
            if (mediaContent?.schema && typeof mediaContent.schema === "object" && "_def" in mediaContent.schema) {
              operation.responses[statusCode].content[mediaType] = {
                ...mediaContent,
                schema: zodToJson.zodToJsonSchema(mediaContent.schema, "openApi3", "none")
              };
            } else {
              operation.responses[statusCode].content[mediaType] = mediaContent;
            }
          }
        }
      }
    } else {
      operation.responses = {
        200: {
          description: "Successful response"
        }
      };
    }
    Object.keys(operation).forEach((key) => {
      if (operation[key] === void 0) {
        delete operation[key];
      }
    });
    paths[openapiPath][method] = operation;
  }
  return paths;
}
function pickParams(schema, params) {
  const keys = Object.keys(schema.shape);
  const result = {};
  for (const key of keys) {
    if (key in params) {
      result[key] = params[key];
    }
  }
  return result;
}
function jsonQueryParam(schema) {
  return zod.z.union([
    schema,
    // Already the expected type (non-string input)
    zod.z.string().transform((val, ctx) => {
      try {
        const parsed = JSON.parse(val);
        const result = schema.safeParse(parsed);
        if (!result.success) {
          for (const issue of result.error.issues) {
            ctx.addIssue({
              code: zod.z.ZodIssueCode.custom,
              message: issue.message,
              path: issue.path
            });
          }
          return zod.z.NEVER;
        }
        return result.data;
      } catch (e) {
        ctx.addIssue({
          code: zod.z.ZodIssueCode.custom,
          message: `Invalid JSON: ${e instanceof Error ? e.message : "parse error"}`
        });
        return zod.z.NEVER;
      }
    })
  ]);
}
function getZodTypeName(schema) {
  return schema?._def?.typeName;
}
function isComplexType(schema) {
  let inner = schema;
  let typeName = getZodTypeName(inner);
  while (typeName === "ZodOptional" || typeName === "ZodNullable") {
    inner = inner._def.innerType;
    typeName = getZodTypeName(inner);
  }
  return typeName === "ZodArray" || typeName === "ZodRecord" || typeName === "ZodObject";
}
function wrapSchemaForQueryParams(schema) {
  const newShape = {};
  for (const [key, fieldSchema] of Object.entries(schema.shape)) {
    if (isComplexType(fieldSchema)) {
      newShape[key] = jsonQueryParam(fieldSchema);
    } else {
      newShape[key] = fieldSchema;
    }
  }
  return zod.z.object(newShape);
}
function createRoute(config) {
  const { summary, description, tags, deprecated, requiresAuth, ...baseRoute } = config;
  const openapi = config.method !== "ALL" ? generateRouteOpenAPI({
    method: config.method,
    path: config.path,
    summary,
    description,
    tags,
    pathParamSchema: config.pathParamSchema,
    queryParamSchema: config.queryParamSchema,
    bodySchema: config.bodySchema,
    responseSchema: config.responseSchema,
    deprecated
  }) : void 0;
  return {
    ...baseRoute,
    openapi,
    deprecated,
    requiresAuth
  };
}

exports.convertCustomRoutesToOpenAPIPaths = convertCustomRoutesToOpenAPIPaths;
exports.createRoute = createRoute;
exports.generateOpenAPIDocument = generateOpenAPIDocument;
exports.jsonQueryParam = jsonQueryParam;
exports.pickParams = pickParams;
exports.wrapSchemaForQueryParams = wrapSchemaForQueryParams;
//# sourceMappingURL=chunk-4LVJBXI2.cjs.map
//# sourceMappingURL=chunk-4LVJBXI2.cjs.map