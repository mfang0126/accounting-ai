{"version":3,"sources":["../src/server/handlers/memory.ts","../src/server/schemas/memory.ts"],"names":["__export","z","createPagePaginationSchema","paginationInfoSchema","successResponseSchema","HTTPException","createRoute","handleError","getEffectiveResourceId","getEffectiveThreadId","validateBody","validateThreadOwnership","generateEmptyFromSchema"],"mappings":"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","file":"chunk-UXMTV44Q.cjs","sourcesContent":["import type { Agent, MastraDBMessage } from '@mastra/core/agent';\nimport type { RequestContext } from '@mastra/core/di';\nimport type { MastraMemory } from '@mastra/core/memory';\nimport type { MastraStorage, MemoryStorage } from '@mastra/core/storage';\nimport { generateEmptyFromSchema } from '@mastra/core/utils';\nimport { HTTPException } from '../http-exception';\nimport {\n  threadIdPathParams,\n  agentIdQuerySchema,\n  getMemoryStatusQuerySchema,\n  getMemoryConfigQuerySchema,\n  listThreadsQuerySchema,\n  getThreadByIdQuerySchema,\n  listMessagesQuerySchema,\n  getWorkingMemoryQuerySchema,\n  deleteThreadQuerySchema,\n  deleteMessagesQuerySchema,\n  getMemoryStatusNetworkQuerySchema,\n  listThreadsNetworkQuerySchema,\n  getThreadByIdNetworkQuerySchema,\n  listMessagesNetworkQuerySchema,\n  saveMessagesNetworkQuerySchema,\n  createThreadNetworkQuerySchema,\n  updateThreadNetworkQuerySchema,\n  deleteThreadNetworkQuerySchema,\n  deleteMessagesNetworkQuerySchema,\n  memoryStatusResponseSchema,\n  memoryConfigResponseSchema,\n  listThreadsResponseSchema,\n  getThreadByIdResponseSchema,\n  listMessagesResponseSchema,\n  getWorkingMemoryResponseSchema,\n  saveMessagesBodySchema,\n  createThreadBodySchema,\n  updateThreadBodySchema,\n  updateWorkingMemoryBodySchema,\n  deleteMessagesBodySchema,\n  searchMemoryQuerySchema,\n  saveMessagesResponseSchema,\n  updateWorkingMemoryResponseSchema,\n  searchMemoryResponseSchema,\n  deleteThreadResponseSchema,\n  deleteMessagesResponseSchema,\n  cloneThreadBodySchema,\n  cloneThreadResponseSchema,\n  getObservationalMemoryQuerySchema,\n  getObservationalMemoryResponseSchema,\n  awaitBufferStatusBodySchema,\n  awaitBufferStatusResponseSchema,\n} from '../schemas/memory';\nimport { createRoute } from '../server-adapter/routes/route-builder';\nimport type { Context } from '../types';\n\nimport { handleError } from './error';\nimport { validateBody, getEffectiveResourceId, getEffectiveThreadId, validateThreadOwnership } from './utils';\n\ninterface MemoryContext extends Context {\n  agentId?: string;\n  resourceId?: string;\n  threadId?: string;\n  requestContext?: RequestContext;\n}\n\ninterface SearchResult {\n  id: string;\n  role: string;\n  content: string;\n  createdAt: Date;\n  threadId?: string;\n  threadTitle?: string;\n  score?: number;\n  context?: {\n    before?: SearchResult[];\n    after?: SearchResult[];\n  };\n}\n\nexport function getTextContent(message: MastraDBMessage): string {\n  if (typeof message.content === 'string') {\n    return message.content;\n  }\n  if (message.content && typeof message.content === 'object' && 'parts' in message.content) {\n    const textPart = message.content.parts.find(p => p.type === 'text');\n    return textPart?.text || '';\n  }\n  return '';\n}\n\nasync function getMemoryFromContext({\n  mastra,\n  agentId,\n  requestContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'requestContext'>): Promise<MastraMemory | null | undefined> {\n  const logger = mastra.getLogger();\n  let agent;\n  if (agentId) {\n    try {\n      agent = mastra.getAgentById(agentId);\n    } catch (error) {\n      logger.debug('Error getting agent from mastra, searching agents for agent', error);\n    }\n  }\n  if (agentId && !agent) {\n    logger.debug('Agent not found in registered agents, trying stored agents', { agentId });\n    try {\n      const storedAgent = (await mastra.getEditor()?.agent.getById(agentId)) ?? null;\n      if (storedAgent) {\n        agent = storedAgent;\n      }\n    } catch (error) {\n      logger.debug('Error getting stored agent', error);\n    }\n  }\n\n  if (agentId && !agent) {\n    logger.debug('Stored agent not found, searching sub-agents', { agentId });\n    const agents = mastra.listAgents();\n    if (Object.keys(agents || {}).length) {\n      for (const [_, ag] of Object.entries(agents)) {\n        try {\n          const subAgents = await ag.listAgents({ requestContext });\n\n          if (subAgents[agentId]) {\n            agent = subAgents[agentId];\n            break;\n          }\n        } catch (error) {\n          logger.debug('Error getting agent from agent', error);\n        }\n      }\n    }\n\n    if (!agent) {\n      throw new HTTPException(404, { message: 'Agent not found' });\n    }\n  }\n\n  if (agent) {\n    return await agent?.getMemory({\n      requestContext,\n    });\n  }\n}\n\n/**\n * Gets the storage from context, used as a fallback when no agentId is provided.\n * This allows fetching threads/messages without knowing which agents were involved.\n */\nfunction getStorageFromContext({ mastra }: Pick<MemoryContext, 'mastra'>): MastraStorage | undefined {\n  return mastra.getStorage();\n}\n\n/**\n * Gets the agent from context for OM processor detection.\n */\nasync function getAgentFromContext({\n  mastra,\n  agentId,\n  requestContext,\n}: Pick<MemoryContext, 'mastra' | 'agentId' | 'requestContext'>): Promise<Agent | null> {\n  if (!agentId) return null;\n\n  const logger = mastra.getLogger();\n  let agent: Agent | null = null;\n\n  // First try registered agents\n  try {\n    agent = mastra.getAgentById(agentId);\n  } catch (error) {\n    logger.debug('Error getting agent from mastra', error);\n  }\n\n  // Then try stored agents\n  if (!agent) {\n    logger.debug('Agent not found in registered agents, trying stored agents', { agentId });\n    try {\n      const storedAgent = (await mastra.getEditor()?.agent.getById(agentId)) ?? null;\n      if (storedAgent) {\n        agent = storedAgent;\n      }\n    } catch (error) {\n      logger.debug('Error getting stored agent', error);\n    }\n  }\n\n  // Finally search sub-agents with requestContext\n  if (!agent) {\n    logger.debug('Stored agent not found, searching sub-agents', { agentId });\n    const agents = mastra.listAgents();\n    if (Object.keys(agents || {}).length) {\n      for (const [_, ag] of Object.entries(agents)) {\n        try {\n          const nestedAgents = await ag.listAgents({ requestContext });\n          if (nestedAgents[agentId]) {\n            agent = nestedAgents[agentId];\n            break;\n          }\n        } catch (error) {\n          logger.debug('Error getting agent from agent', error);\n        }\n      }\n    }\n  }\n\n  return agent;\n}\n\n/**\n * Gets Observational Memory configuration from an agent's processors.\n * Returns null if OM is not enabled.\n */\nasync function getOMConfigFromAgent(\n  agent: Agent,\n  requestContext?: RequestContext,\n): Promise<{\n  enabled: boolean;\n  scope?: 'thread' | 'resource';\n  shareTokenBudget?: boolean;\n  messageTokens?: number | { min: number; max: number };\n  observationTokens?: number | { min: number; max: number };\n  observationModel?: string;\n  reflectionModel?: string;\n} | null> {\n  try {\n    // Guard against older @mastra/core versions that don't have resolveProcessorById\n    if (typeof agent.resolveProcessorById !== 'function') {\n      return null;\n    }\n    const omProcessor = await agent.resolveProcessorById('observational-memory', requestContext);\n    if (!omProcessor) {\n      return null;\n    }\n\n    // Use getResolvedConfig if available (properly resolves model names)\n    // Fall back to .config for backwards compatibility\n    const hasResolvedConfig = typeof (omProcessor as any).getResolvedConfig === 'function';\n\n    if (hasResolvedConfig) {\n      const resolvedConfig = await (omProcessor as any).getResolvedConfig(requestContext);\n      return {\n        enabled: true,\n        scope: resolvedConfig.scope || 'resource',\n        shareTokenBudget: resolvedConfig.shareTokenBudget,\n        messageTokens: resolvedConfig.observation?.messageTokens,\n        observationTokens: resolvedConfig.reflection?.observationTokens,\n        observationModel: resolvedConfig.observation?.model,\n        reflectionModel: resolvedConfig.reflection?.model,\n      };\n    }\n\n    // Fallback for older processor versions\n    const processorConfig = (omProcessor as any).config || {};\n    return {\n      enabled: true,\n      scope: processorConfig.scope || 'resource',\n      shareTokenBudget: processorConfig.shareTokenBudget,\n      messageTokens: processorConfig.observation?.messageTokens,\n      observationTokens: processorConfig.reflection?.observationTokens,\n      observationModel: undefined,\n      reflectionModel: undefined,\n    };\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Gets Observational Memory status for a specific resource/thread.\n */\nasync function getOMStatus(\n  memoryStorage: MemoryStorage,\n  resourceId: string,\n  threadId?: string,\n): Promise<{\n  hasRecord: boolean;\n  originType?: string;\n  lastObservedAt?: Date | null;\n  tokenCount?: number;\n  observationTokenCount?: number;\n  isObserving?: boolean;\n  isReflecting?: boolean;\n} | null> {\n  try {\n    const record = await memoryStorage.getObservationalMemory(threadId ?? null, resourceId);\n    if (!record) {\n      return { hasRecord: false };\n    }\n\n    return {\n      hasRecord: true,\n      originType: record.originType,\n      lastObservedAt: record.lastObservedAt ?? null,\n      tokenCount: record.totalTokensObserved,\n      observationTokenCount: record.observationTokenCount,\n      isObserving: record.isObserving,\n      isReflecting: record.isReflecting,\n    };\n  } catch {\n    return null;\n  }\n}\n\n// ============================================================================\n// Route Definitions (new pattern - handlers defined inline with createRoute)\n// ============================================================================\n\nexport const GET_MEMORY_STATUS_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/status',\n  responseType: 'json',\n  queryParamSchema: getMemoryStatusQuerySchema,\n  responseSchema: memoryStatusResponseSchema,\n  summary: 'Get memory status',\n  description: 'Returns the current status of the memory system including configuration and health information',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, resourceId, threadId, requestContext }) => {\n    try {\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (memory) {\n        // Check for Observational Memory\n        const agent = await getAgentFromContext({ mastra, agentId, requestContext });\n        let omStatus:\n          | {\n              enabled: boolean;\n              hasRecord?: boolean;\n              originType?: string;\n              lastObservedAt?: Date;\n              tokenCount?: number;\n              observationTokenCount?: number;\n              isObserving?: boolean;\n              isReflecting?: boolean;\n            }\n          | undefined;\n\n        if (agent) {\n          const omConfig = await getOMConfigFromAgent(agent, requestContext);\n          if (omConfig?.enabled && resourceId) {\n            // For resource-scoped OM, lookup by resourceId only (threadId=null)\n            const omThreadId = omConfig.scope === 'resource' ? undefined : threadId;\n            // Get OM status from the agent's memory storage (not mastra.getStorage())\n            try {\n              const memoryStore = await memory.storage.getStore('memory');\n              if (memoryStore) {\n                const status = await getOMStatus(memoryStore, resourceId, omThreadId);\n                if (status) {\n                  omStatus = {\n                    enabled: true,\n                    ...status,\n                    // Convert null to undefined for schema compatibility\n                    lastObservedAt: status.lastObservedAt ?? undefined,\n                  };\n                } else {\n                  omStatus = { enabled: true, hasRecord: false };\n                }\n              }\n            } catch {\n              // Storage not configured, just mark as enabled\n              omStatus = { enabled: true };\n            }\n          } else if (omConfig?.enabled) {\n            omStatus = { enabled: true };\n          }\n        }\n\n        return { result: true, observationalMemory: omStatus };\n      }\n\n      // Only fallback to storage if no agentId was provided\n      if (!agentId) {\n        const storage = getStorageFromContext({ mastra });\n        if (storage) {\n          return { result: true };\n        }\n      }\n\n      return { result: false };\n    } catch (error) {\n      return handleError(error, 'Error getting memory status');\n    }\n  },\n});\n\nexport const GET_MEMORY_CONFIG_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/config',\n  responseType: 'json',\n  queryParamSchema: getMemoryConfigQuerySchema,\n  responseSchema: memoryConfigResponseSchema,\n  summary: 'Get memory configuration',\n  description: 'Returns the memory configuration for a specific agent or the system default',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, requestContext }) => {\n    try {\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      // Get the merged configuration (defaults + custom)\n      const config = memory.getMergedThreadConfig({});\n\n      // Check for Observational Memory config\n      const agent = await getAgentFromContext({ mastra, agentId, requestContext });\n      let omConfig:\n        | {\n            enabled: boolean;\n            scope?: 'thread' | 'resource';\n            messageTokens?: number | { min: number; max: number };\n            observationTokens?: number | { min: number; max: number };\n            observationModel?: string;\n            reflectionModel?: string;\n          }\n        | undefined;\n\n      if (agent) {\n        omConfig = (await getOMConfigFromAgent(agent, requestContext)) ?? { enabled: false };\n      }\n\n      return {\n        config: {\n          ...config,\n          observationalMemory: omConfig,\n        },\n      };\n    } catch (error) {\n      return handleError(error, 'Error getting memory configuration');\n    }\n  },\n});\n\nexport const GET_OBSERVATIONAL_MEMORY_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/observational-memory',\n  responseType: 'json',\n  queryParamSchema: getObservationalMemoryQuerySchema,\n  responseSchema: getObservationalMemoryResponseSchema,\n  summary: 'Get observational memory data',\n  description: 'Returns the current observational memory record and optional history for a resource/thread',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, resourceId, threadId, requestContext }) => {\n    try {\n      // Verify agent has OM enabled\n      const agent = await getAgentFromContext({ mastra, agentId, requestContext });\n      if (!agent) {\n        throw new HTTPException(404, { message: 'Agent not found' });\n      }\n\n      const omConfig = await getOMConfigFromAgent(agent, requestContext);\n      if (!omConfig?.enabled) {\n        throw new HTTPException(400, { message: 'Observational Memory is not enabled for this agent' });\n      }\n\n      // Get storage from the agent's memory (not mastra.getStorage())\n      // This ensures we use the same storage the agent uses for OM\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not configured for this agent' });\n      }\n\n      let memoryStore: MemoryStorage | undefined;\n      try {\n        memoryStore = await memory.storage.getStore('memory');\n      } catch {\n        throw new HTTPException(400, { message: 'Memory storage is not initialized' });\n      }\n      if (!memoryStore) {\n        throw new HTTPException(400, { message: 'Memory storage is not initialized' });\n      }\n\n      // Determine the resourceId to use\n      const effectiveResourceId = resourceId;\n      if (!effectiveResourceId) {\n        throw new HTTPException(400, { message: 'resourceId is required for observational memory lookup' });\n      }\n\n      // For resource-scoped OM, lookup by resourceId only (threadId=null)\n      const omThreadId = omConfig.scope === 'resource' ? null : (threadId ?? null);\n\n      // Get current record\n      const record = await memoryStore.getObservationalMemory(omThreadId, effectiveResourceId);\n\n      // Get history (last 5 generations)\n      const history = await memoryStore.getObservationalMemoryHistory(omThreadId, effectiveResourceId, 5);\n\n      return {\n        record: record ?? null,\n        history: history.length > 0 ? history : undefined,\n      };\n    } catch (error) {\n      return handleError(error, 'Error getting observational memory');\n    }\n  },\n});\n\nexport const AWAIT_BUFFER_STATUS_ROUTE = createRoute({\n  method: 'POST',\n  path: '/memory/observational-memory/buffer-status',\n  responseType: 'json',\n  bodySchema: awaitBufferStatusBodySchema,\n  responseSchema: awaitBufferStatusResponseSchema,\n  summary: 'Await observational memory buffering completion',\n  description:\n    'Blocks until any in-flight buffering operations complete for the given thread/resource, then returns the updated record',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, resourceId, threadId, requestContext }: MemoryContext) => {\n    try {\n      const agent = await getAgentFromContext({ mastra, agentId, requestContext });\n      if (!agent) {\n        throw new HTTPException(404, { message: 'Agent not found' });\n      }\n\n      const omConfig = await getOMConfigFromAgent(agent, requestContext);\n      if (!omConfig?.enabled) {\n        throw new HTTPException(400, { message: 'Observational Memory is not enabled for this agent' });\n      }\n\n      // Resolve the OM processor to call waitForBuffering\n      const omProcessor = await agent.resolveProcessorById('observational-memory', requestContext);\n      if (!omProcessor || typeof (omProcessor as any).waitForBuffering !== 'function') {\n        throw new HTTPException(400, { message: 'Observational Memory processor not available' });\n      }\n\n      // Block until buffering completes (30s timeout)\n      await (omProcessor as any).waitForBuffering(threadId, resourceId);\n\n      // After buffering, fetch the updated record\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not configured for this agent' });\n      }\n\n      let memoryStore: MemoryStorage | undefined;\n      try {\n        memoryStore = await memory.storage.getStore('memory');\n      } catch {\n        throw new HTTPException(400, { message: 'Memory storage is not initialized' });\n      }\n      if (!memoryStore) {\n        throw new HTTPException(400, { message: 'Memory storage is not initialized' });\n      }\n\n      const effectiveResourceId = resourceId;\n      if (!effectiveResourceId) {\n        throw new HTTPException(400, { message: 'resourceId is required' });\n      }\n\n      const omThreadId = omConfig.scope === 'resource' ? null : (threadId ?? null);\n      const record = await memoryStore.getObservationalMemory(omThreadId, effectiveResourceId);\n\n      return { record: record ?? null };\n    } catch (error) {\n      console.error('Error awaiting buffer status', error);\n      return handleError(error, 'Error awaiting buffer status');\n    }\n  },\n});\n\nexport const LIST_THREADS_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/threads',\n  responseType: 'json',\n  queryParamSchema: listThreadsQuerySchema,\n  responseSchema: listThreadsResponseSchema,\n  summary: 'List memory threads',\n  description:\n    'Returns a paginated list of conversation threads with optional filtering by resource ID and/or metadata',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, resourceId, metadata, requestContext, page, perPage, orderBy }) => {\n    try {\n      // Use effective resourceId (context key takes precedence over client-provided value)\n      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);\n\n      // Build filter object dynamically based on provided parameters\n      const filter: { resourceId?: string; metadata?: Record<string, unknown> } | undefined =\n        effectiveResourceId || metadata ? {} : undefined;\n\n      if (effectiveResourceId) {\n        filter!.resourceId = effectiveResourceId;\n      }\n      if (metadata) {\n        filter!.metadata = metadata;\n      }\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (memory) {\n        const result = await memory.listThreads({\n          filter,\n          page,\n          perPage,\n          orderBy,\n        });\n        return result;\n      }\n\n      // Only fallback to storage if no agentId was provided\n      if (!agentId) {\n        const storage = getStorageFromContext({ mastra });\n        if (storage) {\n          const memoryStore = await storage.getStore('memory');\n          if (memoryStore) {\n            const result = await memoryStore.listThreads({\n              filter,\n              page,\n              perPage,\n              orderBy,\n            });\n            return result;\n          }\n        }\n      }\n\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    } catch (error) {\n      return handleError(error, 'Error listing threads');\n    }\n  },\n});\n\nexport const GET_THREAD_BY_ID_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: getThreadByIdQuerySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Get thread by ID',\n  description: 'Returns details for a specific conversation thread',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, threadId, resourceId, requestContext }) => {\n    try {\n      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);\n      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);\n      validateBody({ threadId: effectiveThreadId });\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (memory) {\n        const thread = await memory.getThreadById({ threadId: effectiveThreadId! });\n        if (!thread) {\n          throw new HTTPException(404, { message: 'Thread not found' });\n        }\n        await validateThreadOwnership(thread, effectiveResourceId);\n        return thread;\n      }\n\n      // Only fallback to storage if no agentId was provided\n      if (!agentId) {\n        const storage = getStorageFromContext({ mastra });\n        if (storage) {\n          const memoryStore = await storage.getStore('memory');\n          if (memoryStore) {\n            const thread = await memoryStore.getThreadById({ threadId: effectiveThreadId! });\n            if (!thread) {\n              throw new HTTPException(404, { message: 'Thread not found' });\n            }\n            await validateThreadOwnership(thread, effectiveResourceId);\n            return thread;\n          }\n        }\n      }\n\n      throw new HTTPException(400, { message: 'Memory is not initialized' });\n    } catch (error) {\n      return handleError(error, 'Error getting thread');\n    }\n  },\n});\n\nexport const LIST_MESSAGES_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/threads/:threadId/messages',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: listMessagesQuerySchema,\n  responseSchema: listMessagesResponseSchema,\n  summary: 'List thread messages',\n  description: 'Returns a paginated list of messages in a conversation thread',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({\n    mastra,\n    agentId,\n    threadId,\n    resourceId,\n    perPage,\n    page,\n    orderBy,\n    include,\n    filter,\n    requestContext,\n  }) => {\n    try {\n      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);\n      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);\n      validateBody({ threadId: effectiveThreadId });\n\n      if (!effectiveThreadId) {\n        throw new HTTPException(400, { message: 'No threadId found' });\n      }\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (memory) {\n        const thread = await memory.getThreadById({ threadId: effectiveThreadId });\n        if (!thread) {\n          throw new HTTPException(404, { message: 'Thread not found' });\n        }\n        await validateThreadOwnership(thread, effectiveResourceId);\n\n        const result = await memory.recall({\n          threadId: effectiveThreadId,\n          resourceId: effectiveResourceId,\n          perPage,\n          page,\n          orderBy,\n          include,\n          filter,\n        });\n        return result;\n      }\n\n      // Only fallback to storage if no agentId was provided\n      if (!agentId) {\n        const storage = getStorageFromContext({ mastra });\n        if (storage) {\n          const memoryStore = await storage.getStore('memory');\n          if (memoryStore) {\n            const thread = await memoryStore.getThreadById({ threadId: effectiveThreadId });\n            if (!thread) {\n              throw new HTTPException(404, { message: 'Thread not found' });\n            }\n            await validateThreadOwnership(thread, effectiveResourceId);\n\n            const result = await memoryStore.listMessages({\n              threadId: effectiveThreadId,\n              resourceId: effectiveResourceId,\n              perPage,\n              page,\n              orderBy,\n              include,\n              filter,\n            });\n            return result;\n          }\n        }\n      }\n\n      // Return empty messages when memory is not configured (Issue #11765)\n      // This allows the playground UI to gracefully handle agents without memory\n      return { messages: [], uiMessages: [] };\n    } catch (error) {\n      return handleError(error, 'Error getting messages');\n    }\n  },\n});\n\nexport const GET_WORKING_MEMORY_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/threads/:threadId/working-memory',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: getWorkingMemoryQuerySchema,\n  responseSchema: getWorkingMemoryResponseSchema,\n  summary: 'Get working memory',\n  description: 'Returns the working memory state for a thread',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, threadId, resourceId, requestContext, memoryConfig }) => {\n    try {\n      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);\n      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      validateBody({ threadId: effectiveThreadId });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n      const thread = await memory.getThreadById({ threadId: effectiveThreadId! });\n      if (thread) {\n        await validateThreadOwnership(thread, effectiveResourceId);\n      }\n      const threadExists = !!thread;\n      const template = await memory.getWorkingMemoryTemplate({ memoryConfig });\n      const workingMemoryTemplate =\n        template?.format === 'json'\n          ? { ...template, content: JSON.stringify(generateEmptyFromSchema(template.content)) }\n          : template;\n      const workingMemory = await memory.getWorkingMemory({\n        threadId: effectiveThreadId!,\n        resourceId: effectiveResourceId,\n        memoryConfig,\n      });\n      const config = memory.getMergedThreadConfig(memoryConfig || {});\n      const source: 'thread' | 'resource' =\n        config.workingMemory?.scope !== 'thread' && effectiveResourceId ? 'resource' : 'thread';\n      return { workingMemory, source, workingMemoryTemplate, threadExists };\n    } catch (error) {\n      return handleError(error, 'Error getting working memory');\n    }\n  },\n});\n\nexport const SAVE_MESSAGES_ROUTE = createRoute({\n  method: 'POST',\n  path: '/memory/save-messages',\n  responseType: 'json',\n  queryParamSchema: agentIdQuerySchema,\n  bodySchema: saveMessagesBodySchema,\n  responseSchema: saveMessagesResponseSchema,\n  summary: 'Save messages',\n  description: 'Saves new messages to memory',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, messages, requestContext }) => {\n    try {\n      const effectiveResourceId = getEffectiveResourceId(requestContext, undefined);\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      if (!messages) {\n        throw new HTTPException(400, { message: 'Messages are required' });\n      }\n\n      if (!Array.isArray(messages)) {\n        throw new HTTPException(400, { message: 'Messages should be an array' });\n      }\n\n      // Validate that all messages have threadId and resourceId\n      const invalidMessages = messages.filter(message => !message.threadId || !message.resourceId);\n      if (invalidMessages.length > 0) {\n        throw new HTTPException(400, {\n          message: `All messages must have threadId and resourceId fields. Found ${invalidMessages.length} invalid message(s).`,\n        });\n      }\n\n      // If effectiveResourceId is set, validate all messages belong to this resource\n      if (effectiveResourceId) {\n        const unauthorizedMessages = messages.filter(message => message.resourceId !== effectiveResourceId);\n        if (unauthorizedMessages.length > 0) {\n          throw new HTTPException(403, {\n            message: 'Access denied: cannot save messages for a different resource',\n          });\n        }\n\n        // Validate that all threads belong to this resource (prevents cross-resource data pollution)\n        const threadIds = [...new Set(messages.map(m => m.threadId).filter(Boolean))] as string[];\n        for (const threadId of threadIds) {\n          const thread = await memory.getThreadById({ threadId });\n          // Thread may not exist yet (will be created on first message save), which is allowed\n          // But if it exists, it must belong to the same resource\n          await validateThreadOwnership(thread, effectiveResourceId);\n        }\n      }\n\n      const processedMessages = messages.map(message => ({\n        ...message,\n        id: message.id || memory.generateId(),\n        createdAt: message.createdAt ? new Date(message.createdAt) : new Date(),\n      }));\n\n      const result = await memory.saveMessages({ messages: processedMessages as any, memoryConfig: {} });\n      return result;\n    } catch (error) {\n      return handleError(error, 'Error saving messages');\n    }\n  },\n});\n\nexport const CREATE_THREAD_ROUTE = createRoute({\n  method: 'POST',\n  path: '/memory/threads',\n  responseType: 'json',\n  queryParamSchema: agentIdQuerySchema,\n  bodySchema: createThreadBodySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Create thread',\n  description: 'Creates a new conversation thread',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, resourceId, title, metadata, threadId, requestContext }) => {\n    try {\n      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      validateBody({ resourceId: effectiveResourceId });\n\n      const result = await memory.createThread({\n        resourceId: effectiveResourceId!,\n        title,\n        metadata,\n        threadId,\n      });\n      return result;\n    } catch (error) {\n      return handleError(error, 'Error saving thread to memory');\n    }\n  },\n});\n\nexport const UPDATE_THREAD_ROUTE = createRoute({\n  method: 'PATCH',\n  path: '/memory/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: agentIdQuerySchema,\n  bodySchema: updateThreadBodySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Update thread',\n  description: 'Updates a conversation thread',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, threadId, title, metadata, resourceId, requestContext }) => {\n    try {\n      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);\n      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      const updatedAt = new Date();\n\n      validateBody({ threadId: effectiveThreadId });\n\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      const thread = await memory.getThreadById({ threadId: effectiveThreadId! });\n      if (!thread) {\n        throw new HTTPException(404, { message: 'Thread not found' });\n      }\n      await validateThreadOwnership(thread, effectiveResourceId);\n\n      const updatedThread = {\n        ...thread,\n        title: title || thread.title,\n        metadata: metadata || thread.metadata,\n        // Don't allow changing resourceId if effectiveResourceId is set (prevents reassigning threads)\n        resourceId: effectiveResourceId || resourceId || thread.resourceId,\n        createdAt: thread.createdAt,\n        updatedAt,\n      };\n\n      const result = await memory.saveThread({ thread: updatedThread });\n      return {\n        ...result,\n        resourceId: result.resourceId ?? null,\n      };\n    } catch (error) {\n      return handleError(error, 'Error updating thread');\n    }\n  },\n});\n\nexport const DELETE_THREAD_ROUTE = createRoute({\n  method: 'DELETE',\n  path: '/memory/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: deleteThreadQuerySchema,\n  responseSchema: deleteThreadResponseSchema,\n  summary: 'Delete thread',\n  description: 'Deletes a conversation thread',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, threadId, resourceId, requestContext }) => {\n    try {\n      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);\n      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);\n      validateBody({ threadId: effectiveThreadId });\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      const thread = await memory.getThreadById({ threadId: effectiveThreadId! });\n      if (!thread) {\n        throw new HTTPException(404, { message: 'Thread not found' });\n      }\n      await validateThreadOwnership(thread, effectiveResourceId);\n\n      await memory.deleteThread(effectiveThreadId!);\n      return { result: 'Thread deleted' };\n    } catch (error) {\n      return handleError(error, 'Error deleting thread');\n    }\n  },\n});\n\nexport const CLONE_THREAD_ROUTE = createRoute({\n  method: 'POST',\n  path: '/memory/threads/:threadId/clone',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: agentIdQuerySchema,\n  bodySchema: cloneThreadBodySchema,\n  responseSchema: cloneThreadResponseSchema,\n  summary: 'Clone thread',\n  description: 'Creates a copy of a conversation thread with all its messages',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, threadId, newThreadId, resourceId, title, metadata, options, requestContext }) => {\n    try {\n      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);\n      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);\n      validateBody({ threadId: effectiveThreadId });\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      // Validate source thread ownership\n      const sourceThread = await memory.getThreadById({ threadId: effectiveThreadId! });\n      if (!sourceThread) {\n        throw new HTTPException(404, { message: 'Source thread not found' });\n      }\n      await validateThreadOwnership(sourceThread, effectiveResourceId);\n\n      const result = await memory.cloneThread({\n        sourceThreadId: effectiveThreadId!,\n        newThreadId,\n        // Use effective resourceId for the cloned thread\n        resourceId: effectiveResourceId,\n        title,\n        metadata,\n        options,\n      });\n\n      return result;\n    } catch (error) {\n      return handleError(error, 'Error cloning thread');\n    }\n  },\n});\n\nexport const UPDATE_WORKING_MEMORY_ROUTE = createRoute({\n  method: 'POST',\n  path: '/memory/threads/:threadId/working-memory',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: agentIdQuerySchema,\n  bodySchema: updateWorkingMemoryBodySchema,\n  responseSchema: updateWorkingMemoryResponseSchema,\n  summary: 'Update working memory',\n  description: 'Updates the working memory state for a thread',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, threadId, resourceId, memoryConfig, workingMemory, requestContext }) => {\n    try {\n      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);\n      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);\n      validateBody({ threadId: effectiveThreadId, workingMemory });\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n      const thread = await memory.getThreadById({ threadId: effectiveThreadId! });\n      if (!thread) {\n        throw new HTTPException(404, { message: 'Thread not found' });\n      }\n      await validateThreadOwnership(thread, effectiveResourceId);\n\n      await memory.updateWorkingMemory({\n        threadId: effectiveThreadId!,\n        resourceId: effectiveResourceId,\n        workingMemory,\n        memoryConfig,\n      });\n      return { success: true };\n    } catch (error) {\n      return handleError(error, 'Error updating working memory');\n    }\n  },\n});\n\nexport const DELETE_MESSAGES_ROUTE = createRoute({\n  method: 'POST',\n  path: '/memory/messages/delete',\n  responseType: 'json',\n  queryParamSchema: deleteMessagesQuerySchema,\n  bodySchema: deleteMessagesBodySchema,\n  responseSchema: deleteMessagesResponseSchema,\n  summary: 'Delete messages',\n  description: 'Deletes specific messages from memory',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, resourceId, messageIds, requestContext }) => {\n    try {\n      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);\n\n      if (messageIds === undefined || messageIds === null) {\n        throw new HTTPException(400, { message: 'messageIds is required' });\n      }\n\n      // Normalize messageIds to the format expected by deleteMessages\n      // Convert single values to arrays and extract IDs from objects\n      let normalizedIds: string[] | { id: string }[];\n\n      if (Array.isArray(messageIds)) {\n        // Already an array - keep as is (could be string[] or { id: string }[])\n        normalizedIds = messageIds;\n      } else if (typeof messageIds === 'string') {\n        // Single string ID - wrap in array\n        normalizedIds = [messageIds];\n      } else {\n        // Single object with id property - wrap in array\n        normalizedIds = [messageIds];\n      }\n\n      // Extract string IDs for validation and deletion\n      const stringIds = normalizedIds.map(id => (typeof id === 'string' ? id : id.id));\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n\n      // If effectiveResourceId is set, validate ownership of all messages before deletion\n      // Fail closed: if we can't verify ownership, deny deletion\n      if (effectiveResourceId && stringIds.length > 0) {\n        const storage = memory?.storage || getStorageFromContext({ mastra });\n        if (!storage) {\n          throw new HTTPException(403, { message: 'Access denied: unable to verify message ownership' });\n        }\n        const memoryStore = await storage.getStore('memory');\n        if (!memoryStore) {\n          throw new HTTPException(400, { message: 'Memory is not initialized' });\n        }\n\n        // Get messages to find their threads\n        const { messages } = await memoryStore.listMessagesById({ messageIds: stringIds });\n\n        // Collect unique thread IDs\n        const threadIds = [...new Set(messages.map(m => m.threadId).filter(Boolean))] as string[];\n\n        // Validate ownership of all threads\n        for (const threadId of threadIds) {\n          const thread = await memoryStore.getThreadById({ threadId });\n          if (thread && thread.resourceId && thread.resourceId !== effectiveResourceId) {\n            throw new HTTPException(403, {\n              message: 'Access denied: message belongs to a thread owned by a different resource',\n            });\n          }\n        }\n      }\n\n      if (memory) {\n        await memory.deleteMessages(normalizedIds);\n      } else if (!agentId) {\n        // Only fallback to storage if no agentId was provided\n        const storage = getStorageFromContext({ mastra });\n        if (storage) {\n          const memoryStore = await storage.getStore('memory');\n          if (memoryStore) {\n            await memoryStore.deleteMessages(stringIds);\n          } else {\n            throw new HTTPException(400, { message: 'Memory is not initialized' });\n          }\n        } else {\n          throw new HTTPException(400, { message: 'Memory is not initialized' });\n        }\n      } else {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      // Count messages for response\n      const count = Array.isArray(messageIds) ? messageIds.length : 1;\n\n      return { success: true, message: `${count} message${count === 1 ? '' : 's'} deleted successfully` };\n    } catch (error) {\n      return handleError(error, 'Error deleting messages');\n    }\n  },\n});\n\nexport const SEARCH_MEMORY_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/search',\n  responseType: 'json',\n  queryParamSchema: searchMemoryQuerySchema,\n  responseSchema: searchMemoryResponseSchema,\n  summary: 'Search memory',\n  description: 'Searches across memory using semantic or text search',\n  tags: ['Memory'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, searchQuery, resourceId, threadId, limit = 20, requestContext, memoryConfig }) => {\n    try {\n      const effectiveResourceId = getEffectiveResourceId(requestContext, resourceId);\n      const effectiveThreadId = getEffectiveThreadId(requestContext, threadId);\n      validateBody({ searchQuery, resourceId: effectiveResourceId });\n\n      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });\n      if (!memory) {\n        throw new HTTPException(400, { message: 'Memory is not initialized' });\n      }\n\n      // Get memory configuration first to check scope\n      const config = memory.getMergedThreadConfig(memoryConfig || {});\n      const hasSemanticRecall = !!config?.semanticRecall;\n      const resourceScope =\n        typeof config?.semanticRecall === 'object' ? config?.semanticRecall?.scope !== 'thread' : true;\n\n      const searchResults: SearchResult[] = [];\n\n      // If threadId is provided and scope is thread-based, check if the thread exists\n      if (effectiveThreadId && !resourceScope) {\n        const thread = await memory.getThreadById({ threadId: effectiveThreadId });\n        if (!thread) {\n          // Thread doesn't exist yet (new unsaved thread) - return empty results\n          return {\n            results: [],\n            count: 0,\n            query: searchQuery,\n            searchScope: resourceScope ? 'resource' : 'thread',\n            searchType: hasSemanticRecall ? 'semantic' : 'text',\n          };\n        }\n        await validateThreadOwnership(thread, effectiveResourceId);\n      }\n\n      // Use effectiveThreadId or find one from the resource\n      let searchThreadId = effectiveThreadId;\n\n      // If no threadId provided, get one from the resource\n      if (!searchThreadId) {\n        const { threads } = await memory.listThreads({\n          filter: { resourceId: effectiveResourceId },\n          page: 0,\n          perPage: 1,\n          orderBy: { field: 'updatedAt', direction: 'DESC' },\n        });\n\n        if (threads.length === 0) {\n          return {\n            results: [],\n            count: 0,\n            query: searchQuery,\n            searchScope: resourceScope ? 'resource' : 'thread',\n            searchType: hasSemanticRecall ? 'semantic' : 'text',\n          };\n        }\n\n        // Use first thread - Memory class will handle scope internally\n        searchThreadId = threads[0]!.id;\n      }\n\n      const beforeRange =\n        typeof config.semanticRecall === `boolean`\n          ? 2\n          : typeof config.semanticRecall?.messageRange === `number`\n            ? config.semanticRecall.messageRange\n            : config.semanticRecall?.messageRange.before || 2;\n      const afterRange =\n        typeof config.semanticRecall === `boolean`\n          ? 2\n          : typeof config.semanticRecall?.messageRange === `number`\n            ? config.semanticRecall.messageRange\n            : config.semanticRecall?.messageRange.after || 2;\n\n      if (resourceScope && config.semanticRecall) {\n        config.semanticRecall =\n          typeof config.semanticRecall === `boolean`\n            ? // make message range 0 so we can highlight the matches in search, message range will include other messages, not the matching ones\n              // and we add prev/next messages in a special section on each message anyway\n              { messageRange: 0, topK: 2, scope: 'resource' }\n            : { ...config.semanticRecall, messageRange: 0 };\n      }\n\n      // Single call to recall - just like the agent does\n      // The Memory class handles scope (thread vs resource) internally\n      const threadConfig = memory.getMergedThreadConfig(config || {});\n      if (!threadConfig.lastMessages && !threadConfig.semanticRecall) {\n        return { results: [], count: 0, query: searchQuery };\n      }\n\n      const result = await memory.recall({\n        threadId: searchThreadId,\n        resourceId: effectiveResourceId,\n        perPage: threadConfig.lastMessages,\n        threadConfig: config,\n        vectorSearchString: threadConfig.semanticRecall && searchQuery ? searchQuery : undefined,\n      });\n\n      // Get all threads to build context and show which thread each message is from\n      // Fetch threads by IDs from the actual messages to avoid truncation\n      const threadIds = Array.from(\n        new Set(result.messages.map((m: MastraDBMessage) => m.threadId || searchThreadId!).filter(Boolean)),\n      );\n      const fetched = await Promise.all(threadIds.map((id: string) => memory.getThreadById({ threadId: id })));\n      const threadMap = new Map(fetched.filter(Boolean).map(t => [t!.id, t!]));\n\n      // Process each message in the results\n      for (const msg of result.messages) {\n        const content = getTextContent(msg);\n\n        const msgThreadId = msg.threadId || searchThreadId;\n        const thread = threadMap.get(msgThreadId);\n\n        // Get thread messages for context\n        const threadMessages = (await memory.recall({ threadId: msgThreadId })).messages;\n        const messageIndex = threadMessages.findIndex(m => m.id === msg.id);\n\n        const searchResult: SearchResult = {\n          id: msg.id,\n          role: msg.role,\n          content,\n          createdAt: msg.createdAt,\n          threadId: msgThreadId,\n          threadTitle: thread?.title || msgThreadId,\n        };\n\n        if (messageIndex !== -1) {\n          searchResult.context = {\n            before: threadMessages.slice(Math.max(0, messageIndex - beforeRange), messageIndex).map(m => ({\n              id: m.id,\n              role: m.role,\n              content: getTextContent(m),\n              createdAt: m.createdAt || new Date(),\n            })),\n            after: threadMessages.slice(messageIndex + 1, messageIndex + afterRange + 1).map(m => ({\n              id: m.id,\n              role: m.role,\n              content: getTextContent(m),\n              createdAt: m.createdAt || new Date(),\n            })),\n          };\n        }\n\n        searchResults.push(searchResult);\n      }\n\n      // Sort by date (newest first) and limit\n      const sortedResults = searchResults\n        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())\n        .slice(0, limit);\n\n      return {\n        results: sortedResults,\n        count: sortedResults.length,\n        query: searchQuery,\n        searchScope: resourceScope ? 'resource' : 'thread',\n        searchType: hasSemanticRecall ? 'semantic' : 'text',\n      };\n    } catch (error) {\n      return handleError(error, 'Error searching memory');\n    }\n  },\n});\n\n// Network routes (same handlers with /network/ prefix)\nexport const GET_MEMORY_STATUS_NETWORK_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/network/status',\n  responseType: 'json',\n  queryParamSchema: getMemoryStatusNetworkQuerySchema,\n  responseSchema: memoryStatusResponseSchema,\n  summary: 'Get memory status (network)',\n  description: 'Returns the current status of the memory system (network route)',\n  tags: ['Memory - Network'],\n  requiresAuth: true,\n  handler: GET_MEMORY_STATUS_ROUTE.handler,\n});\n\nexport const LIST_THREADS_NETWORK_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/network/threads',\n  responseType: 'json',\n  queryParamSchema: listThreadsNetworkQuerySchema,\n  responseSchema: listThreadsResponseSchema,\n  summary: 'List memory threads (network)',\n  description: 'Returns a paginated list of conversation threads (network route)',\n  tags: ['Memory - Network'],\n  requiresAuth: true,\n  handler: LIST_THREADS_ROUTE.handler,\n});\n\nexport const GET_THREAD_BY_ID_NETWORK_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/network/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: getThreadByIdNetworkQuerySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Get thread by ID (network)',\n  description: 'Returns details for a specific conversation thread (network route)',\n  tags: ['Memory - Network'],\n  requiresAuth: true,\n  handler: GET_THREAD_BY_ID_ROUTE.handler,\n});\n\nexport const LIST_MESSAGES_NETWORK_ROUTE = createRoute({\n  method: 'GET',\n  path: '/memory/network/threads/:threadId/messages',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: listMessagesNetworkQuerySchema,\n  responseSchema: listMessagesResponseSchema,\n  summary: 'List thread messages (network)',\n  description: 'Returns a paginated list of messages in a conversation thread (network route)',\n  tags: ['Memory - Network'],\n  requiresAuth: true,\n  handler: LIST_MESSAGES_ROUTE.handler,\n});\n\nexport const SAVE_MESSAGES_NETWORK_ROUTE = createRoute({\n  method: 'POST',\n  path: '/memory/network/save-messages',\n  responseType: 'json',\n  queryParamSchema: saveMessagesNetworkQuerySchema,\n  bodySchema: saveMessagesBodySchema,\n  responseSchema: saveMessagesResponseSchema,\n  summary: 'Save messages (network)',\n  description: 'Saves new messages to memory (network route)',\n  tags: ['Memory - Network'],\n  requiresAuth: true,\n  handler: SAVE_MESSAGES_ROUTE.handler,\n});\n\nexport const CREATE_THREAD_NETWORK_ROUTE = createRoute({\n  method: 'POST',\n  path: '/memory/network/threads',\n  responseType: 'json',\n  queryParamSchema: createThreadNetworkQuerySchema,\n  bodySchema: createThreadBodySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Create thread (network)',\n  description: 'Creates a new conversation thread (network route)',\n  tags: ['Memory - Network'],\n  requiresAuth: true,\n  handler: CREATE_THREAD_ROUTE.handler,\n});\n\nexport const UPDATE_THREAD_NETWORK_ROUTE = createRoute({\n  method: 'PATCH',\n  path: '/memory/network/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: updateThreadNetworkQuerySchema,\n  bodySchema: updateThreadBodySchema,\n  responseSchema: getThreadByIdResponseSchema,\n  summary: 'Update thread (network)',\n  description: 'Updates a conversation thread (network route)',\n  tags: ['Memory - Network'],\n  requiresAuth: true,\n  handler: UPDATE_THREAD_ROUTE.handler,\n});\n\nexport const DELETE_THREAD_NETWORK_ROUTE = createRoute({\n  method: 'DELETE',\n  path: '/memory/network/threads/:threadId',\n  responseType: 'json',\n  pathParamSchema: threadIdPathParams,\n  queryParamSchema: deleteThreadNetworkQuerySchema,\n  responseSchema: deleteThreadResponseSchema,\n  summary: 'Delete thread (network)',\n  description: 'Deletes a conversation thread (network route)',\n  tags: ['Memory - Network'],\n  requiresAuth: true,\n  handler: DELETE_THREAD_ROUTE.handler,\n});\n\nexport const DELETE_MESSAGES_NETWORK_ROUTE = createRoute({\n  method: 'POST',\n  path: '/memory/network/messages/delete',\n  responseType: 'json',\n  queryParamSchema: deleteMessagesNetworkQuerySchema,\n  bodySchema: deleteMessagesBodySchema,\n  responseSchema: deleteMessagesResponseSchema,\n  summary: 'Delete messages (network)',\n  description: 'Deletes specific messages from memory (network route)',\n  tags: ['Memory - Network'],\n  requiresAuth: true,\n  handler: DELETE_MESSAGES_ROUTE.handler,\n});\n","import z from 'zod';\nimport { paginationInfoSchema, createPagePaginationSchema, successResponseSchema } from './common';\n\n// Path parameter schemas\nexport const threadIdPathParams = z.object({\n  threadId: z.string().describe('Unique identifier for the conversation thread'),\n});\n\n/**\n * Common query parameter: required agent ID\n */\nexport const agentIdQuerySchema = z.object({\n  agentId: z.string(),\n});\n\n/**\n * Common query parameter: optional agent ID\n * Used for read operations that can fall back to storage when agentId is not provided\n */\nexport const optionalAgentIdQuerySchema = z.object({\n  agentId: z.string().optional(),\n});\n\n/**\n * Storage order by configuration for threads and agents (have both createdAt and updatedAt)\n * Handles JSON parsing from query strings\n */\nconst storageOrderBySchema = z.preprocess(\n  val => {\n    if (typeof val === 'string') {\n      try {\n        return JSON.parse(val);\n      } catch {\n        return undefined;\n      }\n    }\n    return val;\n  },\n  z\n    .object({\n      field: z.enum(['createdAt', 'updatedAt']).optional(),\n      direction: z.enum(['ASC', 'DESC']).optional(),\n    })\n    .optional(),\n);\n\n/**\n * Storage order by configuration for messages (only have createdAt)\n * Handles JSON parsing from query strings\n */\nconst messageOrderBySchema = z.preprocess(\n  val => {\n    if (typeof val === 'string') {\n      try {\n        return JSON.parse(val);\n      } catch {\n        return undefined;\n      }\n    }\n    return val;\n  },\n  z\n    .object({\n      field: z.enum(['createdAt']).optional(),\n      direction: z.enum(['ASC', 'DESC']).optional(),\n    })\n    .optional(),\n);\n\n/**\n * Include schema for message listing - handles JSON parsing from query strings\n */\nconst includeSchema = z.preprocess(\n  val => {\n    if (typeof val === 'string') {\n      try {\n        return JSON.parse(val);\n      } catch {\n        // Return invalid string to fail validation (z.array will reject string type)\n        return val;\n      }\n    }\n    return val;\n  },\n  z\n    .array(\n      z.object({\n        id: z.string(),\n        threadId: z.string().optional(),\n        withPreviousMessages: z.number().optional(),\n        withNextMessages: z.number().optional(),\n      }),\n    )\n    .optional(),\n);\n\n/**\n * Filter schema for message listing - handles JSON parsing from query strings\n */\nconst filterSchema = z.preprocess(\n  val => {\n    if (typeof val === 'string') {\n      try {\n        return JSON.parse(val);\n      } catch {\n        // Return invalid string to fail validation (z.object will reject string type)\n        return val;\n      }\n    }\n    return val;\n  },\n  z\n    .object({\n      dateRange: z\n        .object({\n          start: z.coerce.date().optional(),\n          end: z.coerce.date().optional(),\n        })\n        .optional(),\n      roles: z.array(z.string()).optional(),\n    })\n    .optional(),\n);\n\n/**\n * Memory config schema - handles JSON parsing from query strings\n */\nconst memoryConfigSchema = z.preprocess(val => {\n  if (typeof val === 'string') {\n    try {\n      return JSON.parse(val);\n    } catch {\n      // Return invalid string to fail validation (z.record will reject string type)\n      return val;\n    }\n  }\n  return val;\n}, z.record(z.string(), z.unknown()).optional());\n\n/**\n * Thread object structure\n */\nconst threadSchema = z.object({\n  id: z.string(),\n  title: z.string().optional(),\n  resourceId: z.string(),\n  createdAt: z.date(),\n  updatedAt: z.date(),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n});\n\n/**\n * Message structure for storage\n * Extends coreMessageSchema with storage-specific fields\n */\nconst messageSchema = z.any();\n// const messageSchema = coreMessageSchema.extend({\n//   id: z.string(),\n//   createdAt: z.coerce.date(),\n//   threadId: z.string().optional(),\n//   resourceId: z.string().optional(),\n// });\n\n// ============================================================================\n// Query Parameter Schemas\n// ============================================================================\n\n/**\n * GET /api/memory/status\n * Includes optional resourceId and threadId for OM status lookup\n */\nexport const getMemoryStatusQuerySchema = agentIdQuerySchema.extend({\n  resourceId: z.string().optional(),\n  threadId: z.string().optional(),\n});\n\n/**\n * GET /memory/config\n */\nexport const getMemoryConfigQuerySchema = agentIdQuerySchema;\n\n/**\n * GET /memory/threads\n * agentId is optional - can use storage fallback when not provided\n * resourceId is optional - when omitted, returns all threads\n * metadata is optional - filters threads by metadata key-value pairs (AND logic)\n */\nexport const listThreadsQuerySchema = createPagePaginationSchema(100).extend({\n  agentId: z.string().optional(),\n  resourceId: z.string().optional(),\n  metadata: z.preprocess(\n    val => {\n      if (typeof val === 'string') {\n        try {\n          return JSON.parse(val);\n        } catch {\n          // Return invalid string to fail validation (z.record will reject string type)\n          return val;\n        }\n      }\n      return val;\n    },\n    z.optional(z.record(z.string(), z.any())),\n  ),\n  orderBy: storageOrderBySchema,\n});\n\n/**\n * GET /memory/threads/:threadId\n * agentId is optional - can use storage fallback when not provided\n * resourceId is optional - used for ownership validation fallback when not set via middleware\n */\nexport const getThreadByIdQuerySchema = optionalAgentIdQuerySchema.extend({\n  resourceId: z.string().optional(),\n});\n\n/**\n * GET /memory/threads/:threadId/messages\n * agentId is optional - can use storage fallback when not provided\n */\nexport const listMessagesQuerySchema = createPagePaginationSchema(40).extend({\n  agentId: z.string().optional(),\n  resourceId: z.string().optional(),\n  orderBy: messageOrderBySchema,\n  include: includeSchema,\n  filter: filterSchema,\n});\n\n/**\n * GET /memory/threads/:threadId/working-memory\n */\nexport const getWorkingMemoryQuerySchema = z.object({\n  agentId: z.string(),\n  resourceId: z.string().optional(),\n  memoryConfig: memoryConfigSchema,\n});\n\n/**\n * DELETE /memory/threads/:threadId\n * agentId is required\n * resourceId is optional - used for ownership validation fallback when not set via middleware\n */\nexport const deleteThreadQuerySchema = agentIdQuerySchema.extend({\n  resourceId: z.string().optional(),\n});\n\n/**\n * POST /memory/messages/delete\n * agentId is required\n * resourceId is optional - used for ownership validation fallback when not set via middleware\n */\nexport const deleteMessagesQuerySchema = agentIdQuerySchema.extend({\n  resourceId: z.string().optional(),\n});\n\n// ============================================================================\n// Legacy /network Query Parameter Schemas (backward compatibility)\n// ============================================================================\n\n/**\n * GET /memory/network/status\n */\nexport const getMemoryStatusNetworkQuerySchema = agentIdQuerySchema;\n\n/**\n * GET /memory/network/threads\n * agentId is optional - can use storage fallback when not provided\n * resourceId is optional - when omitted, returns all threads\n * metadata is optional - filters threads by metadata key-value pairs (AND logic)\n */\nexport const listThreadsNetworkQuerySchema = createPagePaginationSchema(100).extend({\n  agentId: z.string().optional(),\n  resourceId: z.string().optional(),\n  metadata: z.preprocess(\n    val => {\n      if (typeof val === 'string') {\n        try {\n          return JSON.parse(val);\n        } catch {\n          // Return invalid string to fail validation (z.record will reject string type)\n          return val;\n        }\n      }\n      return val;\n    },\n    z.optional(z.record(z.string(), z.any())),\n  ),\n  orderBy: storageOrderBySchema,\n});\n\n/**\n * GET /memory/network/threads/:threadId\n * agentId is optional - can use storage fallback when not provided\n * resourceId is optional - used for ownership validation fallback when not set via middleware\n */\nexport const getThreadByIdNetworkQuerySchema = optionalAgentIdQuerySchema.extend({\n  resourceId: z.string().optional(),\n});\n\n/**\n * GET /memory/network/threads/:threadId/messages\n * agentId is optional - can use storage fallback when not provided\n */\nexport const listMessagesNetworkQuerySchema = createPagePaginationSchema(40).extend({\n  agentId: z.string().optional(),\n  resourceId: z.string().optional(),\n  orderBy: messageOrderBySchema,\n  include: includeSchema,\n  filter: filterSchema,\n});\n\n/**\n * POST /memory/network/save-messages\n */\nexport const saveMessagesNetworkQuerySchema = agentIdQuerySchema;\n\n/**\n * POST /memory/network/threads\n */\nexport const createThreadNetworkQuerySchema = agentIdQuerySchema;\n\n/**\n * PATCH /memory/network/threads/:threadId\n */\nexport const updateThreadNetworkQuerySchema = agentIdQuerySchema;\n\n/**\n * DELETE /memory/network/threads/:threadId\n * resourceId is optional - used for ownership validation fallback when not set via middleware\n */\nexport const deleteThreadNetworkQuerySchema = agentIdQuerySchema.extend({\n  resourceId: z.string().optional(),\n});\n\n/**\n * POST /memory/network/messages/delete\n * resourceId is optional - used for ownership validation fallback when not set via middleware\n */\nexport const deleteMessagesNetworkQuerySchema = agentIdQuerySchema.extend({\n  resourceId: z.string().optional(),\n});\n\n// ============================================================================\n// Response Schemas\n// ============================================================================\n\n/**\n * Response for GET /memory/status\n */\nexport const memoryStatusResponseSchema = z.object({\n  result: z.boolean(),\n  observationalMemory: z\n    .object({\n      enabled: z.boolean(),\n      hasRecord: z.boolean().optional(),\n      originType: z.string().optional(),\n      lastObservedAt: z.date().optional(),\n      tokenCount: z.number().optional(),\n      observationTokenCount: z.number().optional(),\n      isObserving: z.boolean().optional(),\n      isReflecting: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n/**\n * Observational Memory config schema for API responses\n */\nconst observationalMemoryConfigSchema = z.object({\n  enabled: z.boolean(),\n  scope: z.enum(['thread', 'resource']).optional(),\n  shareTokenBudget: z.boolean().optional(),\n  messageTokens: z.union([z.number(), z.object({ min: z.number(), max: z.number() })]).optional(),\n  observationTokens: z.union([z.number(), z.object({ min: z.number(), max: z.number() })]).optional(),\n  observationModel: z.string().optional(),\n  reflectionModel: z.string().optional(),\n});\n\n/**\n * Response for GET /memory/config\n * MemoryConfig is complex with many optional fields - using passthrough\n */\nexport const memoryConfigResponseSchema = z.object({\n  config: z.object({\n    lastMessages: z.union([z.number(), z.literal(false)]).optional(),\n    semanticRecall: z.union([z.boolean(), z.any()]).optional(),\n    workingMemory: z.any().optional(),\n    observationalMemory: observationalMemoryConfigSchema.optional(),\n  }),\n});\n\n/**\n * Response for GET /memory/threads\n */\nexport const listThreadsResponseSchema = paginationInfoSchema.extend({\n  threads: z.array(threadSchema),\n});\n\n/**\n * Response for GET /memory/threads/:threadId\n */\nexport const getThreadByIdResponseSchema = threadSchema;\n\n/**\n * Response for GET /memory/threads/:threadId/messages\n */\nexport const listMessagesResponseSchema = z.object({\n  messages: z.array(messageSchema),\n  uiMessages: z.unknown(), // Converted messages in UI format\n});\n\n/**\n * Response for GET /memory/threads/:threadId/working-memory\n */\nexport const getWorkingMemoryResponseSchema = z.object({\n  workingMemory: z.unknown(), // Can be string or structured object depending on template\n  source: z.enum(['thread', 'resource']),\n  workingMemoryTemplate: z.unknown(), // Template structure varies\n  threadExists: z.boolean(),\n});\n\n// ============================================================================\n// Body Parameter Schemas for POST/PUT/DELETE\n// ============================================================================\n\n/**\n * Body schema for POST /memory/messages\n */\nexport const saveMessagesBodySchema = z.object({\n  messages: z.array(messageSchema),\n});\n\n/**\n * Body schema for POST /memory/threads\n */\nexport const createThreadBodySchema = z.object({\n  resourceId: z.string(),\n  title: z.string().optional(),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n  threadId: z.string().optional(),\n});\n\n/**\n * Body schema for PUT /memory/threads/:threadId\n */\nexport const updateThreadBodySchema = z.object({\n  title: z.string().optional(),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n  resourceId: z.string().optional(),\n});\n\n/**\n * Body schema for PUT /memory/threads/:threadId/working-memory\n */\nexport const updateWorkingMemoryBodySchema = z.object({\n  workingMemory: z.string(),\n  resourceId: z.string().optional(),\n  memoryConfig: z.record(z.string(), z.unknown()).optional(),\n});\n\n/**\n * Body schema for POST /memory/messages/delete\n * Accepts: string | string[] | { id: string } | { id: string }[]\n */\nexport const deleteMessagesBodySchema = z.object({\n  messageIds: z.union([\n    z.string(),\n    z.array(z.string()),\n    z.object({ id: z.string() }),\n    z.array(z.object({ id: z.string() })),\n  ]),\n});\n\n/**\n * Query schema for GET /memory/search\n */\nexport const searchMemoryQuerySchema = z.object({\n  agentId: z.string(),\n  searchQuery: z.string(),\n  resourceId: z.string(),\n  threadId: z.string().optional(),\n  limit: z.coerce.number().optional().default(20),\n  memoryConfig: memoryConfigSchema,\n});\n\n/**\n * Response schemas\n */\nexport const saveMessagesResponseSchema = z.object({\n  messages: z.array(messageSchema),\n});\n\nexport const deleteThreadResponseSchema = z.object({\n  result: z.string(),\n});\n\nexport const updateWorkingMemoryResponseSchema = successResponseSchema;\n\nexport const deleteMessagesResponseSchema = successResponseSchema.extend({\n  message: z.string(),\n});\n\nexport const searchMemoryResponseSchema = z.object({\n  results: z.array(z.unknown()),\n  count: z.number(),\n  query: z.string(),\n  searchScope: z.string().optional(),\n  searchType: z.string().optional(),\n});\n\n/**\n * Body schema for POST /memory/threads/:threadId/clone\n */\nexport const cloneThreadBodySchema = z.object({\n  newThreadId: z.string().optional(),\n  resourceId: z.string().optional(),\n  title: z.string().optional(),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n  options: z\n    .object({\n      messageLimit: z.number().optional(),\n      messageFilter: z\n        .object({\n          startDate: z.coerce.date().optional(),\n          endDate: z.coerce.date().optional(),\n          messageIds: z.array(z.string()).optional(),\n        })\n        .optional(),\n    })\n    .optional(),\n});\n\n/**\n * Response schema for POST /memory/threads/:threadId/clone\n */\nexport const cloneThreadResponseSchema = z.object({\n  thread: threadSchema,\n  clonedMessages: z.array(messageSchema),\n});\n\n// ============================================================================\n// Observational Memory Schemas\n// ============================================================================\n\n/**\n * Query schema for GET /api/memory/observational-memory\n */\nexport const getObservationalMemoryQuerySchema = z.object({\n  agentId: z.string(),\n  resourceId: z.string().optional(),\n  threadId: z.string().optional(),\n});\n\n/**\n * Observational Memory record schema for API responses\n * Matches the ObservationalMemoryRecord type from @mastra/core/storage\n */\nconst observationalMemoryRecordSchema = z.object({\n  id: z.string(),\n  scope: z.enum(['thread', 'resource']),\n  resourceId: z.string(),\n  threadId: z.string().nullable(),\n  activeObservations: z.string(),\n  bufferedObservations: z.string().optional(),\n  bufferedReflection: z.string().optional(),\n  originType: z.enum(['initial', 'observation', 'reflection']),\n  generationCount: z.number(),\n  lastObservedAt: z.date().optional(),\n  totalTokensObserved: z.number(),\n  observationTokenCount: z.number(),\n  pendingMessageTokens: z.number(),\n  isObserving: z.boolean(),\n  isReflecting: z.boolean(),\n  config: z.record(z.string(), z.unknown()),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n  createdAt: z.date(),\n  updatedAt: z.date(),\n});\n\n/**\n * Response schema for GET /api/memory/observational-memory\n */\nexport const getObservationalMemoryResponseSchema = z.object({\n  record: observationalMemoryRecordSchema.nullable(),\n  history: z.array(observationalMemoryRecordSchema).optional(),\n});\n\n/**\n * Body schema for POST /api/memory/observational-memory/buffer-status\n */\nexport const awaitBufferStatusBodySchema = z.object({\n  agentId: z.string(),\n  resourceId: z.string().optional(),\n  threadId: z.string().optional(),\n});\n\n/**\n * Response schema for POST /api/memory/observational-memory/buffer-status\n */\nexport const awaitBufferStatusResponseSchema = z.object({\n  record: observationalMemoryRecordSchema.nullable(),\n});\n"]}