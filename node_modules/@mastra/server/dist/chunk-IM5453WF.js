import { toSlug } from './chunk-5ZYPAX2U.js';
import { createPagePaginationSchema, paginationInfoSchema } from './chunk-5CRPJSGU.js';
import { handleError } from './chunk-ONN5EA7E.js';
import { createRoute } from './chunk-D5VCL56B.js';
import { HTTPException } from './chunk-6QWQZI4Q.js';
import { LocalSkillSource } from '@mastra/core/workspace';
import z from 'zod';

var storedSkillIdPathParams = z.object({
  storedSkillId: z.string().describe("Unique identifier for the stored skill")
});
var storageOrderBySchema = z.object({
  field: z.enum(["createdAt", "updatedAt"]).optional(),
  direction: z.enum(["ASC", "DESC"]).optional()
});
var listStoredSkillsQuerySchema = createPagePaginationSchema(100).extend({
  orderBy: storageOrderBySchema.optional(),
  authorId: z.string().optional().describe("Filter skills by author identifier"),
  metadata: z.record(z.string(), z.unknown()).optional().describe("Filter skills by metadata key-value pairs")
});
var sourceSchema = z.discriminatedUnion("type", [
  z.object({
    type: z.literal("external"),
    packagePath: z.string().describe("Package path for external source")
  }),
  z.object({
    type: z.literal("local"),
    projectPath: z.string().describe("Project path for local source")
  }),
  z.object({
    type: z.literal("managed"),
    mastraPath: z.string().describe("Mastra path for managed source")
  })
]);
var snapshotConfigSchema = z.object({
  name: z.string().describe("Name of the skill"),
  description: z.string().describe("Description of what the skill does and when to use it"),
  instructions: z.string().describe("Markdown instructions for the skill"),
  license: z.string().optional().describe("License identifier for the skill"),
  compatibility: z.unknown().optional().describe("Compatibility requirements"),
  source: sourceSchema.optional().describe("Source location of the skill"),
  references: z.array(z.string()).optional().describe("List of reference file paths"),
  scripts: z.array(z.string()).optional().describe("List of script file paths"),
  assets: z.array(z.string()).optional().describe("List of asset file paths"),
  metadata: z.record(z.string(), z.unknown()).optional().describe("Additional metadata for the skill")
});
var createStoredSkillBodySchema = z.object({
  id: z.string().optional().describe("Unique identifier. If not provided, derived from name."),
  authorId: z.string().optional().describe("Author identifier for multi-tenant filtering")
}).merge(snapshotConfigSchema);
var updateStoredSkillBodySchema = z.object({
  authorId: z.string().optional()
}).partial().merge(snapshotConfigSchema.partial());
var storedSkillSchema = z.object({
  id: z.string(),
  status: z.string().describe("Skill status: draft, published, or archived"),
  activeVersionId: z.string().optional(),
  authorId: z.string().optional(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
  name: z.string().describe("Name of the skill"),
  description: z.string().describe("Description of what the skill does and when to use it"),
  instructions: z.string().describe("Markdown instructions for the skill"),
  license: z.string().optional().describe("License identifier for the skill"),
  compatibility: z.unknown().optional().describe("Compatibility requirements"),
  source: sourceSchema.optional().describe("Source location of the skill"),
  references: z.array(z.string()).optional().describe("List of reference file paths"),
  scripts: z.array(z.string()).optional().describe("List of script file paths"),
  assets: z.array(z.string()).optional().describe("List of asset file paths"),
  metadata: z.record(z.string(), z.unknown()).optional().describe("Additional metadata for the skill")
});
var listStoredSkillsResponseSchema = paginationInfoSchema.extend({
  skills: z.array(storedSkillSchema)
});
var getStoredSkillResponseSchema = storedSkillSchema;
var createStoredSkillResponseSchema = storedSkillSchema;
var updateStoredSkillResponseSchema = z.union([
  z.object({
    id: z.string(),
    status: z.string(),
    activeVersionId: z.string().optional(),
    authorId: z.string().optional(),
    createdAt: z.coerce.date(),
    updatedAt: z.coerce.date()
  }),
  storedSkillSchema
]);
var deleteStoredSkillResponseSchema = z.object({
  success: z.boolean(),
  message: z.string()
});
var publishStoredSkillBodySchema = z.object({
  skillPath: z.string().describe("Path to the skill directory on the server filesystem (containing SKILL.md)")
});
var publishStoredSkillResponseSchema = storedSkillSchema;

// src/server/handlers/stored-skills.ts
var LIST_STORED_SKILLS_ROUTE = createRoute({
  method: "GET",
  path: "/stored/skills",
  responseType: "json",
  queryParamSchema: listStoredSkillsQuerySchema,
  responseSchema: listStoredSkillsResponseSchema,
  summary: "List stored skills",
  description: "Returns a paginated list of all skill configurations stored in the database",
  tags: ["Stored Skills"],
  requiresAuth: true,
  handler: async ({ mastra, page, perPage, orderBy, authorId, metadata }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const skillStore = await storage.getStore("skills");
      if (!skillStore) {
        throw new HTTPException(500, { message: "Skills storage domain is not available" });
      }
      const result = await skillStore.listResolved({
        page,
        perPage,
        orderBy,
        authorId,
        metadata
      });
      return result;
    } catch (error) {
      return handleError(error, "Error listing stored skills");
    }
  }
});
var GET_STORED_SKILL_ROUTE = createRoute({
  method: "GET",
  path: "/stored/skills/:storedSkillId",
  responseType: "json",
  pathParamSchema: storedSkillIdPathParams,
  responseSchema: getStoredSkillResponseSchema,
  summary: "Get stored skill by ID",
  description: "Returns a specific skill from storage by its unique identifier (resolved with active version config)",
  tags: ["Stored Skills"],
  requiresAuth: true,
  handler: async ({ mastra, storedSkillId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const skillStore = await storage.getStore("skills");
      if (!skillStore) {
        throw new HTTPException(500, { message: "Skills storage domain is not available" });
      }
      const skill = await skillStore.getByIdResolved(storedSkillId);
      if (!skill) {
        throw new HTTPException(404, { message: `Stored skill with id ${storedSkillId} not found` });
      }
      return skill;
    } catch (error) {
      return handleError(error, "Error getting stored skill");
    }
  }
});
var CREATE_STORED_SKILL_ROUTE = createRoute({
  method: "POST",
  path: "/stored/skills",
  responseType: "json",
  bodySchema: createStoredSkillBodySchema,
  responseSchema: createStoredSkillResponseSchema,
  summary: "Create stored skill",
  description: "Creates a new skill configuration in storage with the provided details",
  tags: ["Stored Skills"],
  requiresAuth: true,
  handler: async ({
    mastra,
    id: providedId,
    authorId,
    name,
    description,
    instructions,
    license,
    compatibility,
    source,
    references,
    scripts,
    assets,
    metadata
  }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const skillStore = await storage.getStore("skills");
      if (!skillStore) {
        throw new HTTPException(500, { message: "Skills storage domain is not available" });
      }
      const id = providedId || toSlug(name);
      if (!id) {
        throw new HTTPException(400, {
          message: "Could not derive skill ID from name. Please provide an explicit id."
        });
      }
      const existing = await skillStore.getById(id);
      if (existing) {
        throw new HTTPException(409, { message: `Skill with id ${id} already exists` });
      }
      await skillStore.create({
        skill: {
          id,
          authorId,
          name,
          description,
          instructions,
          license,
          compatibility,
          source,
          references,
          scripts,
          assets,
          metadata
        }
      });
      const resolved = await skillStore.getByIdResolved(id);
      if (!resolved) {
        throw new HTTPException(500, { message: "Failed to resolve created skill" });
      }
      return resolved;
    } catch (error) {
      return handleError(error, "Error creating stored skill");
    }
  }
});
var UPDATE_STORED_SKILL_ROUTE = createRoute({
  method: "PATCH",
  path: "/stored/skills/:storedSkillId",
  responseType: "json",
  pathParamSchema: storedSkillIdPathParams,
  bodySchema: updateStoredSkillBodySchema,
  responseSchema: updateStoredSkillResponseSchema,
  summary: "Update stored skill",
  description: "Updates an existing skill in storage with the provided fields",
  tags: ["Stored Skills"],
  requiresAuth: true,
  handler: async ({
    mastra,
    storedSkillId,
    // Entity-level fields
    authorId,
    // Config fields (snapshot-level)
    name,
    description,
    instructions,
    license,
    compatibility,
    source,
    references,
    scripts,
    assets,
    metadata
  }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const skillStore = await storage.getStore("skills");
      if (!skillStore) {
        throw new HTTPException(500, { message: "Skills storage domain is not available" });
      }
      const existing = await skillStore.getById(storedSkillId);
      if (!existing) {
        throw new HTTPException(404, { message: `Stored skill with id ${storedSkillId} not found` });
      }
      await skillStore.update({
        id: storedSkillId,
        authorId,
        name,
        description,
        instructions,
        license,
        compatibility,
        source,
        references,
        scripts,
        assets,
        metadata
      });
      const resolved = await skillStore.getByIdResolved(storedSkillId);
      if (!resolved) {
        throw new HTTPException(500, { message: "Failed to resolve updated skill" });
      }
      return resolved;
    } catch (error) {
      return handleError(error, "Error updating stored skill");
    }
  }
});
var DELETE_STORED_SKILL_ROUTE = createRoute({
  method: "DELETE",
  path: "/stored/skills/:storedSkillId",
  responseType: "json",
  pathParamSchema: storedSkillIdPathParams,
  responseSchema: deleteStoredSkillResponseSchema,
  summary: "Delete stored skill",
  description: "Deletes a skill from storage by its unique identifier",
  tags: ["Stored Skills"],
  requiresAuth: true,
  handler: async ({ mastra, storedSkillId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const skillStore = await storage.getStore("skills");
      if (!skillStore) {
        throw new HTTPException(500, { message: "Skills storage domain is not available" });
      }
      const existing = await skillStore.getById(storedSkillId);
      if (!existing) {
        throw new HTTPException(404, { message: `Stored skill with id ${storedSkillId} not found` });
      }
      await skillStore.delete(storedSkillId);
      return {
        success: true,
        message: `Skill ${storedSkillId} deleted successfully`
      };
    } catch (error) {
      return handleError(error, "Error deleting stored skill");
    }
  }
});
var PUBLISH_STORED_SKILL_ROUTE = createRoute({
  method: "POST",
  path: "/stored/skills/:storedSkillId/publish",
  responseType: "json",
  pathParamSchema: storedSkillIdPathParams,
  bodySchema: publishStoredSkillBodySchema,
  responseSchema: publishStoredSkillResponseSchema,
  summary: "Publish stored skill",
  description: "Snapshots the skill directory from the filesystem into content-addressable blob storage, creates a new version with a tree manifest, and marks the skill as published",
  tags: ["Stored Skills"],
  requiresAuth: true,
  handler: async ({ mastra, storedSkillId, skillPath }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const skillStore = await storage.getStore("skills");
      if (!skillStore) {
        throw new HTTPException(500, { message: "Skills storage domain is not available" });
      }
      const blobStore = await storage.getStore("blobs");
      if (!blobStore) {
        throw new HTTPException(500, { message: "Blob storage domain is not available" });
      }
      const existing = await skillStore.getById(storedSkillId);
      if (!existing) {
        throw new HTTPException(404, { message: `Stored skill with id ${storedSkillId} not found` });
      }
      const path = await import('path');
      const resolvedPath = path.default.resolve(skillPath);
      const allowedBase = path.default.resolve(process.env.SKILLS_BASE_DIR || process.cwd());
      if (!resolvedPath.startsWith(allowedBase + path.default.sep) && resolvedPath !== allowedBase) {
        throw new HTTPException(400, {
          message: `skillPath must be within the allowed directory: ${allowedBase}`
        });
      }
      const source = new LocalSkillSource();
      const { publishSkillFromSource } = await import('@mastra/core/workspace');
      const { snapshot, tree } = await publishSkillFromSource(source, resolvedPath, blobStore);
      await skillStore.update({
        id: storedSkillId,
        ...snapshot,
        tree,
        status: "published"
      });
      const latestVersion = await skillStore.getLatestVersion(storedSkillId);
      if (latestVersion) {
        await skillStore.update({
          id: storedSkillId,
          activeVersionId: latestVersion.id
        });
      }
      const resolved = await skillStore.getByIdResolved(storedSkillId);
      if (!resolved) {
        throw new HTTPException(500, { message: "Failed to resolve skill after publish" });
      }
      return resolved;
    } catch (error) {
      return handleError(error, "Error publishing stored skill");
    }
  }
});

export { CREATE_STORED_SKILL_ROUTE, DELETE_STORED_SKILL_ROUTE, GET_STORED_SKILL_ROUTE, LIST_STORED_SKILLS_ROUTE, PUBLISH_STORED_SKILL_ROUTE, UPDATE_STORED_SKILL_ROUTE };
//# sourceMappingURL=chunk-IM5453WF.js.map
//# sourceMappingURL=chunk-IM5453WF.js.map