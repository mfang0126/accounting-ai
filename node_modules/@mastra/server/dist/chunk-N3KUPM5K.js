import { createListVersionsResponseSchema, createCompareVersionsResponseSchema, listVersionsQuerySchema, createVersionBodySchema, activateVersionResponseSchema, deleteVersionResponseSchema, compareVersionsQuerySchema } from './chunk-MOR4VVBW.js';
import { extractConfigFromVersion, calculateChangedFields, createVersionWithRetry, enforceRetentionLimit, computeVersionDiffs } from './chunk-BXMV3RRO.js';
import { toolConfigSchema, conditionalFieldSchema, instructionsSchema, scorerConfigSchema, serializedMemoryConfigSchema, storedProcessorGraphSchema, toolsConfigSchema, modelConfigSchema } from './chunk-EBOYKPNI.js';
import { defaultOptionsSchema } from './chunk-7XBOJMBD.js';
import { handleError } from './chunk-ONN5EA7E.js';
import { createRoute } from './chunk-D5VCL56B.js';
import { HTTPException } from './chunk-6QWQZI4Q.js';
import z from 'zod';

var mcpClientToolsConfigSchema = z.object({
  tools: z.record(z.string(), toolConfigSchema).optional()
});
var agentVersionPathParams = z.object({
  agentId: z.string().describe("Unique identifier for the stored agent")
});
var versionIdPathParams = z.object({
  agentId: z.string().describe("Unique identifier for the stored agent"),
  versionId: z.string().describe("Unique identifier for the version (UUID)")
});
var agentVersionSchema = z.object({
  id: z.string().describe("Unique identifier for the version (UUID)"),
  agentId: z.string().describe("ID of the agent this version belongs to"),
  versionNumber: z.number().describe("Sequential version number (1, 2, 3, ...)"),
  // Top-level config fields (from StorageAgentSnapshotType)
  name: z.string().describe("Name of the agent"),
  description: z.string().optional().describe("Description of the agent"),
  instructions: instructionsSchema,
  model: conditionalFieldSchema(modelConfigSchema).describe(
    "Model configuration \u2014 static value or array of conditional variants"
  ),
  tools: conditionalFieldSchema(toolsConfigSchema).optional().describe("Tool keys mapped to per-tool config \u2014 static or conditional"),
  defaultOptions: conditionalFieldSchema(defaultOptionsSchema).optional().describe("Default options for generate/stream calls \u2014 static or conditional"),
  workflows: conditionalFieldSchema(z.record(z.string(), toolConfigSchema)).optional().describe("Workflow keys with optional per-workflow config \u2014 static or conditional"),
  agents: conditionalFieldSchema(z.record(z.string(), toolConfigSchema)).optional().describe("Agent keys with optional per-agent config \u2014 static or conditional"),
  integrationTools: conditionalFieldSchema(z.record(z.string(), mcpClientToolsConfigSchema)).optional().describe("Map of tool provider IDs to their tool configurations \u2014 static or conditional"),
  mcpClients: conditionalFieldSchema(z.record(z.string(), mcpClientToolsConfigSchema)).optional().describe("Map of stored MCP client IDs to their tool configurations \u2014 static or conditional"),
  inputProcessors: conditionalFieldSchema(storedProcessorGraphSchema).optional().describe("Input processor graph \u2014 static or conditional"),
  outputProcessors: conditionalFieldSchema(storedProcessorGraphSchema).optional().describe("Output processor graph \u2014 static or conditional"),
  memory: conditionalFieldSchema(serializedMemoryConfigSchema).optional().describe("Memory configuration \u2014 static or conditional"),
  scorers: conditionalFieldSchema(z.record(z.string(), scorerConfigSchema)).optional().describe("Scorer keys with optional sampling config \u2014 static or conditional"),
  requestContextSchema: z.record(z.string(), z.unknown()).optional().describe("JSON Schema defining valid request context variables"),
  // Version metadata fields
  changedFields: z.array(z.string()).optional().describe("Array of field names that changed from the previous version"),
  changeMessage: z.string().optional().describe("Optional message describing the changes"),
  createdAt: z.coerce.date().describe("When this version was created")
});
var listVersionsResponseSchema = createListVersionsResponseSchema(agentVersionSchema);
var getVersionResponseSchema = agentVersionSchema;
var createVersionResponseSchema = agentVersionSchema.partial().merge(
  z.object({
    // These fields are always present in a version response
    id: z.string().describe("Unique identifier for the version (UUID)"),
    agentId: z.string().describe("ID of the agent this version belongs to"),
    versionNumber: z.number().describe("Sequential version number (1, 2, 3, ...)"),
    createdAt: z.coerce.date().describe("When this version was created")
  })
);
var restoreVersionResponseSchema = agentVersionSchema.describe(
  "The newly created version from the restored configuration"
);
var compareVersionsResponseSchema = createCompareVersionsResponseSchema(agentVersionSchema);

// src/server/handlers/agent-versions.ts
var SNAPSHOT_CONFIG_FIELDS = [
  "name",
  "description",
  "instructions",
  "model",
  "tools",
  "defaultOptions",
  "workflows",
  "agents",
  "integrationTools",
  "inputProcessors",
  "outputProcessors",
  "memory",
  "scorers",
  "requestContextSchema",
  "mcpClients"
];
var LIST_AGENT_VERSIONS_ROUTE = createRoute({
  method: "GET",
  path: "/stored/agents/:agentId/versions",
  requiresAuth: true,
  responseType: "json",
  pathParamSchema: agentVersionPathParams,
  queryParamSchema: listVersionsQuerySchema,
  responseSchema: listVersionsResponseSchema,
  summary: "List agent versions",
  description: "Returns a paginated list of all versions for a stored agent",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, page, perPage, orderBy }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getById(agentId);
      if (!agent) {
        throw new HTTPException(404, { message: `Agent with id ${agentId} not found` });
      }
      const result = await agentsStore.listVersions({
        agentId,
        page,
        perPage,
        orderBy
      });
      return result;
    } catch (error) {
      return handleError(error, "Error listing agent versions");
    }
  }
});
var CREATE_AGENT_VERSION_ROUTE = createRoute({
  method: "POST",
  path: "/stored/agents/:agentId/versions",
  requiresAuth: true,
  responseType: "json",
  pathParamSchema: agentVersionPathParams,
  bodySchema: createVersionBodySchema,
  responseSchema: createVersionResponseSchema,
  summary: "Create agent version",
  description: "Creates a new version snapshot of the current agent configuration",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, changeMessage }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getById(agentId);
      if (!agent) {
        throw new HTTPException(404, { message: `Agent with id ${agentId} not found` });
      }
      let currentConfig = {};
      if (agent.activeVersionId) {
        const activeVersion = await agentsStore.getVersion(agent.activeVersionId);
        if (activeVersion) {
          currentConfig = extractConfigFromVersion(
            activeVersion,
            SNAPSHOT_CONFIG_FIELDS
          );
        }
      }
      const latestVersion = await agentsStore.getLatestVersion(agentId);
      if (!agent.activeVersionId && latestVersion) {
        currentConfig = extractConfigFromVersion(
          latestVersion,
          SNAPSHOT_CONFIG_FIELDS
        );
      }
      const previousConfig = latestVersion ? extractConfigFromVersion(latestVersion, SNAPSHOT_CONFIG_FIELDS) : null;
      const changedFields = calculateChangedFields(previousConfig, currentConfig);
      const { versionId } = await createVersionWithRetry(
        agentsStore,
        agentId,
        "agentId",
        currentConfig,
        changedFields,
        { changeMessage }
      );
      const version = await agentsStore.getVersion(versionId);
      if (!version) {
        throw new HTTPException(500, { message: "Failed to retrieve created version" });
      }
      await enforceRetentionLimit(
        agentsStore,
        agentId,
        "agentId",
        agent.activeVersionId
      );
      return version;
    } catch (error) {
      return handleError(error, "Error creating agent version");
    }
  }
});
var GET_AGENT_VERSION_ROUTE = createRoute({
  method: "GET",
  path: "/stored/agents/:agentId/versions/:versionId",
  requiresAuth: true,
  responseType: "json",
  pathParamSchema: versionIdPathParams,
  responseSchema: getVersionResponseSchema,
  summary: "Get agent version",
  description: "Returns a specific version of an agent by its version ID",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, versionId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const version = await agentsStore.getVersion(versionId);
      if (!version) {
        throw new HTTPException(404, { message: `Version with id ${versionId} not found` });
      }
      if (version.agentId !== agentId) {
        throw new HTTPException(404, { message: `Version with id ${versionId} not found for agent ${agentId}` });
      }
      return version;
    } catch (error) {
      return handleError(error, "Error getting agent version");
    }
  }
});
var ACTIVATE_AGENT_VERSION_ROUTE = createRoute({
  method: "POST",
  path: "/stored/agents/:agentId/versions/:versionId/activate",
  requiresAuth: true,
  responseType: "json",
  pathParamSchema: versionIdPathParams,
  responseSchema: activateVersionResponseSchema,
  summary: "Activate agent version",
  description: "Sets a specific version as the active version for the agent",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, versionId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getById(agentId);
      if (!agent) {
        throw new HTTPException(404, { message: `Agent with id ${agentId} not found` });
      }
      const version = await agentsStore.getVersion(versionId);
      if (!version) {
        throw new HTTPException(404, { message: `Version with id ${versionId} not found` });
      }
      if (version.agentId !== agentId) {
        throw new HTTPException(404, { message: `Version with id ${versionId} not found for agent ${agentId}` });
      }
      await agentsStore.update({
        id: agentId,
        activeVersionId: versionId,
        status: "published"
      });
      mastra.getEditor()?.agent.clearCache(agentId);
      return {
        success: true,
        message: `Version ${version.versionNumber} is now active`,
        activeVersionId: versionId
      };
    } catch (error) {
      return handleError(error, "Error activating agent version");
    }
  }
});
var RESTORE_AGENT_VERSION_ROUTE = createRoute({
  method: "POST",
  path: "/stored/agents/:agentId/versions/:versionId/restore",
  requiresAuth: true,
  responseType: "json",
  pathParamSchema: versionIdPathParams,
  responseSchema: restoreVersionResponseSchema,
  summary: "Restore agent version",
  description: "Restores the agent configuration from a version, creating a new version",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, versionId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getById(agentId);
      if (!agent) {
        throw new HTTPException(404, { message: `Agent with id ${agentId} not found` });
      }
      const versionToRestore = await agentsStore.getVersion(versionId);
      if (!versionToRestore) {
        throw new HTTPException(404, { message: `Version with id ${versionId} not found` });
      }
      if (versionToRestore.agentId !== agentId) {
        throw new HTTPException(404, { message: `Version with id ${versionId} not found for agent ${agentId}` });
      }
      const restoredConfig = extractConfigFromVersion(
        versionToRestore,
        SNAPSHOT_CONFIG_FIELDS
      );
      await agentsStore.update({
        id: agentId,
        ...restoredConfig
      });
      const latestVersion = await agentsStore.getLatestVersion(agentId);
      const previousConfig = latestVersion ? extractConfigFromVersion(latestVersion, SNAPSHOT_CONFIG_FIELDS) : null;
      const changedFields = calculateChangedFields(previousConfig, restoredConfig);
      const { versionId: newVersionId } = await createVersionWithRetry(
        agentsStore,
        agentId,
        "agentId",
        restoredConfig,
        changedFields,
        {
          changeMessage: `Restored from version ${versionToRestore.versionNumber}`
        }
      );
      const newVersion = await agentsStore.getVersion(newVersionId);
      if (!newVersion) {
        throw new HTTPException(500, { message: "Failed to retrieve created version" });
      }
      await enforceRetentionLimit(
        agentsStore,
        agentId,
        "agentId",
        agent.activeVersionId
      );
      mastra.getEditor()?.agent.clearCache(agentId);
      return newVersion;
    } catch (error) {
      return handleError(error, "Error restoring agent version");
    }
  }
});
var DELETE_AGENT_VERSION_ROUTE = createRoute({
  method: "DELETE",
  path: "/stored/agents/:agentId/versions/:versionId",
  requiresAuth: true,
  responseType: "json",
  pathParamSchema: versionIdPathParams,
  responseSchema: deleteVersionResponseSchema,
  summary: "Delete agent version",
  description: "Deletes a specific version (cannot delete the active version)",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, versionId }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const agent = await agentsStore.getById(agentId);
      if (!agent) {
        throw new HTTPException(404, { message: `Agent with id ${agentId} not found` });
      }
      const version = await agentsStore.getVersion(versionId);
      if (!version) {
        throw new HTTPException(404, { message: `Version with id ${versionId} not found` });
      }
      if (version.agentId !== agentId) {
        throw new HTTPException(404, { message: `Version with id ${versionId} not found for agent ${agentId}` });
      }
      if (agent.activeVersionId === versionId) {
        throw new HTTPException(400, {
          message: "Cannot delete the active version. Activate a different version first."
        });
      }
      await agentsStore.deleteVersion(versionId);
      mastra.getEditor()?.agent.clearCache(agentId);
      return {
        success: true,
        message: `Version ${version.versionNumber} deleted successfully`
      };
    } catch (error) {
      return handleError(error, "Error deleting agent version");
    }
  }
});
var COMPARE_AGENT_VERSIONS_ROUTE = createRoute({
  method: "GET",
  path: "/stored/agents/:agentId/versions/compare",
  requiresAuth: true,
  responseType: "json",
  pathParamSchema: agentVersionPathParams,
  queryParamSchema: compareVersionsQuerySchema,
  responseSchema: compareVersionsResponseSchema,
  summary: "Compare agent versions",
  description: "Compares two versions and returns the differences between them",
  tags: ["Agent Versions"],
  handler: async ({ mastra, agentId, from, to }) => {
    try {
      const storage = mastra.getStorage();
      if (!storage) {
        throw new HTTPException(500, { message: "Storage is not configured" });
      }
      const agentsStore = await storage.getStore("agents");
      if (!agentsStore) {
        throw new HTTPException(500, { message: "Agents storage domain is not available" });
      }
      const fromVersion = await agentsStore.getVersion(from);
      if (!fromVersion) {
        throw new HTTPException(404, { message: `Version with id ${from} not found` });
      }
      if (fromVersion.agentId !== agentId) {
        throw new HTTPException(404, { message: `Version with id ${from} not found for agent ${agentId}` });
      }
      const toVersion = await agentsStore.getVersion(to);
      if (!toVersion) {
        throw new HTTPException(404, { message: `Version with id ${to} not found` });
      }
      if (toVersion.agentId !== agentId) {
        throw new HTTPException(404, { message: `Version with id ${to} not found for agent ${agentId}` });
      }
      const fromConfig = extractConfigFromVersion(
        fromVersion,
        SNAPSHOT_CONFIG_FIELDS
      );
      const toConfig = extractConfigFromVersion(
        toVersion,
        SNAPSHOT_CONFIG_FIELDS
      );
      const diffs = computeVersionDiffs(fromConfig, toConfig);
      return {
        diffs,
        fromVersion,
        toVersion
      };
    } catch (error) {
      return handleError(error, "Error comparing agent versions");
    }
  }
});

export { ACTIVATE_AGENT_VERSION_ROUTE, COMPARE_AGENT_VERSIONS_ROUTE, CREATE_AGENT_VERSION_ROUTE, DELETE_AGENT_VERSION_ROUTE, GET_AGENT_VERSION_ROUTE, LIST_AGENT_VERSIONS_ROUTE, RESTORE_AGENT_VERSION_ROUTE };
//# sourceMappingURL=chunk-N3KUPM5K.js.map
//# sourceMappingURL=chunk-N3KUPM5K.js.map