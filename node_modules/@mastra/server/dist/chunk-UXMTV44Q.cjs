'use strict';

var chunkZKMVCV4G_cjs = require('./chunk-ZKMVCV4G.cjs');
var chunkRWLJZWDL_cjs = require('./chunk-RWLJZWDL.cjs');
var chunkSUKFO7UM_cjs = require('./chunk-SUKFO7UM.cjs');
var chunk4LVJBXI2_cjs = require('./chunk-4LVJBXI2.cjs');
var chunk64ITUOXI_cjs = require('./chunk-64ITUOXI.cjs');
var chunkO7I5CWRX_cjs = require('./chunk-O7I5CWRX.cjs');
var utils = require('@mastra/core/utils');
var z = require('zod');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var z__default = /*#__PURE__*/_interopDefault(z);

// src/server/handlers/memory.ts
var memory_exports = {};
chunkO7I5CWRX_cjs.__export(memory_exports, {
  AWAIT_BUFFER_STATUS_ROUTE: () => AWAIT_BUFFER_STATUS_ROUTE,
  CLONE_THREAD_ROUTE: () => CLONE_THREAD_ROUTE,
  CREATE_THREAD_NETWORK_ROUTE: () => CREATE_THREAD_NETWORK_ROUTE,
  CREATE_THREAD_ROUTE: () => CREATE_THREAD_ROUTE,
  DELETE_MESSAGES_NETWORK_ROUTE: () => DELETE_MESSAGES_NETWORK_ROUTE,
  DELETE_MESSAGES_ROUTE: () => DELETE_MESSAGES_ROUTE,
  DELETE_THREAD_NETWORK_ROUTE: () => DELETE_THREAD_NETWORK_ROUTE,
  DELETE_THREAD_ROUTE: () => DELETE_THREAD_ROUTE,
  GET_MEMORY_CONFIG_ROUTE: () => GET_MEMORY_CONFIG_ROUTE,
  GET_MEMORY_STATUS_NETWORK_ROUTE: () => GET_MEMORY_STATUS_NETWORK_ROUTE,
  GET_MEMORY_STATUS_ROUTE: () => GET_MEMORY_STATUS_ROUTE,
  GET_OBSERVATIONAL_MEMORY_ROUTE: () => GET_OBSERVATIONAL_MEMORY_ROUTE,
  GET_THREAD_BY_ID_NETWORK_ROUTE: () => GET_THREAD_BY_ID_NETWORK_ROUTE,
  GET_THREAD_BY_ID_ROUTE: () => GET_THREAD_BY_ID_ROUTE,
  GET_WORKING_MEMORY_ROUTE: () => GET_WORKING_MEMORY_ROUTE,
  LIST_MESSAGES_NETWORK_ROUTE: () => LIST_MESSAGES_NETWORK_ROUTE,
  LIST_MESSAGES_ROUTE: () => LIST_MESSAGES_ROUTE,
  LIST_THREADS_NETWORK_ROUTE: () => LIST_THREADS_NETWORK_ROUTE,
  LIST_THREADS_ROUTE: () => LIST_THREADS_ROUTE,
  SAVE_MESSAGES_NETWORK_ROUTE: () => SAVE_MESSAGES_NETWORK_ROUTE,
  SAVE_MESSAGES_ROUTE: () => SAVE_MESSAGES_ROUTE,
  SEARCH_MEMORY_ROUTE: () => SEARCH_MEMORY_ROUTE,
  UPDATE_THREAD_NETWORK_ROUTE: () => UPDATE_THREAD_NETWORK_ROUTE,
  UPDATE_THREAD_ROUTE: () => UPDATE_THREAD_ROUTE,
  UPDATE_WORKING_MEMORY_ROUTE: () => UPDATE_WORKING_MEMORY_ROUTE,
  getTextContent: () => getTextContent
});
var threadIdPathParams = z__default.default.object({
  threadId: z__default.default.string().describe("Unique identifier for the conversation thread")
});
var agentIdQuerySchema = z__default.default.object({
  agentId: z__default.default.string()
});
var optionalAgentIdQuerySchema = z__default.default.object({
  agentId: z__default.default.string().optional()
});
var storageOrderBySchema = z__default.default.preprocess(
  (val) => {
    if (typeof val === "string") {
      try {
        return JSON.parse(val);
      } catch {
        return void 0;
      }
    }
    return val;
  },
  z__default.default.object({
    field: z__default.default.enum(["createdAt", "updatedAt"]).optional(),
    direction: z__default.default.enum(["ASC", "DESC"]).optional()
  }).optional()
);
var messageOrderBySchema = z__default.default.preprocess(
  (val) => {
    if (typeof val === "string") {
      try {
        return JSON.parse(val);
      } catch {
        return void 0;
      }
    }
    return val;
  },
  z__default.default.object({
    field: z__default.default.enum(["createdAt"]).optional(),
    direction: z__default.default.enum(["ASC", "DESC"]).optional()
  }).optional()
);
var includeSchema = z__default.default.preprocess(
  (val) => {
    if (typeof val === "string") {
      try {
        return JSON.parse(val);
      } catch {
        return val;
      }
    }
    return val;
  },
  z__default.default.array(
    z__default.default.object({
      id: z__default.default.string(),
      threadId: z__default.default.string().optional(),
      withPreviousMessages: z__default.default.number().optional(),
      withNextMessages: z__default.default.number().optional()
    })
  ).optional()
);
var filterSchema = z__default.default.preprocess(
  (val) => {
    if (typeof val === "string") {
      try {
        return JSON.parse(val);
      } catch {
        return val;
      }
    }
    return val;
  },
  z__default.default.object({
    dateRange: z__default.default.object({
      start: z__default.default.coerce.date().optional(),
      end: z__default.default.coerce.date().optional()
    }).optional(),
    roles: z__default.default.array(z__default.default.string()).optional()
  }).optional()
);
var memoryConfigSchema = z__default.default.preprocess((val) => {
  if (typeof val === "string") {
    try {
      return JSON.parse(val);
    } catch {
      return val;
    }
  }
  return val;
}, z__default.default.record(z__default.default.string(), z__default.default.unknown()).optional());
var threadSchema = z__default.default.object({
  id: z__default.default.string(),
  title: z__default.default.string().optional(),
  resourceId: z__default.default.string(),
  createdAt: z__default.default.date(),
  updatedAt: z__default.default.date(),
  metadata: z__default.default.record(z__default.default.string(), z__default.default.unknown()).optional()
});
var messageSchema = z__default.default.any();
var getMemoryStatusQuerySchema = agentIdQuerySchema.extend({
  resourceId: z__default.default.string().optional(),
  threadId: z__default.default.string().optional()
});
var getMemoryConfigQuerySchema = agentIdQuerySchema;
var listThreadsQuerySchema = chunkRWLJZWDL_cjs.createPagePaginationSchema(100).extend({
  agentId: z__default.default.string().optional(),
  resourceId: z__default.default.string().optional(),
  metadata: z__default.default.preprocess(
    (val) => {
      if (typeof val === "string") {
        try {
          return JSON.parse(val);
        } catch {
          return val;
        }
      }
      return val;
    },
    z__default.default.optional(z__default.default.record(z__default.default.string(), z__default.default.any()))
  ),
  orderBy: storageOrderBySchema
});
var getThreadByIdQuerySchema = optionalAgentIdQuerySchema.extend({
  resourceId: z__default.default.string().optional()
});
var listMessagesQuerySchema = chunkRWLJZWDL_cjs.createPagePaginationSchema(40).extend({
  agentId: z__default.default.string().optional(),
  resourceId: z__default.default.string().optional(),
  orderBy: messageOrderBySchema,
  include: includeSchema,
  filter: filterSchema
});
var getWorkingMemoryQuerySchema = z__default.default.object({
  agentId: z__default.default.string(),
  resourceId: z__default.default.string().optional(),
  memoryConfig: memoryConfigSchema
});
var deleteThreadQuerySchema = agentIdQuerySchema.extend({
  resourceId: z__default.default.string().optional()
});
var deleteMessagesQuerySchema = agentIdQuerySchema.extend({
  resourceId: z__default.default.string().optional()
});
var getMemoryStatusNetworkQuerySchema = agentIdQuerySchema;
var listThreadsNetworkQuerySchema = chunkRWLJZWDL_cjs.createPagePaginationSchema(100).extend({
  agentId: z__default.default.string().optional(),
  resourceId: z__default.default.string().optional(),
  metadata: z__default.default.preprocess(
    (val) => {
      if (typeof val === "string") {
        try {
          return JSON.parse(val);
        } catch {
          return val;
        }
      }
      return val;
    },
    z__default.default.optional(z__default.default.record(z__default.default.string(), z__default.default.any()))
  ),
  orderBy: storageOrderBySchema
});
var getThreadByIdNetworkQuerySchema = optionalAgentIdQuerySchema.extend({
  resourceId: z__default.default.string().optional()
});
var listMessagesNetworkQuerySchema = chunkRWLJZWDL_cjs.createPagePaginationSchema(40).extend({
  agentId: z__default.default.string().optional(),
  resourceId: z__default.default.string().optional(),
  orderBy: messageOrderBySchema,
  include: includeSchema,
  filter: filterSchema
});
var saveMessagesNetworkQuerySchema = agentIdQuerySchema;
var createThreadNetworkQuerySchema = agentIdQuerySchema;
var updateThreadNetworkQuerySchema = agentIdQuerySchema;
var deleteThreadNetworkQuerySchema = agentIdQuerySchema.extend({
  resourceId: z__default.default.string().optional()
});
var deleteMessagesNetworkQuerySchema = agentIdQuerySchema.extend({
  resourceId: z__default.default.string().optional()
});
var memoryStatusResponseSchema = z__default.default.object({
  result: z__default.default.boolean(),
  observationalMemory: z__default.default.object({
    enabled: z__default.default.boolean(),
    hasRecord: z__default.default.boolean().optional(),
    originType: z__default.default.string().optional(),
    lastObservedAt: z__default.default.date().optional(),
    tokenCount: z__default.default.number().optional(),
    observationTokenCount: z__default.default.number().optional(),
    isObserving: z__default.default.boolean().optional(),
    isReflecting: z__default.default.boolean().optional()
  }).optional()
});
var observationalMemoryConfigSchema = z__default.default.object({
  enabled: z__default.default.boolean(),
  scope: z__default.default.enum(["thread", "resource"]).optional(),
  shareTokenBudget: z__default.default.boolean().optional(),
  messageTokens: z__default.default.union([z__default.default.number(), z__default.default.object({ min: z__default.default.number(), max: z__default.default.number() })]).optional(),
  observationTokens: z__default.default.union([z__default.default.number(), z__default.default.object({ min: z__default.default.number(), max: z__default.default.number() })]).optional(),
  observationModel: z__default.default.string().optional(),
  reflectionModel: z__default.default.string().optional()
});
var memoryConfigResponseSchema = z__default.default.object({
  config: z__default.default.object({
    lastMessages: z__default.default.union([z__default.default.number(), z__default.default.literal(false)]).optional(),
    semanticRecall: z__default.default.union([z__default.default.boolean(), z__default.default.any()]).optional(),
    workingMemory: z__default.default.any().optional(),
    observationalMemory: observationalMemoryConfigSchema.optional()
  })
});
var listThreadsResponseSchema = chunkRWLJZWDL_cjs.paginationInfoSchema.extend({
  threads: z__default.default.array(threadSchema)
});
var getThreadByIdResponseSchema = threadSchema;
var listMessagesResponseSchema = z__default.default.object({
  messages: z__default.default.array(messageSchema),
  uiMessages: z__default.default.unknown()
  // Converted messages in UI format
});
var getWorkingMemoryResponseSchema = z__default.default.object({
  workingMemory: z__default.default.unknown(),
  // Can be string or structured object depending on template
  source: z__default.default.enum(["thread", "resource"]),
  workingMemoryTemplate: z__default.default.unknown(),
  // Template structure varies
  threadExists: z__default.default.boolean()
});
var saveMessagesBodySchema = z__default.default.object({
  messages: z__default.default.array(messageSchema)
});
var createThreadBodySchema = z__default.default.object({
  resourceId: z__default.default.string(),
  title: z__default.default.string().optional(),
  metadata: z__default.default.record(z__default.default.string(), z__default.default.unknown()).optional(),
  threadId: z__default.default.string().optional()
});
var updateThreadBodySchema = z__default.default.object({
  title: z__default.default.string().optional(),
  metadata: z__default.default.record(z__default.default.string(), z__default.default.unknown()).optional(),
  resourceId: z__default.default.string().optional()
});
var updateWorkingMemoryBodySchema = z__default.default.object({
  workingMemory: z__default.default.string(),
  resourceId: z__default.default.string().optional(),
  memoryConfig: z__default.default.record(z__default.default.string(), z__default.default.unknown()).optional()
});
var deleteMessagesBodySchema = z__default.default.object({
  messageIds: z__default.default.union([
    z__default.default.string(),
    z__default.default.array(z__default.default.string()),
    z__default.default.object({ id: z__default.default.string() }),
    z__default.default.array(z__default.default.object({ id: z__default.default.string() }))
  ])
});
var searchMemoryQuerySchema = z__default.default.object({
  agentId: z__default.default.string(),
  searchQuery: z__default.default.string(),
  resourceId: z__default.default.string(),
  threadId: z__default.default.string().optional(),
  limit: z__default.default.coerce.number().optional().default(20),
  memoryConfig: memoryConfigSchema
});
var saveMessagesResponseSchema = z__default.default.object({
  messages: z__default.default.array(messageSchema)
});
var deleteThreadResponseSchema = z__default.default.object({
  result: z__default.default.string()
});
var updateWorkingMemoryResponseSchema = chunkRWLJZWDL_cjs.successResponseSchema;
var deleteMessagesResponseSchema = chunkRWLJZWDL_cjs.successResponseSchema.extend({
  message: z__default.default.string()
});
var searchMemoryResponseSchema = z__default.default.object({
  results: z__default.default.array(z__default.default.unknown()),
  count: z__default.default.number(),
  query: z__default.default.string(),
  searchScope: z__default.default.string().optional(),
  searchType: z__default.default.string().optional()
});
var cloneThreadBodySchema = z__default.default.object({
  newThreadId: z__default.default.string().optional(),
  resourceId: z__default.default.string().optional(),
  title: z__default.default.string().optional(),
  metadata: z__default.default.record(z__default.default.string(), z__default.default.unknown()).optional(),
  options: z__default.default.object({
    messageLimit: z__default.default.number().optional(),
    messageFilter: z__default.default.object({
      startDate: z__default.default.coerce.date().optional(),
      endDate: z__default.default.coerce.date().optional(),
      messageIds: z__default.default.array(z__default.default.string()).optional()
    }).optional()
  }).optional()
});
var cloneThreadResponseSchema = z__default.default.object({
  thread: threadSchema,
  clonedMessages: z__default.default.array(messageSchema)
});
var getObservationalMemoryQuerySchema = z__default.default.object({
  agentId: z__default.default.string(),
  resourceId: z__default.default.string().optional(),
  threadId: z__default.default.string().optional()
});
var observationalMemoryRecordSchema = z__default.default.object({
  id: z__default.default.string(),
  scope: z__default.default.enum(["thread", "resource"]),
  resourceId: z__default.default.string(),
  threadId: z__default.default.string().nullable(),
  activeObservations: z__default.default.string(),
  bufferedObservations: z__default.default.string().optional(),
  bufferedReflection: z__default.default.string().optional(),
  originType: z__default.default.enum(["initial", "observation", "reflection"]),
  generationCount: z__default.default.number(),
  lastObservedAt: z__default.default.date().optional(),
  totalTokensObserved: z__default.default.number(),
  observationTokenCount: z__default.default.number(),
  pendingMessageTokens: z__default.default.number(),
  isObserving: z__default.default.boolean(),
  isReflecting: z__default.default.boolean(),
  config: z__default.default.record(z__default.default.string(), z__default.default.unknown()),
  metadata: z__default.default.record(z__default.default.string(), z__default.default.unknown()).optional(),
  createdAt: z__default.default.date(),
  updatedAt: z__default.default.date()
});
var getObservationalMemoryResponseSchema = z__default.default.object({
  record: observationalMemoryRecordSchema.nullable(),
  history: z__default.default.array(observationalMemoryRecordSchema).optional()
});
var awaitBufferStatusBodySchema = z__default.default.object({
  agentId: z__default.default.string(),
  resourceId: z__default.default.string().optional(),
  threadId: z__default.default.string().optional()
});
var awaitBufferStatusResponseSchema = z__default.default.object({
  record: observationalMemoryRecordSchema.nullable()
});

// src/server/handlers/memory.ts
function getTextContent(message) {
  if (typeof message.content === "string") {
    return message.content;
  }
  if (message.content && typeof message.content === "object" && "parts" in message.content) {
    const textPart = message.content.parts.find((p) => p.type === "text");
    return textPart?.text || "";
  }
  return "";
}
async function getMemoryFromContext({
  mastra,
  agentId,
  requestContext
}) {
  const logger = mastra.getLogger();
  let agent;
  if (agentId) {
    try {
      agent = mastra.getAgentById(agentId);
    } catch (error) {
      logger.debug("Error getting agent from mastra, searching agents for agent", error);
    }
  }
  if (agentId && !agent) {
    logger.debug("Agent not found in registered agents, trying stored agents", { agentId });
    try {
      const storedAgent = await mastra.getEditor()?.agent.getById(agentId) ?? null;
      if (storedAgent) {
        agent = storedAgent;
      }
    } catch (error) {
      logger.debug("Error getting stored agent", error);
    }
  }
  if (agentId && !agent) {
    logger.debug("Stored agent not found, searching sub-agents", { agentId });
    const agents = mastra.listAgents();
    if (Object.keys(agents || {}).length) {
      for (const [_, ag] of Object.entries(agents)) {
        try {
          const subAgents = await ag.listAgents({ requestContext });
          if (subAgents[agentId]) {
            agent = subAgents[agentId];
            break;
          }
        } catch (error) {
          logger.debug("Error getting agent from agent", error);
        }
      }
    }
    if (!agent) {
      throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Agent not found" });
    }
  }
  if (agent) {
    return await agent?.getMemory({
      requestContext
    });
  }
}
function getStorageFromContext({ mastra }) {
  return mastra.getStorage();
}
async function getAgentFromContext({
  mastra,
  agentId,
  requestContext
}) {
  if (!agentId) return null;
  const logger = mastra.getLogger();
  let agent = null;
  try {
    agent = mastra.getAgentById(agentId);
  } catch (error) {
    logger.debug("Error getting agent from mastra", error);
  }
  if (!agent) {
    logger.debug("Agent not found in registered agents, trying stored agents", { agentId });
    try {
      const storedAgent = await mastra.getEditor()?.agent.getById(agentId) ?? null;
      if (storedAgent) {
        agent = storedAgent;
      }
    } catch (error) {
      logger.debug("Error getting stored agent", error);
    }
  }
  if (!agent) {
    logger.debug("Stored agent not found, searching sub-agents", { agentId });
    const agents = mastra.listAgents();
    if (Object.keys(agents || {}).length) {
      for (const [_, ag] of Object.entries(agents)) {
        try {
          const nestedAgents = await ag.listAgents({ requestContext });
          if (nestedAgents[agentId]) {
            agent = nestedAgents[agentId];
            break;
          }
        } catch (error) {
          logger.debug("Error getting agent from agent", error);
        }
      }
    }
  }
  return agent;
}
async function getOMConfigFromAgent(agent, requestContext) {
  try {
    if (typeof agent.resolveProcessorById !== "function") {
      return null;
    }
    const omProcessor = await agent.resolveProcessorById("observational-memory", requestContext);
    if (!omProcessor) {
      return null;
    }
    const hasResolvedConfig = typeof omProcessor.getResolvedConfig === "function";
    if (hasResolvedConfig) {
      const resolvedConfig = await omProcessor.getResolvedConfig(requestContext);
      return {
        enabled: true,
        scope: resolvedConfig.scope || "resource",
        shareTokenBudget: resolvedConfig.shareTokenBudget,
        messageTokens: resolvedConfig.observation?.messageTokens,
        observationTokens: resolvedConfig.reflection?.observationTokens,
        observationModel: resolvedConfig.observation?.model,
        reflectionModel: resolvedConfig.reflection?.model
      };
    }
    const processorConfig = omProcessor.config || {};
    return {
      enabled: true,
      scope: processorConfig.scope || "resource",
      shareTokenBudget: processorConfig.shareTokenBudget,
      messageTokens: processorConfig.observation?.messageTokens,
      observationTokens: processorConfig.reflection?.observationTokens,
      observationModel: void 0,
      reflectionModel: void 0
    };
  } catch {
    return null;
  }
}
async function getOMStatus(memoryStorage, resourceId, threadId) {
  try {
    const record = await memoryStorage.getObservationalMemory(threadId ?? null, resourceId);
    if (!record) {
      return { hasRecord: false };
    }
    return {
      hasRecord: true,
      originType: record.originType,
      lastObservedAt: record.lastObservedAt ?? null,
      tokenCount: record.totalTokensObserved,
      observationTokenCount: record.observationTokenCount,
      isObserving: record.isObserving,
      isReflecting: record.isReflecting
    };
  } catch {
    return null;
  }
}
var GET_MEMORY_STATUS_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/status",
  responseType: "json",
  queryParamSchema: getMemoryStatusQuerySchema,
  responseSchema: memoryStatusResponseSchema,
  summary: "Get memory status",
  description: "Returns the current status of the memory system including configuration and health information",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, threadId, requestContext }) => {
    try {
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (memory) {
        const agent = await getAgentFromContext({ mastra, agentId, requestContext });
        let omStatus;
        if (agent) {
          const omConfig = await getOMConfigFromAgent(agent, requestContext);
          if (omConfig?.enabled && resourceId) {
            const omThreadId = omConfig.scope === "resource" ? void 0 : threadId;
            try {
              const memoryStore = await memory.storage.getStore("memory");
              if (memoryStore) {
                const status = await getOMStatus(memoryStore, resourceId, omThreadId);
                if (status) {
                  omStatus = {
                    enabled: true,
                    ...status,
                    // Convert null to undefined for schema compatibility
                    lastObservedAt: status.lastObservedAt ?? void 0
                  };
                } else {
                  omStatus = { enabled: true, hasRecord: false };
                }
              }
            } catch {
              omStatus = { enabled: true };
            }
          } else if (omConfig?.enabled) {
            omStatus = { enabled: true };
          }
        }
        return { result: true, observationalMemory: omStatus };
      }
      if (!agentId) {
        const storage = getStorageFromContext({ mastra });
        if (storage) {
          return { result: true };
        }
      }
      return { result: false };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting memory status");
    }
  }
});
var GET_MEMORY_CONFIG_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/config",
  responseType: "json",
  queryParamSchema: getMemoryConfigQuerySchema,
  responseSchema: memoryConfigResponseSchema,
  summary: "Get memory configuration",
  description: "Returns the memory configuration for a specific agent or the system default",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, requestContext }) => {
    try {
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
      }
      const config = memory.getMergedThreadConfig({});
      const agent = await getAgentFromContext({ mastra, agentId, requestContext });
      let omConfig;
      if (agent) {
        omConfig = await getOMConfigFromAgent(agent, requestContext) ?? { enabled: false };
      }
      return {
        config: {
          ...config,
          observationalMemory: omConfig
        }
      };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting memory configuration");
    }
  }
});
var GET_OBSERVATIONAL_MEMORY_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/observational-memory",
  responseType: "json",
  queryParamSchema: getObservationalMemoryQuerySchema,
  responseSchema: getObservationalMemoryResponseSchema,
  summary: "Get observational memory data",
  description: "Returns the current observational memory record and optional history for a resource/thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, threadId, requestContext }) => {
    try {
      const agent = await getAgentFromContext({ mastra, agentId, requestContext });
      if (!agent) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Agent not found" });
      }
      const omConfig = await getOMConfigFromAgent(agent, requestContext);
      if (!omConfig?.enabled) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Observational Memory is not enabled for this agent" });
      }
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not configured for this agent" });
      }
      let memoryStore;
      try {
        memoryStore = await memory.storage.getStore("memory");
      } catch {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory storage is not initialized" });
      }
      if (!memoryStore) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory storage is not initialized" });
      }
      const effectiveResourceId = resourceId;
      if (!effectiveResourceId) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "resourceId is required for observational memory lookup" });
      }
      const omThreadId = omConfig.scope === "resource" ? null : threadId ?? null;
      const record = await memoryStore.getObservationalMemory(omThreadId, effectiveResourceId);
      const history = await memoryStore.getObservationalMemoryHistory(omThreadId, effectiveResourceId, 5);
      return {
        record: record ?? null,
        history: history.length > 0 ? history : void 0
      };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting observational memory");
    }
  }
});
var AWAIT_BUFFER_STATUS_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/memory/observational-memory/buffer-status",
  responseType: "json",
  bodySchema: awaitBufferStatusBodySchema,
  responseSchema: awaitBufferStatusResponseSchema,
  summary: "Await observational memory buffering completion",
  description: "Blocks until any in-flight buffering operations complete for the given thread/resource, then returns the updated record",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, threadId, requestContext }) => {
    try {
      const agent = await getAgentFromContext({ mastra, agentId, requestContext });
      if (!agent) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Agent not found" });
      }
      const omConfig = await getOMConfigFromAgent(agent, requestContext);
      if (!omConfig?.enabled) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Observational Memory is not enabled for this agent" });
      }
      const omProcessor = await agent.resolveProcessorById("observational-memory", requestContext);
      if (!omProcessor || typeof omProcessor.waitForBuffering !== "function") {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Observational Memory processor not available" });
      }
      await omProcessor.waitForBuffering(threadId, resourceId);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not configured for this agent" });
      }
      let memoryStore;
      try {
        memoryStore = await memory.storage.getStore("memory");
      } catch {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory storage is not initialized" });
      }
      if (!memoryStore) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory storage is not initialized" });
      }
      const effectiveResourceId = resourceId;
      if (!effectiveResourceId) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "resourceId is required" });
      }
      const omThreadId = omConfig.scope === "resource" ? null : threadId ?? null;
      const record = await memoryStore.getObservationalMemory(omThreadId, effectiveResourceId);
      return { record: record ?? null };
    } catch (error) {
      console.error("Error awaiting buffer status", error);
      return chunkSUKFO7UM_cjs.handleError(error, "Error awaiting buffer status");
    }
  }
});
var LIST_THREADS_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/threads",
  responseType: "json",
  queryParamSchema: listThreadsQuerySchema,
  responseSchema: listThreadsResponseSchema,
  summary: "List memory threads",
  description: "Returns a paginated list of conversation threads with optional filtering by resource ID and/or metadata",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, metadata, requestContext, page, perPage, orderBy }) => {
    try {
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, resourceId);
      const filter = effectiveResourceId || metadata ? {} : void 0;
      if (effectiveResourceId) {
        filter.resourceId = effectiveResourceId;
      }
      if (metadata) {
        filter.metadata = metadata;
      }
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (memory) {
        const result = await memory.listThreads({
          filter,
          page,
          perPage,
          orderBy
        });
        return result;
      }
      if (!agentId) {
        const storage = getStorageFromContext({ mastra });
        if (storage) {
          const memoryStore = await storage.getStore("memory");
          if (memoryStore) {
            const result = await memoryStore.listThreads({
              filter,
              page,
              perPage,
              orderBy
            });
            return result;
          }
        }
      }
      throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error listing threads");
    }
  }
});
var GET_THREAD_BY_ID_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: getThreadByIdQuerySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Get thread by ID",
  description: "Returns details for a specific conversation thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, resourceId, requestContext }) => {
    try {
      const effectiveThreadId = chunkZKMVCV4G_cjs.getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, resourceId);
      chunkZKMVCV4G_cjs.validateBody({ threadId: effectiveThreadId });
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (memory) {
        const thread = await memory.getThreadById({ threadId: effectiveThreadId });
        if (!thread) {
          throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Thread not found" });
        }
        await chunkZKMVCV4G_cjs.validateThreadOwnership(thread, effectiveResourceId);
        return thread;
      }
      if (!agentId) {
        const storage = getStorageFromContext({ mastra });
        if (storage) {
          const memoryStore = await storage.getStore("memory");
          if (memoryStore) {
            const thread = await memoryStore.getThreadById({ threadId: effectiveThreadId });
            if (!thread) {
              throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Thread not found" });
            }
            await chunkZKMVCV4G_cjs.validateThreadOwnership(thread, effectiveResourceId);
            return thread;
          }
        }
      }
      throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting thread");
    }
  }
});
var LIST_MESSAGES_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/threads/:threadId/messages",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: listMessagesQuerySchema,
  responseSchema: listMessagesResponseSchema,
  summary: "List thread messages",
  description: "Returns a paginated list of messages in a conversation thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({
    mastra,
    agentId,
    threadId,
    resourceId,
    perPage,
    page,
    orderBy,
    include,
    filter,
    requestContext
  }) => {
    try {
      const effectiveThreadId = chunkZKMVCV4G_cjs.getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, resourceId);
      chunkZKMVCV4G_cjs.validateBody({ threadId: effectiveThreadId });
      if (!effectiveThreadId) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "No threadId found" });
      }
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (memory) {
        const thread = await memory.getThreadById({ threadId: effectiveThreadId });
        if (!thread) {
          throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Thread not found" });
        }
        await chunkZKMVCV4G_cjs.validateThreadOwnership(thread, effectiveResourceId);
        const result = await memory.recall({
          threadId: effectiveThreadId,
          resourceId: effectiveResourceId,
          perPage,
          page,
          orderBy,
          include,
          filter
        });
        return result;
      }
      if (!agentId) {
        const storage = getStorageFromContext({ mastra });
        if (storage) {
          const memoryStore = await storage.getStore("memory");
          if (memoryStore) {
            const thread = await memoryStore.getThreadById({ threadId: effectiveThreadId });
            if (!thread) {
              throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Thread not found" });
            }
            await chunkZKMVCV4G_cjs.validateThreadOwnership(thread, effectiveResourceId);
            const result = await memoryStore.listMessages({
              threadId: effectiveThreadId,
              resourceId: effectiveResourceId,
              perPage,
              page,
              orderBy,
              include,
              filter
            });
            return result;
          }
        }
      }
      return { messages: [], uiMessages: [] };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting messages");
    }
  }
});
var GET_WORKING_MEMORY_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/threads/:threadId/working-memory",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: getWorkingMemoryQuerySchema,
  responseSchema: getWorkingMemoryResponseSchema,
  summary: "Get working memory",
  description: "Returns the working memory state for a thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, resourceId, requestContext, memoryConfig }) => {
    try {
      const effectiveThreadId = chunkZKMVCV4G_cjs.getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, resourceId);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      chunkZKMVCV4G_cjs.validateBody({ threadId: effectiveThreadId });
      if (!memory) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
      }
      const thread = await memory.getThreadById({ threadId: effectiveThreadId });
      if (thread) {
        await chunkZKMVCV4G_cjs.validateThreadOwnership(thread, effectiveResourceId);
      }
      const threadExists = !!thread;
      const template = await memory.getWorkingMemoryTemplate({ memoryConfig });
      const workingMemoryTemplate = template?.format === "json" ? { ...template, content: JSON.stringify(utils.generateEmptyFromSchema(template.content)) } : template;
      const workingMemory = await memory.getWorkingMemory({
        threadId: effectiveThreadId,
        resourceId: effectiveResourceId,
        memoryConfig
      });
      const config = memory.getMergedThreadConfig(memoryConfig || {});
      const source = config.workingMemory?.scope !== "thread" && effectiveResourceId ? "resource" : "thread";
      return { workingMemory, source, workingMemoryTemplate, threadExists };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error getting working memory");
    }
  }
});
var SAVE_MESSAGES_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/memory/save-messages",
  responseType: "json",
  queryParamSchema: agentIdQuerySchema,
  bodySchema: saveMessagesBodySchema,
  responseSchema: saveMessagesResponseSchema,
  summary: "Save messages",
  description: "Saves new messages to memory",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, messages, requestContext }) => {
    try {
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, void 0);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
      }
      if (!messages) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Messages are required" });
      }
      if (!Array.isArray(messages)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Messages should be an array" });
      }
      const invalidMessages = messages.filter((message) => !message.threadId || !message.resourceId);
      if (invalidMessages.length > 0) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, {
          message: `All messages must have threadId and resourceId fields. Found ${invalidMessages.length} invalid message(s).`
        });
      }
      if (effectiveResourceId) {
        const unauthorizedMessages = messages.filter((message) => message.resourceId !== effectiveResourceId);
        if (unauthorizedMessages.length > 0) {
          throw new chunk64ITUOXI_cjs.HTTPException(403, {
            message: "Access denied: cannot save messages for a different resource"
          });
        }
        const threadIds = [...new Set(messages.map((m) => m.threadId).filter(Boolean))];
        for (const threadId of threadIds) {
          const thread = await memory.getThreadById({ threadId });
          await chunkZKMVCV4G_cjs.validateThreadOwnership(thread, effectiveResourceId);
        }
      }
      const processedMessages = messages.map((message) => ({
        ...message,
        id: message.id || memory.generateId(),
        createdAt: message.createdAt ? new Date(message.createdAt) : /* @__PURE__ */ new Date()
      }));
      const result = await memory.saveMessages({ messages: processedMessages, memoryConfig: {} });
      return result;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error saving messages");
    }
  }
});
var CREATE_THREAD_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/memory/threads",
  responseType: "json",
  queryParamSchema: agentIdQuerySchema,
  bodySchema: createThreadBodySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Create thread",
  description: "Creates a new conversation thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, title, metadata, threadId, requestContext }) => {
    try {
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, resourceId);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
      }
      chunkZKMVCV4G_cjs.validateBody({ resourceId: effectiveResourceId });
      const result = await memory.createThread({
        resourceId: effectiveResourceId,
        title,
        metadata,
        threadId
      });
      return result;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error saving thread to memory");
    }
  }
});
var UPDATE_THREAD_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "PATCH",
  path: "/memory/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: agentIdQuerySchema,
  bodySchema: updateThreadBodySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Update thread",
  description: "Updates a conversation thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, title, metadata, resourceId, requestContext }) => {
    try {
      const effectiveThreadId = chunkZKMVCV4G_cjs.getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, resourceId);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      const updatedAt = /* @__PURE__ */ new Date();
      chunkZKMVCV4G_cjs.validateBody({ threadId: effectiveThreadId });
      if (!memory) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
      }
      const thread = await memory.getThreadById({ threadId: effectiveThreadId });
      if (!thread) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Thread not found" });
      }
      await chunkZKMVCV4G_cjs.validateThreadOwnership(thread, effectiveResourceId);
      const updatedThread = {
        ...thread,
        title: title || thread.title,
        metadata: metadata || thread.metadata,
        // Don't allow changing resourceId if effectiveResourceId is set (prevents reassigning threads)
        resourceId: effectiveResourceId || resourceId || thread.resourceId,
        createdAt: thread.createdAt,
        updatedAt
      };
      const result = await memory.saveThread({ thread: updatedThread });
      return {
        ...result,
        resourceId: result.resourceId ?? null
      };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error updating thread");
    }
  }
});
var DELETE_THREAD_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "DELETE",
  path: "/memory/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: deleteThreadQuerySchema,
  responseSchema: deleteThreadResponseSchema,
  summary: "Delete thread",
  description: "Deletes a conversation thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, resourceId, requestContext }) => {
    try {
      const effectiveThreadId = chunkZKMVCV4G_cjs.getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, resourceId);
      chunkZKMVCV4G_cjs.validateBody({ threadId: effectiveThreadId });
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
      }
      const thread = await memory.getThreadById({ threadId: effectiveThreadId });
      if (!thread) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Thread not found" });
      }
      await chunkZKMVCV4G_cjs.validateThreadOwnership(thread, effectiveResourceId);
      await memory.deleteThread(effectiveThreadId);
      return { result: "Thread deleted" };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error deleting thread");
    }
  }
});
var CLONE_THREAD_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/memory/threads/:threadId/clone",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: agentIdQuerySchema,
  bodySchema: cloneThreadBodySchema,
  responseSchema: cloneThreadResponseSchema,
  summary: "Clone thread",
  description: "Creates a copy of a conversation thread with all its messages",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, newThreadId, resourceId, title, metadata, options, requestContext }) => {
    try {
      const effectiveThreadId = chunkZKMVCV4G_cjs.getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, resourceId);
      chunkZKMVCV4G_cjs.validateBody({ threadId: effectiveThreadId });
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
      }
      const sourceThread = await memory.getThreadById({ threadId: effectiveThreadId });
      if (!sourceThread) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Source thread not found" });
      }
      await chunkZKMVCV4G_cjs.validateThreadOwnership(sourceThread, effectiveResourceId);
      const result = await memory.cloneThread({
        sourceThreadId: effectiveThreadId,
        newThreadId,
        // Use effective resourceId for the cloned thread
        resourceId: effectiveResourceId,
        title,
        metadata,
        options
      });
      return result;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error cloning thread");
    }
  }
});
var UPDATE_WORKING_MEMORY_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/memory/threads/:threadId/working-memory",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: agentIdQuerySchema,
  bodySchema: updateWorkingMemoryBodySchema,
  responseSchema: updateWorkingMemoryResponseSchema,
  summary: "Update working memory",
  description: "Updates the working memory state for a thread",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, threadId, resourceId, memoryConfig, workingMemory, requestContext }) => {
    try {
      const effectiveThreadId = chunkZKMVCV4G_cjs.getEffectiveThreadId(requestContext, threadId);
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, resourceId);
      chunkZKMVCV4G_cjs.validateBody({ threadId: effectiveThreadId, workingMemory });
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
      }
      const thread = await memory.getThreadById({ threadId: effectiveThreadId });
      if (!thread) {
        throw new chunk64ITUOXI_cjs.HTTPException(404, { message: "Thread not found" });
      }
      await chunkZKMVCV4G_cjs.validateThreadOwnership(thread, effectiveResourceId);
      await memory.updateWorkingMemory({
        threadId: effectiveThreadId,
        resourceId: effectiveResourceId,
        workingMemory,
        memoryConfig
      });
      return { success: true };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error updating working memory");
    }
  }
});
var DELETE_MESSAGES_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/memory/messages/delete",
  responseType: "json",
  queryParamSchema: deleteMessagesQuerySchema,
  bodySchema: deleteMessagesBodySchema,
  responseSchema: deleteMessagesResponseSchema,
  summary: "Delete messages",
  description: "Deletes specific messages from memory",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, resourceId, messageIds, requestContext }) => {
    try {
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, resourceId);
      if (messageIds === void 0 || messageIds === null) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "messageIds is required" });
      }
      let normalizedIds;
      if (Array.isArray(messageIds)) {
        normalizedIds = messageIds;
      } else if (typeof messageIds === "string") {
        normalizedIds = [messageIds];
      } else {
        normalizedIds = [messageIds];
      }
      const stringIds = normalizedIds.map((id) => typeof id === "string" ? id : id.id);
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (effectiveResourceId && stringIds.length > 0) {
        const storage = memory?.storage || getStorageFromContext({ mastra });
        if (!storage) {
          throw new chunk64ITUOXI_cjs.HTTPException(403, { message: "Access denied: unable to verify message ownership" });
        }
        const memoryStore = await storage.getStore("memory");
        if (!memoryStore) {
          throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
        }
        const { messages } = await memoryStore.listMessagesById({ messageIds: stringIds });
        const threadIds = [...new Set(messages.map((m) => m.threadId).filter(Boolean))];
        for (const threadId of threadIds) {
          const thread = await memoryStore.getThreadById({ threadId });
          if (thread && thread.resourceId && thread.resourceId !== effectiveResourceId) {
            throw new chunk64ITUOXI_cjs.HTTPException(403, {
              message: "Access denied: message belongs to a thread owned by a different resource"
            });
          }
        }
      }
      if (memory) {
        await memory.deleteMessages(normalizedIds);
      } else if (!agentId) {
        const storage = getStorageFromContext({ mastra });
        if (storage) {
          const memoryStore = await storage.getStore("memory");
          if (memoryStore) {
            await memoryStore.deleteMessages(stringIds);
          } else {
            throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
          }
        } else {
          throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
        }
      } else {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
      }
      const count = Array.isArray(messageIds) ? messageIds.length : 1;
      return { success: true, message: `${count} message${count === 1 ? "" : "s"} deleted successfully` };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error deleting messages");
    }
  }
});
var SEARCH_MEMORY_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/search",
  responseType: "json",
  queryParamSchema: searchMemoryQuerySchema,
  responseSchema: searchMemoryResponseSchema,
  summary: "Search memory",
  description: "Searches across memory using semantic or text search",
  tags: ["Memory"],
  requiresAuth: true,
  handler: async ({ mastra, agentId, searchQuery, resourceId, threadId, limit = 20, requestContext, memoryConfig }) => {
    try {
      const effectiveResourceId = chunkZKMVCV4G_cjs.getEffectiveResourceId(requestContext, resourceId);
      const effectiveThreadId = chunkZKMVCV4G_cjs.getEffectiveThreadId(requestContext, threadId);
      chunkZKMVCV4G_cjs.validateBody({ searchQuery, resourceId: effectiveResourceId });
      const memory = await getMemoryFromContext({ mastra, agentId, requestContext });
      if (!memory) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Memory is not initialized" });
      }
      const config = memory.getMergedThreadConfig(memoryConfig || {});
      const hasSemanticRecall = !!config?.semanticRecall;
      const resourceScope = typeof config?.semanticRecall === "object" ? config?.semanticRecall?.scope !== "thread" : true;
      const searchResults = [];
      if (effectiveThreadId && !resourceScope) {
        const thread = await memory.getThreadById({ threadId: effectiveThreadId });
        if (!thread) {
          return {
            results: [],
            count: 0,
            query: searchQuery,
            searchScope: resourceScope ? "resource" : "thread",
            searchType: hasSemanticRecall ? "semantic" : "text"
          };
        }
        await chunkZKMVCV4G_cjs.validateThreadOwnership(thread, effectiveResourceId);
      }
      let searchThreadId = effectiveThreadId;
      if (!searchThreadId) {
        const { threads } = await memory.listThreads({
          filter: { resourceId: effectiveResourceId },
          page: 0,
          perPage: 1,
          orderBy: { field: "updatedAt", direction: "DESC" }
        });
        if (threads.length === 0) {
          return {
            results: [],
            count: 0,
            query: searchQuery,
            searchScope: resourceScope ? "resource" : "thread",
            searchType: hasSemanticRecall ? "semantic" : "text"
          };
        }
        searchThreadId = threads[0].id;
      }
      const beforeRange = typeof config.semanticRecall === `boolean` ? 2 : typeof config.semanticRecall?.messageRange === `number` ? config.semanticRecall.messageRange : config.semanticRecall?.messageRange.before || 2;
      const afterRange = typeof config.semanticRecall === `boolean` ? 2 : typeof config.semanticRecall?.messageRange === `number` ? config.semanticRecall.messageRange : config.semanticRecall?.messageRange.after || 2;
      if (resourceScope && config.semanticRecall) {
        config.semanticRecall = typeof config.semanticRecall === `boolean` ? (
          // make message range 0 so we can highlight the matches in search, message range will include other messages, not the matching ones
          // and we add prev/next messages in a special section on each message anyway
          { messageRange: 0, topK: 2, scope: "resource" }
        ) : { ...config.semanticRecall, messageRange: 0 };
      }
      const threadConfig = memory.getMergedThreadConfig(config || {});
      if (!threadConfig.lastMessages && !threadConfig.semanticRecall) {
        return { results: [], count: 0, query: searchQuery };
      }
      const result = await memory.recall({
        threadId: searchThreadId,
        resourceId: effectiveResourceId,
        perPage: threadConfig.lastMessages,
        threadConfig: config,
        vectorSearchString: threadConfig.semanticRecall && searchQuery ? searchQuery : void 0
      });
      const threadIds = Array.from(
        new Set(result.messages.map((m) => m.threadId || searchThreadId).filter(Boolean))
      );
      const fetched = await Promise.all(threadIds.map((id) => memory.getThreadById({ threadId: id })));
      const threadMap = new Map(fetched.filter(Boolean).map((t) => [t.id, t]));
      for (const msg of result.messages) {
        const content = getTextContent(msg);
        const msgThreadId = msg.threadId || searchThreadId;
        const thread = threadMap.get(msgThreadId);
        const threadMessages = (await memory.recall({ threadId: msgThreadId })).messages;
        const messageIndex = threadMessages.findIndex((m) => m.id === msg.id);
        const searchResult = {
          id: msg.id,
          role: msg.role,
          content,
          createdAt: msg.createdAt,
          threadId: msgThreadId,
          threadTitle: thread?.title || msgThreadId
        };
        if (messageIndex !== -1) {
          searchResult.context = {
            before: threadMessages.slice(Math.max(0, messageIndex - beforeRange), messageIndex).map((m) => ({
              id: m.id,
              role: m.role,
              content: getTextContent(m),
              createdAt: m.createdAt || /* @__PURE__ */ new Date()
            })),
            after: threadMessages.slice(messageIndex + 1, messageIndex + afterRange + 1).map((m) => ({
              id: m.id,
              role: m.role,
              content: getTextContent(m),
              createdAt: m.createdAt || /* @__PURE__ */ new Date()
            }))
          };
        }
        searchResults.push(searchResult);
      }
      const sortedResults = searchResults.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, limit);
      return {
        results: sortedResults,
        count: sortedResults.length,
        query: searchQuery,
        searchScope: resourceScope ? "resource" : "thread",
        searchType: hasSemanticRecall ? "semantic" : "text"
      };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error searching memory");
    }
  }
});
var GET_MEMORY_STATUS_NETWORK_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/network/status",
  responseType: "json",
  queryParamSchema: getMemoryStatusNetworkQuerySchema,
  responseSchema: memoryStatusResponseSchema,
  summary: "Get memory status (network)",
  description: "Returns the current status of the memory system (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: GET_MEMORY_STATUS_ROUTE.handler
});
var LIST_THREADS_NETWORK_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/network/threads",
  responseType: "json",
  queryParamSchema: listThreadsNetworkQuerySchema,
  responseSchema: listThreadsResponseSchema,
  summary: "List memory threads (network)",
  description: "Returns a paginated list of conversation threads (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: LIST_THREADS_ROUTE.handler
});
var GET_THREAD_BY_ID_NETWORK_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/network/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: getThreadByIdNetworkQuerySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Get thread by ID (network)",
  description: "Returns details for a specific conversation thread (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: GET_THREAD_BY_ID_ROUTE.handler
});
var LIST_MESSAGES_NETWORK_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/memory/network/threads/:threadId/messages",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: listMessagesNetworkQuerySchema,
  responseSchema: listMessagesResponseSchema,
  summary: "List thread messages (network)",
  description: "Returns a paginated list of messages in a conversation thread (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: LIST_MESSAGES_ROUTE.handler
});
var SAVE_MESSAGES_NETWORK_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/memory/network/save-messages",
  responseType: "json",
  queryParamSchema: saveMessagesNetworkQuerySchema,
  bodySchema: saveMessagesBodySchema,
  responseSchema: saveMessagesResponseSchema,
  summary: "Save messages (network)",
  description: "Saves new messages to memory (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: SAVE_MESSAGES_ROUTE.handler
});
var CREATE_THREAD_NETWORK_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/memory/network/threads",
  responseType: "json",
  queryParamSchema: createThreadNetworkQuerySchema,
  bodySchema: createThreadBodySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Create thread (network)",
  description: "Creates a new conversation thread (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: CREATE_THREAD_ROUTE.handler
});
var UPDATE_THREAD_NETWORK_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "PATCH",
  path: "/memory/network/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: updateThreadNetworkQuerySchema,
  bodySchema: updateThreadBodySchema,
  responseSchema: getThreadByIdResponseSchema,
  summary: "Update thread (network)",
  description: "Updates a conversation thread (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: UPDATE_THREAD_ROUTE.handler
});
var DELETE_THREAD_NETWORK_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "DELETE",
  path: "/memory/network/threads/:threadId",
  responseType: "json",
  pathParamSchema: threadIdPathParams,
  queryParamSchema: deleteThreadNetworkQuerySchema,
  responseSchema: deleteThreadResponseSchema,
  summary: "Delete thread (network)",
  description: "Deletes a conversation thread (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: DELETE_THREAD_ROUTE.handler
});
var DELETE_MESSAGES_NETWORK_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/memory/network/messages/delete",
  responseType: "json",
  queryParamSchema: deleteMessagesNetworkQuerySchema,
  bodySchema: deleteMessagesBodySchema,
  responseSchema: deleteMessagesResponseSchema,
  summary: "Delete messages (network)",
  description: "Deletes specific messages from memory (network route)",
  tags: ["Memory - Network"],
  requiresAuth: true,
  handler: DELETE_MESSAGES_ROUTE.handler
});

exports.AWAIT_BUFFER_STATUS_ROUTE = AWAIT_BUFFER_STATUS_ROUTE;
exports.CLONE_THREAD_ROUTE = CLONE_THREAD_ROUTE;
exports.CREATE_THREAD_NETWORK_ROUTE = CREATE_THREAD_NETWORK_ROUTE;
exports.CREATE_THREAD_ROUTE = CREATE_THREAD_ROUTE;
exports.DELETE_MESSAGES_NETWORK_ROUTE = DELETE_MESSAGES_NETWORK_ROUTE;
exports.DELETE_MESSAGES_ROUTE = DELETE_MESSAGES_ROUTE;
exports.DELETE_THREAD_NETWORK_ROUTE = DELETE_THREAD_NETWORK_ROUTE;
exports.DELETE_THREAD_ROUTE = DELETE_THREAD_ROUTE;
exports.GET_MEMORY_CONFIG_ROUTE = GET_MEMORY_CONFIG_ROUTE;
exports.GET_MEMORY_STATUS_NETWORK_ROUTE = GET_MEMORY_STATUS_NETWORK_ROUTE;
exports.GET_MEMORY_STATUS_ROUTE = GET_MEMORY_STATUS_ROUTE;
exports.GET_OBSERVATIONAL_MEMORY_ROUTE = GET_OBSERVATIONAL_MEMORY_ROUTE;
exports.GET_THREAD_BY_ID_NETWORK_ROUTE = GET_THREAD_BY_ID_NETWORK_ROUTE;
exports.GET_THREAD_BY_ID_ROUTE = GET_THREAD_BY_ID_ROUTE;
exports.GET_WORKING_MEMORY_ROUTE = GET_WORKING_MEMORY_ROUTE;
exports.LIST_MESSAGES_NETWORK_ROUTE = LIST_MESSAGES_NETWORK_ROUTE;
exports.LIST_MESSAGES_ROUTE = LIST_MESSAGES_ROUTE;
exports.LIST_THREADS_NETWORK_ROUTE = LIST_THREADS_NETWORK_ROUTE;
exports.LIST_THREADS_ROUTE = LIST_THREADS_ROUTE;
exports.SAVE_MESSAGES_NETWORK_ROUTE = SAVE_MESSAGES_NETWORK_ROUTE;
exports.SAVE_MESSAGES_ROUTE = SAVE_MESSAGES_ROUTE;
exports.SEARCH_MEMORY_ROUTE = SEARCH_MEMORY_ROUTE;
exports.UPDATE_THREAD_NETWORK_ROUTE = UPDATE_THREAD_NETWORK_ROUTE;
exports.UPDATE_THREAD_ROUTE = UPDATE_THREAD_ROUTE;
exports.UPDATE_WORKING_MEMORY_ROUTE = UPDATE_WORKING_MEMORY_ROUTE;
exports.getTextContent = getTextContent;
exports.memory_exports = memory_exports;
//# sourceMappingURL=chunk-UXMTV44Q.cjs.map
//# sourceMappingURL=chunk-UXMTV44Q.cjs.map