'use strict';

var chunkRWLJZWDL_cjs = require('./chunk-RWLJZWDL.cjs');
var chunkSUKFO7UM_cjs = require('./chunk-SUKFO7UM.cjs');
var chunk4LVJBXI2_cjs = require('./chunk-4LVJBXI2.cjs');
var chunk64ITUOXI_cjs = require('./chunk-64ITUOXI.cjs');
var chunkO7I5CWRX_cjs = require('./chunk-O7I5CWRX.cjs');
var llm = require('@mastra/core/llm');
var z = require('zod');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var z__default = /*#__PURE__*/_interopDefault(z);

// src/server/handlers/vector.ts
var vector_exports = {};
chunkO7I5CWRX_cjs.__export(vector_exports, {
  CREATE_INDEX_ROUTE: () => CREATE_INDEX_ROUTE,
  DELETE_INDEX_ROUTE: () => DELETE_INDEX_ROUTE,
  DESCRIBE_INDEX_ROUTE: () => DESCRIBE_INDEX_ROUTE,
  LIST_EMBEDDERS_ROUTE: () => LIST_EMBEDDERS_ROUTE,
  LIST_INDEXES_ROUTE: () => LIST_INDEXES_ROUTE,
  LIST_VECTORS_ROUTE: () => LIST_VECTORS_ROUTE,
  QUERY_VECTORS_ROUTE: () => QUERY_VECTORS_ROUTE,
  UPSERT_VECTORS_ROUTE: () => UPSERT_VECTORS_ROUTE,
  createIndex: () => createIndex,
  deleteIndex: () => deleteIndex,
  describeIndex: () => describeIndex,
  listIndexes: () => listIndexes,
  listVectorStores: () => listVectorStores,
  queryVectors: () => queryVectors,
  upsertVectors: () => upsertVectors
});
var vectorNamePathParams = z__default.default.object({
  vectorName: z__default.default.string().describe("Name of the vector store")
});
var vectorIndexPathParams = vectorNamePathParams.extend({
  indexName: z__default.default.string().describe("Name of the index")
});
var indexBodyBaseSchema = z__default.default.object({
  indexName: z__default.default.string()
});
var upsertVectorsBodySchema = indexBodyBaseSchema.extend({
  vectors: z__default.default.array(z__default.default.array(z__default.default.number())),
  metadata: z__default.default.array(z__default.default.record(z__default.default.string(), z__default.default.any())).optional(),
  ids: z__default.default.array(z__default.default.string()).optional()
});
var createIndexBodySchema = indexBodyBaseSchema.extend({
  dimension: z__default.default.number(),
  metric: z__default.default.enum(["cosine", "euclidean", "dotproduct"]).optional()
});
var queryVectorsBodySchema = indexBodyBaseSchema.extend({
  queryVector: z__default.default.array(z__default.default.number()),
  topK: z__default.default.number().optional(),
  filter: z__default.default.record(z__default.default.string(), z__default.default.any()).optional(),
  includeVector: z__default.default.boolean().optional()
});
var upsertVectorsResponseSchema = z__default.default.object({
  ids: z__default.default.array(z__default.default.string())
});
var createIndexResponseSchema = chunkRWLJZWDL_cjs.successResponseSchema;
var queryVectorsResponseSchema = z__default.default.array(z__default.default.unknown());
var listIndexesResponseSchema = z__default.default.array(z__default.default.string());
var describeIndexResponseSchema = z__default.default.object({
  dimension: z__default.default.number(),
  count: z__default.default.number(),
  metric: z__default.default.string().optional()
});
var deleteIndexResponseSchema = chunkRWLJZWDL_cjs.successResponseSchema;
var listVectorsResponseSchema = z__default.default.object({
  vectors: z__default.default.array(
    z__default.default.object({
      id: z__default.default.string(),
      name: z__default.default.string(),
      type: z__default.default.string(),
      description: z__default.default.string().optional()
    })
  )
});
var listEmbeddersResponseSchema = z__default.default.object({
  embedders: z__default.default.array(
    z__default.default.object({
      id: z__default.default.string(),
      provider: z__default.default.string(),
      name: z__default.default.string(),
      description: z__default.default.string(),
      dimensions: z__default.default.number(),
      maxInputTokens: z__default.default.number()
    })
  )
});

// src/server/handlers/vector.ts
function getVector(mastra, vectorName) {
  if (!vectorName) {
    throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Vector name is required" });
  }
  const vector = mastra.getVector(vectorName);
  if (!vector) {
    throw new chunk64ITUOXI_cjs.HTTPException(404, { message: `Vector store ${vectorName} not found` });
  }
  return vector;
}
async function upsertVectors({
  mastra,
  vectorName,
  indexName,
  vectors,
  metadata,
  ids
}) {
  try {
    if (!indexName || !vectors || !Array.isArray(vectors)) {
      throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Invalid request index. indexName and vectors array are required." });
    }
    const vector = getVector(mastra, vectorName);
    const result = await vector.upsert({ indexName, vectors, metadata, ids });
    return { ids: result };
  } catch (error) {
    return chunkSUKFO7UM_cjs.handleError(error, "Error upserting vectors");
  }
}
async function createIndex({
  mastra,
  vectorName,
  indexName,
  dimension,
  metric
}) {
  try {
    if (!indexName || typeof dimension !== "number" || dimension <= 0) {
      throw new chunk64ITUOXI_cjs.HTTPException(400, {
        message: "Invalid request index, indexName and positive dimension number are required."
      });
    }
    if (metric && !["cosine", "euclidean", "dotproduct"].includes(metric)) {
      throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Invalid metric. Must be one of: cosine, euclidean, dotproduct" });
    }
    const vector = getVector(mastra, vectorName);
    await vector.createIndex({ indexName, dimension, metric });
    return { success: true };
  } catch (error) {
    return chunkSUKFO7UM_cjs.handleError(error, "Error creating index");
  }
}
async function queryVectors({
  mastra,
  vectorName,
  indexName,
  queryVector,
  topK,
  filter,
  includeVector
}) {
  try {
    if (!indexName || !queryVector || !Array.isArray(queryVector)) {
      throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Invalid request query. indexName and queryVector array are required." });
    }
    const vector = getVector(mastra, vectorName);
    const results = await vector.query({ indexName, queryVector, topK, filter, includeVector });
    return results;
  } catch (error) {
    return chunkSUKFO7UM_cjs.handleError(error, "Error querying vectors");
  }
}
async function listIndexes({ mastra, vectorName }) {
  try {
    const vector = getVector(mastra, vectorName);
    const indexes = await vector.listIndexes();
    return indexes.filter(Boolean);
  } catch (error) {
    return chunkSUKFO7UM_cjs.handleError(error, "Error listing indexes");
  }
}
async function describeIndex({
  mastra,
  vectorName,
  indexName
}) {
  try {
    if (!indexName) {
      throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Index name is required" });
    }
    const vector = getVector(mastra, vectorName);
    const stats = await vector.describeIndex({ indexName });
    return {
      dimension: stats.dimension,
      count: stats.count,
      metric: stats.metric?.toLowerCase()
    };
  } catch (error) {
    return chunkSUKFO7UM_cjs.handleError(error, "Error describing index");
  }
}
async function deleteIndex({
  mastra,
  vectorName,
  indexName
}) {
  try {
    if (!indexName) {
      throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Index name is required" });
    }
    const vector = getVector(mastra, vectorName);
    await vector.deleteIndex({ indexName });
    return { success: true };
  } catch (error) {
    return chunkSUKFO7UM_cjs.handleError(error, "Error deleting index");
  }
}
async function listVectorStores({ mastra }) {
  try {
    const vectors = mastra.listVectors();
    if (!vectors) {
      return { vectors: [] };
    }
    const vectorList = Object.entries(vectors).map(([name, vector]) => ({
      name,
      id: vector.id,
      type: vector.constructor.name
      // Add any other metadata that might be useful
    }));
    return { vectors: vectorList };
  } catch (error) {
    return chunkSUKFO7UM_cjs.handleError(error, "Error listing vector stores");
  }
}
var UPSERT_VECTORS_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/vector/:vectorName/upsert",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  bodySchema: upsertVectorsBodySchema,
  responseSchema: upsertVectorsResponseSchema,
  summary: "Upsert vectors",
  description: "Inserts or updates vectors in the specified index",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName, ...params }) => {
    try {
      const { indexName, vectors, metadata, ids } = params;
      if (!indexName || !vectors || !Array.isArray(vectors)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Invalid request index. indexName and vectors array are required." });
      }
      const vector = getVector(mastra, vectorName);
      const result = await vector.upsert({ indexName, vectors, metadata, ids });
      return { ids: result };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error upserting vectors");
    }
  }
});
var CREATE_INDEX_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/vector/:vectorName/create-index",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  bodySchema: createIndexBodySchema,
  responseSchema: createIndexResponseSchema,
  summary: "Create index",
  description: "Creates a new vector index with the specified dimension and metric",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName, ...params }) => {
    try {
      const { indexName, dimension, metric } = params;
      if (!indexName || typeof dimension !== "number" || dimension <= 0) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, {
          message: "Invalid request index, indexName and positive dimension number are required."
        });
      }
      if (metric && !["cosine", "euclidean", "dotproduct"].includes(metric)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Invalid metric. Must be one of: cosine, euclidean, dotproduct" });
      }
      const vector = getVector(mastra, vectorName);
      await vector.createIndex({ indexName, dimension, metric });
      return { success: true };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error creating index");
    }
  }
});
var QUERY_VECTORS_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "POST",
  path: "/vector/:vectorName/query",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  bodySchema: queryVectorsBodySchema,
  responseSchema: queryVectorsResponseSchema,
  summary: "Query vectors",
  description: "Performs a similarity search on the vector index",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName, ...params }) => {
    try {
      const { indexName, queryVector, topK, filter, includeVector } = params;
      if (!indexName || !queryVector || !Array.isArray(queryVector)) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, {
          message: "Invalid request query. indexName and queryVector array are required."
        });
      }
      const vector = getVector(mastra, vectorName);
      const results = await vector.query({ indexName, queryVector, topK, filter, includeVector });
      return results;
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error querying vectors");
    }
  }
});
var LIST_INDEXES_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/vector/:vectorName/indexes",
  responseType: "json",
  pathParamSchema: vectorNamePathParams,
  responseSchema: listIndexesResponseSchema,
  summary: "List indexes",
  description: "Returns a list of all indexes in the vector store",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName }) => {
    try {
      const vector = getVector(mastra, vectorName);
      const indexes = await vector.listIndexes();
      return indexes.filter(Boolean);
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error listing indexes");
    }
  }
});
var DESCRIBE_INDEX_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/vector/:vectorName/indexes/:indexName",
  responseType: "json",
  pathParamSchema: vectorIndexPathParams,
  responseSchema: describeIndexResponseSchema,
  summary: "Describe index",
  description: "Returns statistics and metadata for a specific index",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName, indexName }) => {
    try {
      if (!indexName) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Index name is required" });
      }
      const vector = getVector(mastra, vectorName);
      const stats = await vector.describeIndex({ indexName });
      return {
        dimension: stats.dimension,
        count: stats.count,
        metric: stats.metric?.toLowerCase()
      };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error describing index");
    }
  }
});
var DELETE_INDEX_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "DELETE",
  path: "/vector/:vectorName/indexes/:indexName",
  responseType: "json",
  pathParamSchema: vectorIndexPathParams,
  responseSchema: deleteIndexResponseSchema,
  summary: "Delete index",
  description: "Deletes a vector index and all its data",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra, vectorName, indexName }) => {
    try {
      if (!indexName) {
        throw new chunk64ITUOXI_cjs.HTTPException(400, { message: "Index name is required" });
      }
      const vector = getVector(mastra, vectorName);
      await vector.deleteIndex({ indexName });
      return { success: true };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error deleting index");
    }
  }
});
var LIST_VECTORS_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/vectors",
  responseType: "json",
  responseSchema: listVectorsResponseSchema,
  summary: "List vector stores",
  description: "Returns a list of all configured vector stores",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async ({ mastra }) => {
    try {
      const vectors = mastra.listVectors();
      if (!vectors) {
        return { vectors: [] };
      }
      const vectorList = Object.entries(vectors).map(([name, vector]) => ({
        id: vector.id || name,
        // Use the key as the ID since vectors might not have their own id property
        name,
        type: vector.constructor.name
      }));
      return { vectors: vectorList };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error listing vector stores");
    }
  }
});
var LIST_EMBEDDERS_ROUTE = chunk4LVJBXI2_cjs.createRoute({
  method: "GET",
  path: "/embedders",
  responseType: "json",
  responseSchema: listEmbeddersResponseSchema,
  summary: "List available embedder models",
  description: "Returns a list of all available embedding models",
  tags: ["Vectors"],
  requiresAuth: true,
  handler: async () => {
    try {
      const embeddersList = llm.EMBEDDING_MODELS.map((model) => ({
        id: `${model.provider}/${model.id}`,
        provider: model.provider,
        name: model.id,
        description: model.description || "",
        dimensions: model.dimensions,
        maxInputTokens: model.maxInputTokens
      }));
      return { embedders: embeddersList };
    } catch (error) {
      return chunkSUKFO7UM_cjs.handleError(error, "Error listing embedders");
    }
  }
});

exports.CREATE_INDEX_ROUTE = CREATE_INDEX_ROUTE;
exports.DELETE_INDEX_ROUTE = DELETE_INDEX_ROUTE;
exports.DESCRIBE_INDEX_ROUTE = DESCRIBE_INDEX_ROUTE;
exports.LIST_EMBEDDERS_ROUTE = LIST_EMBEDDERS_ROUTE;
exports.LIST_INDEXES_ROUTE = LIST_INDEXES_ROUTE;
exports.LIST_VECTORS_ROUTE = LIST_VECTORS_ROUTE;
exports.QUERY_VECTORS_ROUTE = QUERY_VECTORS_ROUTE;
exports.UPSERT_VECTORS_ROUTE = UPSERT_VECTORS_ROUTE;
exports.createIndex = createIndex;
exports.deleteIndex = deleteIndex;
exports.describeIndex = describeIndex;
exports.listIndexes = listIndexes;
exports.listVectorStores = listVectorStores;
exports.queryVectors = queryVectors;
exports.upsertVectors = upsertVectors;
exports.vector_exports = vector_exports;
//# sourceMappingURL=chunk-EHHCBPKQ.cjs.map
//# sourceMappingURL=chunk-EHHCBPKQ.cjs.map