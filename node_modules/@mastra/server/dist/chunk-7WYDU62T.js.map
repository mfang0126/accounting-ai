{"version":3,"sources":["../src/server/schemas/stored-mcp-clients.ts","../src/server/handlers/stored-mcp-clients.ts"],"names":[],"mappings":"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","file":"chunk-7WYDU62T.js","sourcesContent":["import z from 'zod';\n\nimport { paginationInfoSchema, createPagePaginationSchema, statusQuerySchema } from './common';\n\n// ============================================================================\n// Path Parameter Schemas\n// ============================================================================\n\nexport const storedMCPClientIdPathParams = z.object({\n  storedMCPClientId: z.string().describe('Unique identifier for the stored MCP client'),\n});\n\n// ============================================================================\n// Query Parameter Schemas\n// ============================================================================\n\nconst storageOrderBySchema = z.object({\n  field: z.enum(['createdAt', 'updatedAt']).optional(),\n  direction: z.enum(['ASC', 'DESC']).optional(),\n});\n\nexport { statusQuerySchema };\n\nexport const listStoredMCPClientsQuerySchema = createPagePaginationSchema(100).extend({\n  orderBy: storageOrderBySchema.optional(),\n  status: z\n    .enum(['draft', 'published', 'archived'])\n    .optional()\n    .default('published')\n    .describe('Filter MCP clients by status (defaults to published)'),\n  authorId: z.string().optional().describe('Filter MCP clients by author identifier'),\n  metadata: z.record(z.string(), z.unknown()).optional().describe('Filter MCP clients by metadata key-value pairs'),\n});\n\n// ============================================================================\n// Body Parameter Schemas\n// ============================================================================\n\nconst mcpServerConfigSchema = z.object({\n  type: z.enum(['stdio', 'http']).describe('Transport type: stdio for local processes, http for remote servers'),\n  command: z.string().optional().describe('Command to run (stdio only)'),\n  args: z.array(z.string()).optional().describe('Command arguments (stdio only)'),\n  env: z.record(z.string(), z.string()).optional().describe('Environment variables (stdio only)'),\n  url: z.string().optional().describe('Server URL (http only)'),\n  timeout: z.number().optional().describe('Connection timeout in milliseconds'),\n});\n\nconst snapshotConfigSchema = z.object({\n  name: z.string().describe('Name of the MCP client'),\n  description: z.string().optional().describe('Description of the MCP client'),\n  servers: z.record(z.string(), mcpServerConfigSchema).describe('Map of server name to server configuration'),\n});\n\nexport const createStoredMCPClientBodySchema = z\n  .object({\n    id: z.string().optional().describe('Unique identifier. If not provided, derived from name.'),\n    authorId: z.string().optional().describe('Author identifier for multi-tenant filtering'),\n    metadata: z.record(z.string(), z.unknown()).optional().describe('Additional metadata for the MCP client'),\n  })\n  .merge(snapshotConfigSchema);\n\nexport const updateStoredMCPClientBodySchema = z\n  .object({\n    authorId: z.string().optional(),\n    metadata: z.record(z.string(), z.unknown()).optional(),\n  })\n  .partial()\n  .merge(snapshotConfigSchema.partial());\n\n// ============================================================================\n// Response Schemas\n// ============================================================================\n\nexport const storedMCPClientSchema = z.object({\n  id: z.string(),\n  status: z.string().describe('MCP client status: draft, published, or archived'),\n  activeVersionId: z.string().optional(),\n  authorId: z.string().optional(),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n  createdAt: z.coerce.date(),\n  updatedAt: z.coerce.date(),\n  name: z.string().describe('Name of the MCP client'),\n  description: z.string().optional().describe('Description of the MCP client'),\n  servers: z.record(z.string(), mcpServerConfigSchema).describe('Map of server name to server configuration'),\n});\n\nexport const listStoredMCPClientsResponseSchema = paginationInfoSchema.extend({\n  mcpClients: z.array(storedMCPClientSchema),\n});\n\nexport const getStoredMCPClientResponseSchema = storedMCPClientSchema;\nexport const createStoredMCPClientResponseSchema = storedMCPClientSchema;\n\nexport const updateStoredMCPClientResponseSchema = z.union([\n  z.object({\n    id: z.string(),\n    status: z.string(),\n    activeVersionId: z.string().optional(),\n    authorId: z.string().optional(),\n    metadata: z.record(z.string(), z.unknown()).optional(),\n    createdAt: z.coerce.date(),\n    updatedAt: z.coerce.date(),\n  }),\n  storedMCPClientSchema,\n]);\n\nexport const deleteStoredMCPClientResponseSchema = z.object({\n  success: z.boolean(),\n  message: z.string(),\n});\n","import { HTTPException } from '../http-exception';\nimport {\n  storedMCPClientIdPathParams,\n  statusQuerySchema,\n  listStoredMCPClientsQuerySchema,\n  createStoredMCPClientBodySchema,\n  updateStoredMCPClientBodySchema,\n  listStoredMCPClientsResponseSchema,\n  getStoredMCPClientResponseSchema,\n  createStoredMCPClientResponseSchema,\n  updateStoredMCPClientResponseSchema,\n  deleteStoredMCPClientResponseSchema,\n} from '../schemas/stored-mcp-clients';\nimport { createRoute } from '../server-adapter/routes/route-builder';\nimport { toSlug } from '../utils';\n\nimport { handleError } from './error';\nimport { handleAutoVersioning, MCP_CLIENT_SNAPSHOT_CONFIG_FIELDS } from './version-helpers';\nimport type { VersionedStoreInterface } from './version-helpers';\n\n// ============================================================================\n// Route Definitions\n// ============================================================================\n\n/**\n * GET /stored/mcp-clients - List all stored MCP clients\n */\nexport const LIST_STORED_MCP_CLIENTS_ROUTE = createRoute({\n  method: 'GET',\n  path: '/stored/mcp-clients',\n  responseType: 'json',\n  queryParamSchema: listStoredMCPClientsQuerySchema,\n  responseSchema: listStoredMCPClientsResponseSchema,\n  summary: 'List stored MCP clients',\n  description: 'Returns a paginated list of all MCP client configurations stored in the database',\n  tags: ['Stored MCP Clients'],\n  requiresAuth: true,\n  handler: async ({ mastra, page, perPage, orderBy, status, authorId, metadata }) => {\n    try {\n      const storage = mastra.getStorage();\n\n      if (!storage) {\n        throw new HTTPException(500, { message: 'Storage is not configured' });\n      }\n\n      const mcpClientStore = await storage.getStore('mcpClients');\n      if (!mcpClientStore) {\n        throw new HTTPException(500, { message: 'MCP clients storage domain is not available' });\n      }\n\n      const result = await mcpClientStore.listResolved({\n        page,\n        perPage,\n        orderBy,\n        status,\n        authorId,\n        metadata,\n      });\n\n      return result;\n    } catch (error) {\n      return handleError(error, 'Error listing stored MCP clients');\n    }\n  },\n});\n\n/**\n * GET /stored/mcp-clients/:storedMCPClientId - Get a stored MCP client by ID\n */\nexport const GET_STORED_MCP_CLIENT_ROUTE = createRoute({\n  method: 'GET',\n  path: '/stored/mcp-clients/:storedMCPClientId',\n  responseType: 'json',\n  pathParamSchema: storedMCPClientIdPathParams,\n  queryParamSchema: statusQuerySchema,\n  responseSchema: getStoredMCPClientResponseSchema,\n  summary: 'Get stored MCP client by ID',\n  description:\n    'Returns a specific MCP client from storage by its unique identifier. Use ?status=draft to resolve with the latest (draft) version, or ?status=published (default) for the active published version.',\n  tags: ['Stored MCP Clients'],\n  requiresAuth: true,\n  handler: async ({ mastra, storedMCPClientId, status }) => {\n    try {\n      const storage = mastra.getStorage();\n\n      if (!storage) {\n        throw new HTTPException(500, { message: 'Storage is not configured' });\n      }\n\n      const mcpClientStore = await storage.getStore('mcpClients');\n      if (!mcpClientStore) {\n        throw new HTTPException(500, { message: 'MCP clients storage domain is not available' });\n      }\n\n      const mcpClient = await mcpClientStore.getByIdResolved(storedMCPClientId, { status });\n\n      if (!mcpClient) {\n        throw new HTTPException(404, { message: `Stored MCP client with id ${storedMCPClientId} not found` });\n      }\n\n      return mcpClient;\n    } catch (error) {\n      return handleError(error, 'Error getting stored MCP client');\n    }\n  },\n});\n\n/**\n * POST /stored/mcp-clients - Create a new stored MCP client\n */\nexport const CREATE_STORED_MCP_CLIENT_ROUTE = createRoute({\n  method: 'POST',\n  path: '/stored/mcp-clients',\n  responseType: 'json',\n  bodySchema: createStoredMCPClientBodySchema,\n  responseSchema: createStoredMCPClientResponseSchema,\n  summary: 'Create stored MCP client',\n  description: 'Creates a new MCP client configuration in storage with the provided servers',\n  tags: ['Stored MCP Clients'],\n  requiresAuth: true,\n  handler: async ({ mastra, id: providedId, authorId, metadata, name, description, servers }) => {\n    try {\n      const storage = mastra.getStorage();\n\n      if (!storage) {\n        throw new HTTPException(500, { message: 'Storage is not configured' });\n      }\n\n      const mcpClientStore = await storage.getStore('mcpClients');\n      if (!mcpClientStore) {\n        throw new HTTPException(500, { message: 'MCP clients storage domain is not available' });\n      }\n\n      // Derive ID from name if not explicitly provided\n      const id = providedId || toSlug(name);\n\n      if (!id) {\n        throw new HTTPException(400, {\n          message: 'Could not derive MCP client ID from name. Please provide an explicit id.',\n        });\n      }\n\n      // Check if MCP client with this ID already exists\n      const existing = await mcpClientStore.getById(id);\n      if (existing) {\n        throw new HTTPException(409, { message: `MCP client with id ${id} already exists` });\n      }\n\n      await mcpClientStore.create({\n        mcpClient: {\n          id,\n          authorId,\n          metadata,\n          name,\n          description,\n          servers,\n        },\n      });\n\n      // Return the resolved MCP client (thin record + version config)\n      // Use draft status since newly created entities start as drafts\n      const resolved = await mcpClientStore.getByIdResolved(id, { status: 'draft' });\n      if (!resolved) {\n        throw new HTTPException(500, { message: 'Failed to resolve created MCP client' });\n      }\n\n      return resolved;\n    } catch (error) {\n      return handleError(error, 'Error creating stored MCP client');\n    }\n  },\n});\n\n/**\n * PATCH /stored/mcp-clients/:storedMCPClientId - Update a stored MCP client\n */\nexport const UPDATE_STORED_MCP_CLIENT_ROUTE = createRoute({\n  method: 'PATCH',\n  path: '/stored/mcp-clients/:storedMCPClientId',\n  responseType: 'json',\n  pathParamSchema: storedMCPClientIdPathParams,\n  bodySchema: updateStoredMCPClientBodySchema,\n  responseSchema: updateStoredMCPClientResponseSchema,\n  summary: 'Update stored MCP client',\n  description: 'Updates an existing MCP client in storage with the provided fields',\n  tags: ['Stored MCP Clients'],\n  requiresAuth: true,\n  handler: async ({\n    mastra,\n    storedMCPClientId,\n    // Metadata-level fields\n    authorId,\n    metadata,\n    // Config fields (snapshot-level)\n    name,\n    description,\n    servers,\n  }) => {\n    try {\n      const storage = mastra.getStorage();\n\n      if (!storage) {\n        throw new HTTPException(500, { message: 'Storage is not configured' });\n      }\n\n      const mcpClientStore = await storage.getStore('mcpClients');\n      if (!mcpClientStore) {\n        throw new HTTPException(500, { message: 'MCP clients storage domain is not available' });\n      }\n\n      // Check if MCP client exists\n      const existing = await mcpClientStore.getById(storedMCPClientId);\n      if (!existing) {\n        throw new HTTPException(404, { message: `Stored MCP client with id ${storedMCPClientId} not found` });\n      }\n\n      // Update the MCP client with both metadata-level and config-level fields\n      const updatedMCPClient = await mcpClientStore.update({\n        id: storedMCPClientId,\n        authorId,\n        metadata,\n        name,\n        description,\n        servers,\n      });\n\n      // Build the snapshot config for auto-versioning comparison\n      const configFields = { name, description, servers };\n\n      // Filter out undefined values to get only the config fields that were provided\n      const providedConfigFields = Object.fromEntries(Object.entries(configFields).filter(([_, v]) => v !== undefined));\n\n      // Handle auto-versioning with retry logic for race conditions\n      // This creates a new version if there are meaningful config changes.\n      // It does NOT update activeVersionId â€” the version stays as a draft until explicitly published.\n      await handleAutoVersioning(\n        mcpClientStore as unknown as VersionedStoreInterface,\n        storedMCPClientId,\n        'mcpClientId',\n        MCP_CLIENT_SNAPSHOT_CONFIG_FIELDS,\n        existing,\n        updatedMCPClient,\n        providedConfigFields,\n      );\n\n      // Return the resolved MCP client with the latest (draft) version so the UI sees its edits\n      const resolved = await mcpClientStore.getByIdResolved(storedMCPClientId, { status: 'draft' });\n      if (!resolved) {\n        throw new HTTPException(500, { message: 'Failed to resolve updated MCP client' });\n      }\n\n      return resolved;\n    } catch (error) {\n      return handleError(error, 'Error updating stored MCP client');\n    }\n  },\n});\n\n/**\n * DELETE /stored/mcp-clients/:storedMCPClientId - Delete a stored MCP client\n */\nexport const DELETE_STORED_MCP_CLIENT_ROUTE = createRoute({\n  method: 'DELETE',\n  path: '/stored/mcp-clients/:storedMCPClientId',\n  responseType: 'json',\n  pathParamSchema: storedMCPClientIdPathParams,\n  responseSchema: deleteStoredMCPClientResponseSchema,\n  summary: 'Delete stored MCP client',\n  description: 'Deletes an MCP client from storage by its unique identifier',\n  tags: ['Stored MCP Clients'],\n  requiresAuth: true,\n  handler: async ({ mastra, storedMCPClientId }) => {\n    try {\n      const storage = mastra.getStorage();\n\n      if (!storage) {\n        throw new HTTPException(500, { message: 'Storage is not configured' });\n      }\n\n      const mcpClientStore = await storage.getStore('mcpClients');\n      if (!mcpClientStore) {\n        throw new HTTPException(500, { message: 'MCP clients storage domain is not available' });\n      }\n\n      // Check if MCP client exists\n      const existing = await mcpClientStore.getById(storedMCPClientId);\n      if (!existing) {\n        throw new HTTPException(404, { message: `Stored MCP client with id ${storedMCPClientId} not found` });\n      }\n\n      await mcpClientStore.delete(storedMCPClientId);\n\n      return {\n        success: true,\n        message: `MCP client ${storedMCPClientId} deleted successfully`,\n      };\n    } catch (error) {\n      return handleError(error, 'Error deleting stored MCP client');\n    }\n  },\n});\n"]}