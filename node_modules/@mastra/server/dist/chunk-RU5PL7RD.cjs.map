{"version":3,"sources":["../src/server/handlers/tools.ts"],"names":["__export","isProviderDefinedTool","stringify","zodToJsonSchema","createRoute","listToolsResponseSchema","handleError","toolIdPathParams","serializedToolSchema","HTTPException","optionalRunIdSchema","executeToolContextBodySchema","executeToolResponseSchema","validateBody","isVercelTool","result","agentToolPathParams","getAgentFromSystem","tool","executeToolBodySchema"],"mappings":"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","file":"chunk-RU5PL7RD.cjs","sourcesContent":["import { isVercelTool, isProviderDefinedTool } from '@mastra/core/tools';\nimport { zodToJsonSchema } from '@mastra/core/utils/zod-to-json';\nimport { stringify } from 'superjson';\nimport { HTTPException } from '../http-exception';\nimport {\n  executeToolContextBodySchema,\n  executeToolResponseSchema,\n  listToolsResponseSchema,\n  serializedToolSchema,\n  toolIdPathParams,\n  agentToolPathParams,\n  executeToolBodySchema,\n} from '../schemas/agents';\nimport { optionalRunIdSchema } from '../schemas/common';\nimport { createRoute } from '../server-adapter/routes/route-builder';\n\nimport { getAgentFromSystem } from './agents';\nimport { handleError } from './error';\nimport { validateBody } from './utils';\n\n/**\n * Resolves a schema value that may be a lazy function (as used by AI SDK provider tools).\n * Provider tools use lazy schemas: `inputSchema` is a function that returns an AI SDK Schema\n * object with `{ jsonSchema, validate, _type }`.\n */\nfunction resolveSchema(schema: unknown): unknown {\n  if (typeof schema === 'function') {\n    try {\n      return schema();\n    } catch {\n      return undefined;\n    }\n  }\n  return schema;\n}\n\n/**\n * Serializes a tool for API responses, handling both regular tools (with Zod schemas)\n * and provider-defined tools (with AI SDK lazy schemas).\n */\nfunction serializeTool(tool: any): any {\n  // Provider-defined tools (e.g. google.tools.googleSearch(), openai.tools.webSearch())\n  // have lazy inputSchema functions that return AI SDK Schema objects, not Zod schemas.\n  // We resolve them and use the jsonSchema property directly.\n  if (isProviderDefinedTool(tool)) {\n    const resolvedInput = resolveSchema(tool.inputSchema);\n    const resolvedOutput = resolveSchema(tool.outputSchema);\n    return {\n      ...tool,\n      inputSchema:\n        resolvedInput && typeof resolvedInput === 'object' && 'jsonSchema' in resolvedInput\n          ? stringify(resolvedInput.jsonSchema)\n          : undefined,\n      outputSchema:\n        resolvedOutput && typeof resolvedOutput === 'object' && 'jsonSchema' in resolvedOutput\n          ? stringify(resolvedOutput.jsonSchema)\n          : undefined,\n    };\n  }\n\n  return {\n    ...tool,\n    inputSchema: tool.inputSchema ? stringify(zodToJsonSchema(tool.inputSchema)) : undefined,\n    outputSchema: tool.outputSchema ? stringify(zodToJsonSchema(tool.outputSchema)) : undefined,\n    requestContextSchema: tool.requestContextSchema ? stringify(zodToJsonSchema(tool.requestContextSchema)) : undefined,\n  };\n}\n\n// ============================================================================\n// Route Definitions (new pattern - handlers defined inline with createRoute)\n// ============================================================================\n\nexport const LIST_TOOLS_ROUTE = createRoute({\n  method: 'GET',\n  path: '/tools',\n  responseType: 'json',\n  responseSchema: listToolsResponseSchema,\n  summary: 'List all tools',\n  description: 'Returns a list of all available tools in the system',\n  tags: ['Tools'],\n  requiresAuth: true,\n  handler: async ({ mastra, registeredTools }) => {\n    try {\n      const allTools =\n        registeredTools && Object.keys(registeredTools).length > 0 ? registeredTools : mastra.listTools() || {};\n\n      const serializedTools = Object.entries(allTools).reduce(\n        (acc, [id, _tool]) => {\n          acc[id] = serializeTool(_tool);\n          return acc;\n        },\n        {} as Record<string, any>,\n      );\n\n      return serializedTools;\n    } catch (error) {\n      return handleError(error, 'Error getting tools');\n    }\n  },\n});\n\nexport const GET_TOOL_BY_ID_ROUTE = createRoute({\n  method: 'GET',\n  path: '/tools/:toolId',\n  responseType: 'json',\n  pathParamSchema: toolIdPathParams,\n  responseSchema: serializedToolSchema,\n  summary: 'Get tool by ID',\n  description: 'Returns details for a specific tool including its schema and configuration',\n  tags: ['Tools'],\n  requiresAuth: true,\n  handler: async ({ mastra, registeredTools, toolId }) => {\n    try {\n      let tool: any;\n\n      // Try explicit registeredTools first, then fallback to mastra\n      if (registeredTools && Object.keys(registeredTools).length > 0) {\n        tool = Object.values(registeredTools).find((t: any) => t.id === toolId);\n      } else {\n        tool = mastra.getToolById(toolId);\n      }\n\n      if (!tool) {\n        throw new HTTPException(404, { message: 'Tool not found' });\n      }\n\n      return serializeTool(tool);\n    } catch (error) {\n      return handleError(error, 'Error getting tool');\n    }\n  },\n});\n\nexport const EXECUTE_TOOL_ROUTE = createRoute({\n  method: 'POST',\n  path: '/tools/:toolId/execute',\n  responseType: 'json',\n  pathParamSchema: toolIdPathParams,\n  queryParamSchema: optionalRunIdSchema,\n  bodySchema: executeToolContextBodySchema,\n  responseSchema: executeToolResponseSchema,\n  summary: 'Execute tool',\n  description: 'Executes a specific tool with the provided input data',\n  tags: ['Tools'],\n  requiresAuth: true,\n  handler: async ({ mastra, runId, toolId, registeredTools, requestContext, ...bodyParams }) => {\n    try {\n      if (!toolId) {\n        throw new HTTPException(400, { message: 'Tool ID is required' });\n      }\n\n      let tool: any;\n\n      // Try explicit registeredTools first, then fallback to mastra\n      if (registeredTools && Object.keys(registeredTools).length > 0) {\n        tool = Object.values(registeredTools).find((t: any) => t.id === toolId);\n      } else {\n        tool = mastra.getToolById(toolId);\n      }\n\n      if (!tool) {\n        throw new HTTPException(404, { message: 'Tool not found' });\n      }\n\n      if (!tool?.execute) {\n        throw new HTTPException(400, { message: 'Tool is not executable' });\n      }\n\n      const { data } = bodyParams;\n\n      validateBody({ data });\n\n      if (isVercelTool(tool)) {\n        const result = await (tool as any).execute(data);\n        return result;\n      }\n\n      const result = await tool.execute(data!, {\n        mastra,\n        requestContext,\n        // TODO: Pass proper tracing context when server API supports tracing\n        tracingContext: { currentSpan: undefined },\n        ...(runId\n          ? {\n              workflow: {\n                runId,\n                suspend: async () => {},\n              },\n            }\n          : {}),\n      });\n      return result;\n    } catch (error) {\n      return handleError(error, 'Error executing tool');\n    }\n  },\n});\n\n// ============================================================================\n// Agent Tool Routes\n// ============================================================================\n\nexport const GET_AGENT_TOOL_ROUTE = createRoute({\n  method: 'GET',\n  path: '/agents/:agentId/tools/:toolId',\n  responseType: 'json',\n  pathParamSchema: agentToolPathParams,\n  responseSchema: serializedToolSchema,\n  summary: 'Get agent tool',\n  description: 'Returns details for a specific tool assigned to the agent',\n  tags: ['Agents', 'Tools'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, toolId, requestContext }) => {\n    try {\n      if (!agentId) {\n        throw new HTTPException(400, { message: 'Agent ID is required' });\n      }\n      const agent = await getAgentFromSystem({ mastra, agentId });\n\n      const agentTools = await agent.listTools({ requestContext });\n\n      const tool = Object.values(agentTools || {}).find((tool: any) => tool.id === toolId) as any;\n\n      if (!tool) {\n        throw new HTTPException(404, { message: 'Tool not found' });\n      }\n\n      return serializeTool(tool);\n    } catch (error) {\n      return handleError(error, 'Error getting agent tool');\n    }\n  },\n});\n\nexport const EXECUTE_AGENT_TOOL_ROUTE = createRoute({\n  method: 'POST',\n  path: '/agents/:agentId/tools/:toolId/execute',\n  responseType: 'json',\n  pathParamSchema: agentToolPathParams,\n  bodySchema: executeToolBodySchema,\n  responseSchema: executeToolResponseSchema,\n  summary: 'Execute agent tool',\n  description: 'Executes a specific tool assigned to the agent with the provided input data',\n  tags: ['Agents', 'Tools'],\n  requiresAuth: true,\n  handler: async ({ mastra, agentId, toolId, data, requestContext }) => {\n    try {\n      if (!agentId) {\n        throw new HTTPException(400, { message: 'Agent ID is required' });\n      }\n      const agent = await getAgentFromSystem({ mastra, agentId });\n\n      const agentTools = await agent.listTools({ requestContext });\n\n      const tool = Object.values(agentTools || {}).find((tool: any) => tool.id === toolId) as any;\n\n      if (!tool) {\n        throw new HTTPException(404, { message: 'Tool not found' });\n      }\n\n      if (!tool?.execute) {\n        throw new HTTPException(400, { message: 'Tool is not executable' });\n      }\n\n      const result = await tool.execute(data, {\n        mastra,\n        requestContext,\n        // TODO: Pass proper tracing context when server API supports tracing\n        tracingContext: { currentSpan: undefined },\n      });\n\n      return result;\n    } catch (error) {\n      return handleError(error, 'Error executing agent tool');\n    }\n  },\n});\n"]}