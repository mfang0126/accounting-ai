{"version":3,"sources":["../src/server/schemas/processors.ts","../src/server/handlers/processors.ts"],"names":["z","isProcessorWorkflow","createRoute","processors","handleError","HTTPException","MessageList"],"mappings":"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","file":"chunk-KPDZYFEE.cjs","sourcesContent":["import z from 'zod';\n\n// Path parameter schemas\nexport const processorIdPathParams = z.object({\n  processorId: z.string().describe('Unique identifier for the processor'),\n});\n\n/**\n * Schema for processor configuration (how it's attached to an agent)\n */\nexport const processorConfigurationSchema = z.object({\n  agentId: z.string(),\n  agentName: z.string(),\n  type: z.enum(['input', 'output']),\n});\n\n/**\n * Schema for processor configuration in list response (simplified)\n */\nconst processorListConfigurationSchema = z.object({\n  agentId: z.string(),\n  type: z.enum(['input', 'output']),\n});\n\n/**\n * Schema for processor in list response\n */\nexport const serializedProcessorSchema = z.object({\n  id: z.string(),\n  name: z.string().optional(),\n  description: z.string().optional(),\n  phases: z.array(z.enum(['input', 'inputStep', 'outputStream', 'outputResult', 'outputStep'])),\n  agentIds: z.array(z.string()),\n  configurations: z.array(processorListConfigurationSchema),\n  isWorkflow: z.boolean(),\n});\n\n/**\n * Schema for detailed processor response\n */\nexport const serializedProcessorDetailSchema = z.object({\n  id: z.string(),\n  name: z.string().optional(),\n  description: z.string().optional(),\n  phases: z.array(z.enum(['input', 'inputStep', 'outputStream', 'outputResult', 'outputStep'])),\n  configurations: z.array(processorConfigurationSchema),\n  isWorkflow: z.boolean(),\n});\n\n/**\n * Schema for list processors endpoint response\n */\nexport const listProcessorsResponseSchema = z.record(z.string(), serializedProcessorSchema);\n\n/**\n * Schema for message content in processor execution\n */\nconst messageContentSchema = z\n  .object({\n    format: z.literal(2).optional(),\n    parts: z.array(z.any()).optional(),\n    content: z.string().optional(),\n  })\n  .passthrough();\n\n/**\n * Schema for a message in processor execution\n */\nconst processorMessageSchema = z\n  .object({\n    id: z.string(),\n    role: z.enum(['user', 'assistant', 'system', 'tool']),\n    createdAt: z.coerce.date().optional(),\n    content: z.union([messageContentSchema, z.string()]),\n  })\n  .passthrough();\n\n/**\n * Body schema for executing a processor\n */\nexport const executeProcessorBodySchema = z.object({\n  phase: z.enum(['input', 'inputStep', 'outputStream', 'outputResult', 'outputStep']),\n  messages: z.array(processorMessageSchema),\n  agentId: z.string().optional(),\n  requestContext: z.record(z.string(), z.any()).optional(),\n});\n\n/**\n * Schema for tripwire result\n */\nconst tripwireSchema = z.object({\n  triggered: z.boolean(),\n  reason: z.string().optional(),\n  metadata: z.any().optional(),\n});\n\n/**\n * Response schema for processor execution\n */\nexport const executeProcessorResponseSchema = z.object({\n  success: z.boolean(),\n  phase: z.string(),\n  messages: z.array(processorMessageSchema).optional(),\n  messageList: z\n    .object({\n      messages: z.array(processorMessageSchema),\n    })\n    .optional(),\n  tripwire: tripwireSchema.optional(),\n  error: z.string().optional(),\n});\n","import { MessageList } from '@mastra/core/agent';\nimport type { MessageInput } from '@mastra/core/agent/message-list';\nimport { isProcessorWorkflow } from '@mastra/core/processors';\nimport type { Processor, ProcessorWorkflow } from '@mastra/core/processors';\n\nimport { HTTPException } from '../http-exception';\nimport {\n  listProcessorsResponseSchema,\n  serializedProcessorDetailSchema,\n  processorIdPathParams,\n  executeProcessorBodySchema,\n  executeProcessorResponseSchema,\n} from '../schemas/processors';\nimport { createRoute } from '../server-adapter/routes/route-builder';\nimport { handleError } from './error';\n\n// ============================================================================\n// Route Definitions\n// ============================================================================\n\ntype ProcessorPhase = 'input' | 'inputStep' | 'outputStream' | 'outputResult' | 'outputStep';\n\n/**\n * Helper to extract text from messages for outputStep testing.\n * In real usage, the `text` field contains the assistant's response text.\n */\nfunction extractTextFromMessages(messages: unknown[]): string {\n  if (!messages || !Array.isArray(messages) || messages.length === 0) {\n    return '';\n  }\n  const firstMessage = messages[0] as any;\n  if (firstMessage?.content?.parts) {\n    const textParts = firstMessage.content.parts\n      .filter((part: any) => part?.type === 'text')\n      .map((part: any) => part?.text || '');\n    return textParts.join('');\n  }\n  return '';\n}\n\n/**\n * Helper to detect phases for a processor.\n * For individual processors, checks which methods are implemented.\n * For workflow processors, returns all phases since createStep handles each phase\n * and it's a no-op if the underlying processor doesn't implement it.\n */\nfunction detectProcessorPhases(processor: any): ProcessorPhase[] {\n  // Check if it's a workflow processor\n  if (isProcessorWorkflow(processor)) {\n    // Workflow processors can potentially handle all phases\n    // The createStep in workflows handles each phase and it's a no-op if not implemented\n    return ['input', 'inputStep', 'outputStream', 'outputResult', 'outputStep'];\n  }\n\n  // For individual processors, detect by checking which methods exist\n  const phases: ProcessorPhase[] = [];\n  if (typeof processor.processInput === 'function') {\n    phases.push('input');\n  }\n  if (typeof processor.processInputStep === 'function') {\n    phases.push('inputStep');\n  }\n  if (typeof processor.processOutputStream === 'function') {\n    phases.push('outputStream');\n  }\n  if (typeof processor.processOutputResult === 'function') {\n    phases.push('outputResult');\n  }\n  if (typeof processor.processOutputStep === 'function') {\n    phases.push('outputStep');\n  }\n  return phases;\n}\n\nexport const LIST_PROCESSORS_ROUTE = createRoute({\n  method: 'GET',\n  path: '/processors',\n  responseType: 'json',\n  responseSchema: listProcessorsResponseSchema,\n  summary: 'List all processors',\n  description: 'Returns a list of all available individual processors',\n  tags: ['Processors'],\n  requiresAuth: true,\n  handler: async ({ mastra }) => {\n    try {\n      const processors = mastra.listProcessors() || {};\n      const processorConfigurations = mastra.listProcessorConfigurations();\n      const result: Record<\n        string,\n        {\n          id: string;\n          name?: string;\n          description?: string;\n          phases: ProcessorPhase[];\n          agentIds: string[];\n          configurations: Array<{ agentId: string; type: 'input' | 'output' }>;\n          isWorkflow: boolean;\n        }\n      > = {};\n\n      // Iterate through all individual processors registered with Mastra\n      for (const [processorKey, processorEntry] of Object.entries(processors)) {\n        const processor = processorEntry as Processor | ProcessorWorkflow;\n        const processorId = processor.id || processorKey;\n\n        // Check if it's a workflow processor\n        const isWorkflow = isProcessorWorkflow(processor);\n\n        // Detect phases (handles both individual processors and workflow processors)\n        const phases = detectProcessorPhases(processor);\n\n        // Get agent configurations for this processor\n        const configs = processorConfigurations.get(processorId) || [];\n        const agentIds = [...new Set(configs.map(c => c.agentId))];\n        const configurations = configs.map(c => ({ agentId: c.agentId, type: c.type }));\n\n        result[processorId] = {\n          id: processorId,\n          name: processor.name || processorId,\n          description: processor.description,\n          phases,\n          agentIds,\n          configurations,\n          isWorkflow,\n        };\n      }\n\n      return result;\n    } catch (error) {\n      return handleError(error, 'Error getting processors');\n    }\n  },\n});\n\nexport const GET_PROCESSOR_BY_ID_ROUTE = createRoute({\n  method: 'GET',\n  path: '/processors/:processorId',\n  responseType: 'json',\n  pathParamSchema: processorIdPathParams,\n  responseSchema: serializedProcessorDetailSchema,\n  summary: 'Get processor by ID',\n  description: 'Returns details for a specific processor including its phases and configurations',\n  tags: ['Processors'],\n  requiresAuth: true,\n  handler: async ({ mastra, processorId }) => {\n    try {\n      // Get the processor from Mastra's registered processors\n      let processorEntry: Processor | ProcessorWorkflow | undefined;\n      try {\n        processorEntry = mastra.getProcessorById(processorId) as Processor | ProcessorWorkflow;\n      } catch {\n        // getProcessorById throws if not found, try by key\n        const processors = mastra.listProcessors() || {};\n        processorEntry = processors[processorId as keyof typeof processors] as Processor | ProcessorWorkflow;\n      }\n\n      if (!processorEntry) {\n        throw new HTTPException(404, { message: 'Processor not found' });\n      }\n\n      // Check if it's a workflow processor\n      const isWorkflow = isProcessorWorkflow(processorEntry);\n\n      // Detect phases (handles both individual processors and workflow processors)\n      const phases = detectProcessorPhases(processorEntry);\n\n      // Get agent configurations for this processor\n      const configs = mastra.getProcessorConfigurations(processorId);\n      const agents = mastra.listAgents() || {};\n      const configurations = configs.map(c => ({\n        agentId: c.agentId,\n        agentName: agents[c.agentId]?.name || c.agentId,\n        type: c.type,\n      }));\n\n      return {\n        id: processorEntry.id,\n        name: processorEntry.name || processorEntry.id,\n        description: processorEntry.description,\n        phases,\n        configurations,\n        isWorkflow,\n      };\n    } catch (error) {\n      return handleError(error, 'Error getting processor');\n    }\n  },\n});\n\nexport const EXECUTE_PROCESSOR_ROUTE = createRoute({\n  method: 'POST',\n  path: '/processors/:processorId/execute',\n  responseType: 'json',\n  pathParamSchema: processorIdPathParams,\n  bodySchema: executeProcessorBodySchema,\n  responseSchema: executeProcessorResponseSchema,\n  summary: 'Execute processor',\n  description: 'Executes a specific processor with the provided input data',\n  tags: ['Processors'],\n  requiresAuth: true,\n  handler: async ({ mastra, processorId, ...bodyParams }) => {\n    try {\n      const { phase, messages } = bodyParams;\n\n      if (!processorId) {\n        throw new HTTPException(400, { message: 'Processor ID is required' });\n      }\n\n      if (!phase) {\n        throw new HTTPException(400, { message: 'Phase is required' });\n      }\n\n      if (!messages || !Array.isArray(messages)) {\n        throw new HTTPException(400, { message: 'Messages array is required' });\n      }\n\n      // Get the processor from Mastra's registered processors\n      let processor;\n      try {\n        processor = mastra.getProcessorById(processorId);\n      } catch {\n        // getProcessorById throws if not found, try by key\n        const processors = mastra.listProcessors() || {};\n        processor = processors[processorId as keyof typeof processors];\n      }\n\n      if (!processor) {\n        throw new HTTPException(404, { message: 'Processor not found' });\n      }\n\n      const messageList = new MessageList();\n      messageList.add(messages as unknown as MessageInput[], 'input');\n\n      // Check if this is a workflow processor\n      if (isProcessorWorkflow(processor)) {\n        // Execute workflow processor\n        try {\n          // Build inputData based on phase - each phase has different required fields\n          const baseInputData = {\n            phase: phase as 'input' | 'inputStep' | 'outputStream' | 'outputResult' | 'outputStep',\n            messages: messageList.get.all.db(),\n            messageList,\n            retryCount: 0,\n          };\n          let inputData: typeof baseInputData & Record<string, unknown> = baseInputData;\n\n          // Add phase-specific fields\n          switch (phase) {\n            case 'input':\n              inputData = {\n                ...inputData,\n                systemMessages: [],\n              };\n              break;\n            case 'inputStep':\n              inputData = {\n                ...inputData,\n                stepNumber: 0,\n                systemMessages: [],\n                steps: [],\n                model: '',\n                tools: {},\n                toolChoice: undefined,\n                activeTools: [],\n                providerOptions: undefined,\n                modelSettings: undefined,\n                structuredOutput: undefined,\n              };\n              break;\n            case 'outputResult':\n              // outputResult only needs base fields\n              break;\n            case 'outputStep':\n              inputData = {\n                ...inputData,\n                stepNumber: 0,\n                systemMessages: [],\n                steps: [],\n                finishReason: 'stop',\n                toolCalls: [],\n                text: extractTextFromMessages(messages),\n              };\n              break;\n            case 'outputStream':\n              inputData = {\n                ...inputData,\n                part: null,\n                streamParts: [],\n                state: {},\n              };\n              break;\n          }\n\n          const run = await processor.createRun();\n          const result = await run.start({\n            inputData,\n          });\n\n          // Check for tripwire status\n          if (result.status === 'tripwire') {\n            return {\n              success: false,\n              phase,\n              tripwire: {\n                triggered: true,\n                reason: result.tripwire.reason || `Tripwire triggered in workflow ${processor.id}`,\n                metadata: result.tripwire.metadata,\n              },\n              messages,\n              messageList: {\n                messages,\n              },\n            };\n          }\n\n          // Check for execution failure\n          if (result.status !== 'success') {\n            throw new HTTPException(500, {\n              message: `Processor workflow ${processor.id} failed with status: ${result.status}`,\n            });\n          }\n\n          // Extract output from workflow result\n          const output = result.result;\n          let outputMessages = messages;\n\n          if (output && typeof output === 'object') {\n            if ('messages' in output && Array.isArray(output.messages)) {\n              outputMessages = output.messages;\n            } else if ('messageList' in output && output.messageList instanceof MessageList) {\n              outputMessages = output.messageList.get.all.db();\n            }\n          }\n\n          return {\n            success: true,\n            phase,\n            messages: outputMessages,\n            messageList: {\n              messages: outputMessages,\n            },\n          };\n        } catch (error: any) {\n          // Re-throw HTTP exceptions\n          if (error instanceof HTTPException) {\n            throw error;\n          }\n          throw new HTTPException(500, {\n            message: `Error executing processor workflow: ${error.message}`,\n          });\n        }\n      }\n\n      // Handle individual processor execution\n      // Create the abort function for tripwire support\n      let tripwireTriggered = false;\n      let tripwireReason: string | undefined;\n      let tripwireMetadata: unknown;\n\n      const abort = (reason?: string, options?: { retry?: boolean; metadata?: unknown }) => {\n        tripwireTriggered = true;\n        tripwireReason = reason;\n        tripwireMetadata = options?.metadata;\n        throw new Error(`TRIPWIRE:${reason || 'Processor aborted'}`);\n      };\n\n      // Build the context based on phase\n      const baseContext = {\n        abort,\n        retryCount: 0,\n        messages: messageList.get.all.db(),\n        messageList,\n        state: {},\n      };\n\n      try {\n        let result: any;\n\n        // Execute the specific phase method on the individual processor\n        switch (phase) {\n          case 'input':\n            if (!processor.processInput) {\n              throw new HTTPException(400, { message: 'Processor does not support input phase' });\n            }\n            result = await processor.processInput({\n              ...baseContext,\n              systemMessages: [],\n            });\n            break;\n\n          case 'inputStep':\n            if (!processor.processInputStep) {\n              throw new HTTPException(400, { message: 'Processor does not support inputStep phase' });\n            }\n            result = await processor.processInputStep({\n              ...baseContext,\n              systemMessages: [],\n              stepNumber: 0,\n              steps: [],\n              // Pass empty/default values for all inputStep fields\n              model: '' as any,\n              tools: {},\n              toolChoice: undefined,\n              activeTools: [],\n              providerOptions: undefined,\n              modelSettings: undefined,\n              structuredOutput: undefined,\n            });\n            break;\n\n          case 'outputResult':\n            if (!processor.processOutputResult) {\n              throw new HTTPException(400, { message: 'Processor does not support outputResult phase' });\n            }\n            result = await processor.processOutputResult(baseContext);\n            break;\n\n          case 'outputStep':\n            if (!processor.processOutputStep) {\n              throw new HTTPException(400, { message: 'Processor does not support outputStep phase' });\n            }\n            result = await processor.processOutputStep({\n              ...baseContext,\n              systemMessages: [],\n              stepNumber: 0,\n              steps: [],\n              finishReason: 'stop',\n              toolCalls: [],\n              text: extractTextFromMessages(messages),\n            });\n            break;\n\n          case 'outputStream':\n            // outputStream is for streaming chunks, not a simple execute\n            throw new HTTPException(400, {\n              message: 'outputStream phase cannot be executed directly. Use streaming instead.',\n            });\n\n          default:\n            throw new HTTPException(400, { message: `Unknown phase: ${phase}` });\n        }\n\n        // Process the result\n        let outputMessages = messages;\n        if (result) {\n          if (Array.isArray(result)) {\n            outputMessages = result;\n          } else if (result.get && result.get.all && typeof result.get.all.db === 'function') {\n            // It's a MessageList\n            outputMessages = result.get.all.db();\n          } else if (result.messages) {\n            outputMessages = result.messages;\n          }\n        }\n\n        return {\n          success: true,\n          phase,\n          messages: outputMessages,\n          messageList: {\n            messages: outputMessages,\n          },\n        };\n      } catch (error: any) {\n        // Check if it's a tripwire\n        if (tripwireTriggered || error.message?.startsWith('TRIPWIRE:')) {\n          return {\n            success: false,\n            phase,\n            tripwire: {\n              triggered: true,\n              reason: tripwireReason || error.message?.replace('TRIPWIRE:', ''),\n              metadata: tripwireMetadata,\n            },\n            messages,\n            messageList: {\n              messages,\n            },\n          };\n        }\n        throw error;\n      }\n    } catch (error) {\n      return handleError(error, 'Error executing processor');\n    }\n  },\n});\n"]}