{"version":3,"sources":["../src/server/schemas/stored-prompt-blocks.ts","../src/server/handlers/stored-prompt-blocks.ts"],"names":[],"mappings":"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","file":"chunk-EFKPTKKF.js","sourcesContent":["import z from 'zod';\n\nimport { paginationInfoSchema, createPagePaginationSchema, statusQuerySchema } from './common';\nimport { ruleGroupSchema } from './rule-group';\n\n// ============================================================================\n// Path Parameter Schemas\n// ============================================================================\n\nexport const storedPromptBlockIdPathParams = z.object({\n  storedPromptBlockId: z.string().describe('Unique identifier for the stored prompt block'),\n});\n\n// ============================================================================\n// Query Parameter Schemas\n// ============================================================================\n\nconst storageOrderBySchema = z.object({\n  field: z.enum(['createdAt', 'updatedAt']).optional(),\n  direction: z.enum(['ASC', 'DESC']).optional(),\n});\n\nexport { statusQuerySchema };\n\nexport const listStoredPromptBlocksQuerySchema = createPagePaginationSchema(100).extend({\n  orderBy: storageOrderBySchema.optional(),\n  status: z\n    .enum(['draft', 'published', 'archived'])\n    .optional()\n    .describe('Filter prompt blocks by status. When omitted, returns all prompt blocks regardless of status'),\n  authorId: z.string().optional().describe('Filter prompt blocks by author identifier'),\n  metadata: z.record(z.string(), z.unknown()).optional().describe('Filter prompt blocks by metadata key-value pairs'),\n});\n\n// ============================================================================\n// Body Parameter Schemas\n// ============================================================================\n\nconst snapshotConfigSchema = z.object({\n  name: z.string().describe('Display name of the prompt block'),\n  description: z.string().optional().describe('Purpose description'),\n  content: z.string().describe('Template content with {{variable}} interpolation'),\n  rules: ruleGroupSchema.optional().describe('Rules for conditional inclusion'),\n  requestContextSchema: z\n    .record(z.string(), z.unknown())\n    .optional()\n    .describe('JSON Schema defining available variables for {{variableName}} interpolation and conditions'),\n});\n\nexport const createStoredPromptBlockBodySchema = z\n  .object({\n    id: z.string().optional().describe('Unique identifier. If not provided, derived from name.'),\n    authorId: z.string().optional().describe('Author identifier for multi-tenant filtering'),\n    metadata: z.record(z.string(), z.unknown()).optional().describe('Additional metadata for the prompt block'),\n  })\n  .merge(snapshotConfigSchema);\n\nexport const updateStoredPromptBlockBodySchema = z\n  .object({\n    authorId: z.string().optional(),\n    metadata: z.record(z.string(), z.unknown()).optional(),\n  })\n  .merge(snapshotConfigSchema.partial());\n\n// ============================================================================\n// Response Schemas\n// ============================================================================\n\nexport const storedPromptBlockSchema = z.object({\n  id: z.string(),\n  status: z.string().describe('Prompt block status: draft, published, or archived'),\n  activeVersionId: z.string().optional(),\n  hasDraft: z.boolean().optional().describe('Whether the prompt block has unpublished draft changes'),\n  authorId: z.string().optional(),\n  metadata: z.record(z.string(), z.unknown()).optional(),\n  createdAt: z.coerce.date(),\n  updatedAt: z.coerce.date(),\n  name: z.string().describe('Display name of the prompt block'),\n  description: z.string().optional().describe('Purpose description'),\n  content: z.string().describe('Template content with {{variable}} interpolation'),\n  rules: ruleGroupSchema.optional().describe('Rules for conditional inclusion'),\n  requestContextSchema: z\n    .record(z.string(), z.unknown())\n    .optional()\n    .describe('JSON Schema defining available variables for {{variableName}} interpolation and conditions'),\n});\n\nexport const listStoredPromptBlocksResponseSchema = paginationInfoSchema.extend({\n  promptBlocks: z.array(storedPromptBlockSchema),\n});\n\nexport const getStoredPromptBlockResponseSchema = storedPromptBlockSchema;\nexport const createStoredPromptBlockResponseSchema = storedPromptBlockSchema;\n\nexport const updateStoredPromptBlockResponseSchema = z.union([\n  z.object({\n    id: z.string(),\n    status: z.string(),\n    activeVersionId: z.string().optional(),\n    authorId: z.string().optional(),\n    metadata: z.record(z.string(), z.unknown()).optional(),\n    createdAt: z.coerce.date(),\n    updatedAt: z.coerce.date(),\n  }),\n  storedPromptBlockSchema,\n]);\n\nexport const deleteStoredPromptBlockResponseSchema = z.object({\n  success: z.boolean(),\n  message: z.string(),\n});\n","import { HTTPException } from '../http-exception';\nimport {\n  storedPromptBlockIdPathParams,\n  statusQuerySchema,\n  listStoredPromptBlocksQuerySchema,\n  createStoredPromptBlockBodySchema,\n  updateStoredPromptBlockBodySchema,\n  listStoredPromptBlocksResponseSchema,\n  getStoredPromptBlockResponseSchema,\n  createStoredPromptBlockResponseSchema,\n  updateStoredPromptBlockResponseSchema,\n  deleteStoredPromptBlockResponseSchema,\n} from '../schemas/stored-prompt-blocks';\nimport { createRoute } from '../server-adapter/routes/route-builder';\nimport { toSlug } from '../utils';\n\nimport { handleError } from './error';\nimport { handleAutoVersioning } from './version-helpers';\nimport type { VersionedStoreInterface } from './version-helpers';\n\nconst PROMPT_BLOCK_SNAPSHOT_CONFIG_FIELDS = [\n  'name',\n  'description',\n  'content',\n  'rules',\n  'requestContextSchema',\n] as const;\n\n/** Computes whether a prompt block has an unpublished draft version. */\nfunction computeHasDraft(\n  latestVersion: { id: string } | null | undefined,\n  activeVersionId: string | null | undefined,\n): boolean {\n  return !!(latestVersion && (!activeVersionId || latestVersion.id !== activeVersionId));\n}\n\n// ============================================================================\n// Route Definitions\n// ============================================================================\n\n/**\n * GET /stored/prompt-blocks - List all stored prompt blocks\n */\nexport const LIST_STORED_PROMPT_BLOCKS_ROUTE = createRoute({\n  method: 'GET',\n  path: '/stored/prompt-blocks',\n  responseType: 'json',\n  queryParamSchema: listStoredPromptBlocksQuerySchema,\n  responseSchema: listStoredPromptBlocksResponseSchema,\n  summary: 'List stored prompt blocks',\n  description: 'Returns a paginated list of all prompt blocks stored in the database',\n  tags: ['Stored Prompt Blocks'],\n  requiresAuth: true,\n  handler: async ({ mastra, page, perPage, orderBy, status, authorId, metadata }) => {\n    try {\n      const storage = mastra.getStorage();\n\n      if (!storage) {\n        throw new HTTPException(500, { message: 'Storage is not configured' });\n      }\n\n      const promptBlockStore = await storage.getStore('promptBlocks');\n      if (!promptBlockStore) {\n        throw new HTTPException(500, { message: 'Prompt blocks storage domain is not available' });\n      }\n\n      const result = await promptBlockStore.listResolved({\n        page,\n        perPage,\n        orderBy,\n        status,\n        authorId,\n        metadata,\n      });\n\n      // For each block, fetch the latest version to compute hasDraft.\n      // resolvedVersionId from listResolved defaults to 'published' resolution,\n      // so we need the actual latest version to detect unpublished drafts.\n      const promptBlocks = await Promise.all(\n        result.promptBlocks.map(async (block: (typeof result.promptBlocks)[number]) => {\n          const latestVersion = await promptBlockStore.getLatestVersion(block.id);\n          return { ...block, hasDraft: computeHasDraft(latestVersion, block.activeVersionId) };\n        }),\n      );\n\n      return { ...result, promptBlocks };\n    } catch (error) {\n      return handleError(error, 'Error listing stored prompt blocks');\n    }\n  },\n});\n\n/**\n * GET /stored/prompt-blocks/:storedPromptBlockId - Get a stored prompt block by ID\n */\nexport const GET_STORED_PROMPT_BLOCK_ROUTE = createRoute({\n  method: 'GET',\n  path: '/stored/prompt-blocks/:storedPromptBlockId',\n  responseType: 'json',\n  pathParamSchema: storedPromptBlockIdPathParams,\n  queryParamSchema: statusQuerySchema,\n  responseSchema: getStoredPromptBlockResponseSchema,\n  summary: 'Get stored prompt block by ID',\n  description:\n    'Returns a specific prompt block from storage by its unique identifier. Use ?status=draft to resolve with the latest (draft) version, or ?status=published (default) for the active published version.',\n  tags: ['Stored Prompt Blocks'],\n  requiresAuth: true,\n  handler: async ({ mastra, storedPromptBlockId, status }) => {\n    try {\n      const storage = mastra.getStorage();\n\n      if (!storage) {\n        throw new HTTPException(500, { message: 'Storage is not configured' });\n      }\n\n      const promptBlockStore = await storage.getStore('promptBlocks');\n      if (!promptBlockStore) {\n        throw new HTTPException(500, { message: 'Prompt blocks storage domain is not available' });\n      }\n\n      const promptBlock = await promptBlockStore.getByIdResolved(storedPromptBlockId, { status });\n\n      if (!promptBlock) {\n        throw new HTTPException(404, { message: `Stored prompt block with id ${storedPromptBlockId} not found` });\n      }\n\n      const latestVersion = await promptBlockStore.getLatestVersion(storedPromptBlockId);\n\n      return { ...promptBlock, hasDraft: computeHasDraft(latestVersion, promptBlock.activeVersionId) };\n    } catch (error) {\n      return handleError(error, 'Error getting stored prompt block');\n    }\n  },\n});\n\n/**\n * POST /stored/prompt-blocks - Create a new stored prompt block\n */\nexport const CREATE_STORED_PROMPT_BLOCK_ROUTE = createRoute({\n  method: 'POST',\n  path: '/stored/prompt-blocks',\n  responseType: 'json',\n  bodySchema: createStoredPromptBlockBodySchema,\n  responseSchema: createStoredPromptBlockResponseSchema,\n  summary: 'Create stored prompt block',\n  description: 'Creates a new prompt block in storage with the provided configuration',\n  tags: ['Stored Prompt Blocks'],\n  requiresAuth: true,\n  handler: async ({\n    mastra,\n    id: providedId,\n    authorId,\n    metadata,\n    name,\n    description,\n    content,\n    rules,\n    requestContextSchema,\n  }) => {\n    try {\n      const storage = mastra.getStorage();\n\n      if (!storage) {\n        throw new HTTPException(500, { message: 'Storage is not configured' });\n      }\n\n      const promptBlockStore = await storage.getStore('promptBlocks');\n      if (!promptBlockStore) {\n        throw new HTTPException(500, { message: 'Prompt blocks storage domain is not available' });\n      }\n\n      // Derive ID from name if not explicitly provided\n      const id = providedId || toSlug(name);\n\n      if (!id) {\n        throw new HTTPException(400, {\n          message: 'Could not derive prompt block ID from name. Please provide an explicit id.',\n        });\n      }\n\n      // Check if prompt block with this ID already exists\n      const existing = await promptBlockStore.getById(id);\n      if (existing) {\n        throw new HTTPException(409, { message: `Prompt block with id ${id} already exists` });\n      }\n\n      await promptBlockStore.create({\n        promptBlock: {\n          id,\n          authorId,\n          metadata,\n          name,\n          description,\n          content,\n          rules,\n          requestContextSchema,\n        },\n      });\n\n      // Return the resolved prompt block (thin record + version config)\n      // Use draft status since newly created entities start as drafts\n      const resolved = await promptBlockStore.getByIdResolved(id, { status: 'draft' });\n      if (!resolved) {\n        throw new HTTPException(500, { message: 'Failed to resolve created prompt block' });\n      }\n\n      const latestVersion = await promptBlockStore.getLatestVersion(id);\n      const hasDraft = !!(\n        latestVersion &&\n        (!resolved.activeVersionId || latestVersion.id !== resolved.activeVersionId)\n      );\n\n      return { ...resolved, hasDraft };\n    } catch (error) {\n      return handleError(error, 'Error creating stored prompt block');\n    }\n  },\n});\n\n/**\n * PATCH /stored/prompt-blocks/:storedPromptBlockId - Update a stored prompt block\n */\nexport const UPDATE_STORED_PROMPT_BLOCK_ROUTE = createRoute({\n  method: 'PATCH',\n  path: '/stored/prompt-blocks/:storedPromptBlockId',\n  responseType: 'json',\n  pathParamSchema: storedPromptBlockIdPathParams,\n  bodySchema: updateStoredPromptBlockBodySchema,\n  responseSchema: updateStoredPromptBlockResponseSchema,\n  summary: 'Update stored prompt block',\n  description: 'Updates an existing prompt block in storage with the provided fields',\n  tags: ['Stored Prompt Blocks'],\n  requiresAuth: true,\n  handler: async ({\n    mastra,\n    storedPromptBlockId,\n    // Metadata-level fields\n    authorId,\n    metadata,\n    // Config fields (snapshot-level)\n    name,\n    description,\n    content,\n    rules,\n    requestContextSchema,\n  }) => {\n    try {\n      const storage = mastra.getStorage();\n\n      if (!storage) {\n        throw new HTTPException(500, { message: 'Storage is not configured' });\n      }\n\n      const promptBlockStore = await storage.getStore('promptBlocks');\n      if (!promptBlockStore) {\n        throw new HTTPException(500, { message: 'Prompt blocks storage domain is not available' });\n      }\n\n      // Check if prompt block exists\n      const existing = await promptBlockStore.getById(storedPromptBlockId);\n      if (!existing) {\n        throw new HTTPException(404, { message: `Stored prompt block with id ${storedPromptBlockId} not found` });\n      }\n\n      // Update the prompt block with both metadata-level and config-level fields\n      const updatedPromptBlock = await promptBlockStore.update({\n        id: storedPromptBlockId,\n        authorId,\n        metadata,\n        name,\n        description,\n        content,\n        rules,\n        requestContextSchema,\n      });\n\n      // Build the snapshot config for auto-versioning comparison\n      const configFields = { name, description, content, rules, requestContextSchema };\n\n      // Filter out undefined values to get only the config fields that were provided\n      const providedConfigFields = Object.fromEntries(Object.entries(configFields).filter(([_, v]) => v !== undefined));\n\n      // Handle auto-versioning with retry logic for race conditions\n      // This creates a new version if there are meaningful config changes.\n      // It does NOT update activeVersionId â€” the version stays as a draft until explicitly published.\n      await handleAutoVersioning(\n        promptBlockStore as unknown as VersionedStoreInterface,\n        storedPromptBlockId,\n        'blockId',\n        PROMPT_BLOCK_SNAPSHOT_CONFIG_FIELDS,\n        existing,\n        updatedPromptBlock,\n        providedConfigFields,\n      );\n\n      // Return the resolved prompt block with the latest (draft) version so the UI sees its edits\n      const resolved = await promptBlockStore.getByIdResolved(storedPromptBlockId, { status: 'draft' });\n      if (!resolved) {\n        throw new HTTPException(500, { message: 'Failed to resolve updated prompt block' });\n      }\n\n      const latestVersion = await promptBlockStore.getLatestVersion(storedPromptBlockId);\n      const hasDraft = !!(\n        latestVersion &&\n        (!resolved.activeVersionId || latestVersion.id !== resolved.activeVersionId)\n      );\n\n      return { ...resolved, hasDraft };\n    } catch (error) {\n      return handleError(error, 'Error updating stored prompt block');\n    }\n  },\n});\n\n/**\n * DELETE /stored/prompt-blocks/:storedPromptBlockId - Delete a stored prompt block\n */\nexport const DELETE_STORED_PROMPT_BLOCK_ROUTE = createRoute({\n  method: 'DELETE',\n  path: '/stored/prompt-blocks/:storedPromptBlockId',\n  responseType: 'json',\n  pathParamSchema: storedPromptBlockIdPathParams,\n  responseSchema: deleteStoredPromptBlockResponseSchema,\n  summary: 'Delete stored prompt block',\n  description: 'Deletes a prompt block from storage by its unique identifier',\n  tags: ['Stored Prompt Blocks'],\n  requiresAuth: true,\n  handler: async ({ mastra, storedPromptBlockId }) => {\n    try {\n      const storage = mastra.getStorage();\n\n      if (!storage) {\n        throw new HTTPException(500, { message: 'Storage is not configured' });\n      }\n\n      const promptBlockStore = await storage.getStore('promptBlocks');\n      if (!promptBlockStore) {\n        throw new HTTPException(500, { message: 'Prompt blocks storage domain is not available' });\n      }\n\n      // Check if prompt block exists\n      const existing = await promptBlockStore.getById(storedPromptBlockId);\n      if (!existing) {\n        throw new HTTPException(404, { message: `Stored prompt block with id ${storedPromptBlockId} not found` });\n      }\n\n      await promptBlockStore.delete(storedPromptBlockId);\n\n      return {\n        success: true,\n        message: `Prompt block ${storedPromptBlockId} deleted successfully`,\n      };\n    } catch (error) {\n      return handleError(error, 'Error deleting stored prompt block');\n    }\n  },\n});\n"]}