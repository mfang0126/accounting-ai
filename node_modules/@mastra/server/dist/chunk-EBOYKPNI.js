import { snapshotConfigSchema } from './chunk-BZMWUSOF.js';
import { ruleGroupSchema } from './chunk-IQHNSFTT.js';
import { defaultOptionsSchema } from './chunk-7XBOJMBD.js';
import { createPagePaginationSchema, paginationInfoSchema } from './chunk-5CRPJSGU.js';
import z2 from 'zod';

var semanticRecallSchema = z2.object({
  topK: z2.number().describe("Number of semantically similar messages to retrieve"),
  messageRange: z2.union([
    z2.number(),
    z2.object({
      before: z2.number(),
      after: z2.number()
    })
  ]).describe("Amount of surrounding context to include with each retrieved message"),
  scope: z2.enum(["thread", "resource"]).optional().describe("Scope for semantic search queries"),
  threshold: z2.number().min(0).max(1).optional().describe("Minimum similarity score threshold"),
  indexName: z2.string().optional().describe("Index name for the vector store")
});
var titleGenerationSchema = z2.union([
  z2.boolean(),
  z2.object({
    model: z2.string().describe("Model ID in format provider/model-name (ModelRouterModelId)"),
    instructions: z2.string().optional().describe("Custom instructions for title generation")
  })
]);
var serializedObservationConfigSchema = z2.object({
  model: z2.string().optional().describe("Observer model ID"),
  messageTokens: z2.number().optional().describe("Token threshold that triggers observation"),
  modelSettings: z2.record(z2.string(), z2.unknown()).optional().describe("Model settings (temperature, etc.)"),
  providerOptions: z2.record(z2.string(), z2.record(z2.string(), z2.unknown()).optional()).optional().describe("Provider-specific options"),
  maxTokensPerBatch: z2.number().optional().describe("Maximum tokens per batch"),
  bufferTokens: z2.union([z2.number(), z2.literal(false)]).optional().describe("Async buffering interval or false"),
  bufferActivation: z2.number().optional().describe("Ratio of buffered observations to activate"),
  blockAfter: z2.number().optional().describe("Token threshold for synchronous blocking")
});
var serializedReflectionConfigSchema = z2.object({
  model: z2.string().optional().describe("Reflector model ID"),
  observationTokens: z2.number().optional().describe("Token threshold that triggers reflection"),
  modelSettings: z2.record(z2.string(), z2.unknown()).optional().describe("Model settings (temperature, etc.)"),
  providerOptions: z2.record(z2.string(), z2.record(z2.string(), z2.unknown()).optional()).optional().describe("Provider-specific options"),
  blockAfter: z2.number().optional().describe("Token threshold for synchronous blocking"),
  bufferActivation: z2.number().optional().describe("Ratio for async reflection buffering")
});
var serializedObservationalMemoryConfigObjectSchema = z2.object({
  model: z2.string().optional().describe("Model ID for both Observer and Reflector"),
  scope: z2.enum(["resource", "thread"]).optional().describe("Memory scope"),
  shareTokenBudget: z2.boolean().optional().describe("Share token budget between messages and observations"),
  observation: serializedObservationConfigSchema.optional().describe("Observation step configuration"),
  reflection: serializedReflectionConfigSchema.optional().describe("Reflection step configuration")
});
var serializedObservationalMemoryConfigSchema = z2.union([
  z2.boolean(),
  serializedObservationalMemoryConfigObjectSchema
]);
var serializedMemoryConfigSchema = z2.object({
  vector: z2.union([z2.string(), z2.literal(false)]).optional().describe("Vector database identifier or false to disable"),
  options: z2.object({
    readOnly: z2.boolean().optional(),
    lastMessages: z2.union([z2.number(), z2.literal(false)]).optional(),
    semanticRecall: z2.union([z2.boolean(), semanticRecallSchema]).optional(),
    generateTitle: titleGenerationSchema.optional()
  }).optional().describe("Memory behavior configuration, excluding workingMemory and threads"),
  embedder: z2.string().optional().describe('Embedding model ID in the format "provider/model" (e.g., "openai/text-embedding-3-small")'),
  embedderOptions: z2.record(z2.string(), z2.unknown()).optional().describe("Options to pass to the embedder, omitting telemetry"),
  observationalMemory: serializedObservationalMemoryConfigSchema.optional().describe("Serialized observational memory configuration")
}).refine(
  (data) => {
    const semanticRecall = data.options?.semanticRecall;
    const semanticRecallEnabled = semanticRecall === true || typeof semanticRecall === "object" && semanticRecall !== null;
    if (semanticRecallEnabled) {
      const hasVector = typeof data.vector === "string" && data.vector.length > 0;
      const hasEmbedder = typeof data.embedder === "string" && data.embedder.length > 0;
      return hasVector && hasEmbedder;
    }
    return true;
  },
  {
    message: "Semantic recall requires both vector and embedder to be configured",
    path: ["options", "semanticRecall"]
  }
);

// src/server/schemas/stored-agents.ts
var storedAgentIdPathParams = z2.object({
  storedAgentId: z2.string().describe("Unique identifier for the stored agent")
});
var storageOrderBySchema = z2.object({
  field: z2.enum(["createdAt", "updatedAt"]).optional(),
  direction: z2.enum(["ASC", "DESC"]).optional()
});
var listStoredAgentsQuerySchema = createPagePaginationSchema(100).extend({
  orderBy: storageOrderBySchema.optional(),
  status: z2.enum(["draft", "published", "archived"]).optional().default("published").describe("Filter agents by status (defaults to published)"),
  authorId: z2.string().optional().describe("Filter agents by author identifier"),
  metadata: z2.record(z2.string(), z2.unknown()).optional().describe("Filter agents by metadata key-value pairs")
});
var scorerConfigSchema = z2.object({
  description: z2.string().optional(),
  sampling: z2.union([
    z2.object({ type: z2.literal("none") }),
    z2.object({ type: z2.literal("ratio"), rate: z2.number().min(0).max(1) })
  ]).optional(),
  rules: ruleGroupSchema.optional()
});
var agentInstructionBlockSchema = z2.discriminatedUnion("type", [
  z2.object({ type: z2.literal("text"), content: z2.string() }),
  z2.object({ type: z2.literal("prompt_block_ref"), id: z2.string() }),
  z2.object({ type: z2.literal("prompt_block"), content: z2.string(), rules: ruleGroupSchema.optional() })
]);
function conditionalFieldSchema(valueSchema) {
  const variantSchema = z2.object({
    value: valueSchema,
    rules: ruleGroupSchema.optional()
  });
  return z2.union([valueSchema, z2.array(variantSchema)]);
}
var instructionsSchema = z2.union([z2.string(), z2.array(agentInstructionBlockSchema)]).describe("System instructions for the agent (string or array of instruction blocks)");
var modelConfigSchema = z2.object({
  provider: z2.string().describe("Model provider (e.g., openai, anthropic)"),
  name: z2.string().describe("Model name (e.g., gpt-4o, claude-3-opus)")
}).passthrough();
var toolConfigSchema = z2.object({ description: z2.string().optional(), rules: ruleGroupSchema.optional() });
var toolsConfigSchema = z2.record(z2.string(), toolConfigSchema);
var mcpClientToolsConfigSchema = z2.object({
  tools: z2.record(z2.string(), toolConfigSchema).optional()
});
var skillConfigSchema = z2.object({
  description: z2.string().optional(),
  instructions: z2.string().optional(),
  pin: z2.string().optional(),
  strategy: z2.enum(["latest", "live"]).optional()
});
var skillsConfigSchema = z2.record(z2.string(), skillConfigSchema);
var workspaceRefSchema = z2.discriminatedUnion("type", [
  z2.object({ type: z2.literal("id"), workspaceId: z2.string() }),
  z2.object({ type: z2.literal("inline"), config: snapshotConfigSchema })
]);
var processorPhaseSchema = z2.enum([
  "processInput",
  "processInputStep",
  "processOutputStream",
  "processOutputResult",
  "processOutputStep"
]);
var processorGraphStepSchema = z2.object({
  id: z2.string().describe("Unique ID for this step within the graph"),
  providerId: z2.string().describe("ProcessorProvider ID that creates this processor"),
  config: z2.record(z2.string(), z2.unknown()).describe("Configuration matching the provider configSchema"),
  enabledPhases: z2.array(processorPhaseSchema).min(1).describe("Which processor phases to enable")
});
var processorGraphEntryDepth3 = z2.discriminatedUnion("type", [
  z2.object({ type: z2.literal("step"), step: processorGraphStepSchema })
]);
var processorGraphEntryDepth2 = z2.discriminatedUnion("type", [
  z2.object({ type: z2.literal("step"), step: processorGraphStepSchema }),
  z2.object({ type: z2.literal("parallel"), branches: z2.array(z2.array(processorGraphEntryDepth3)) }),
  z2.object({
    type: z2.literal("conditional"),
    conditions: z2.array(
      z2.object({
        steps: z2.array(processorGraphEntryDepth3),
        rules: ruleGroupSchema.optional()
      })
    )
  })
]);
var processorGraphEntrySchema = z2.discriminatedUnion("type", [
  z2.object({ type: z2.literal("step"), step: processorGraphStepSchema }),
  z2.object({ type: z2.literal("parallel"), branches: z2.array(z2.array(processorGraphEntryDepth2)) }),
  z2.object({
    type: z2.literal("conditional"),
    conditions: z2.array(
      z2.object({
        steps: z2.array(processorGraphEntryDepth2),
        rules: ruleGroupSchema.optional()
      })
    )
  })
]);
var storedProcessorGraphSchema = z2.object({
  steps: z2.array(processorGraphEntrySchema).describe("Ordered list of processor graph entries")
});
var snapshotConfigSchema2 = z2.object({
  name: z2.string().describe("Name of the agent"),
  description: z2.string().optional().describe("Description of the agent"),
  instructions: instructionsSchema,
  model: conditionalFieldSchema(modelConfigSchema).describe(
    "Model configuration \u2014 static value or array of conditional variants"
  ),
  tools: conditionalFieldSchema(toolsConfigSchema).optional().describe("Tool keys mapped to per-tool config \u2014 static or conditional"),
  defaultOptions: conditionalFieldSchema(defaultOptionsSchema).optional().describe("Default options for generate/stream calls \u2014 static or conditional"),
  workflows: conditionalFieldSchema(z2.record(z2.string(), toolConfigSchema)).optional().describe("Workflow keys with optional per-workflow config \u2014 static or conditional"),
  agents: conditionalFieldSchema(z2.record(z2.string(), toolConfigSchema)).optional().describe("Agent keys with optional per-agent config \u2014 static or conditional"),
  integrationTools: conditionalFieldSchema(z2.record(z2.string(), mcpClientToolsConfigSchema)).optional().describe("Map of tool provider IDs to their tool configurations \u2014 static or conditional"),
  mcpClients: conditionalFieldSchema(z2.record(z2.string(), mcpClientToolsConfigSchema)).optional().describe("Map of stored MCP client IDs to their tool configurations \u2014 static or conditional"),
  inputProcessors: conditionalFieldSchema(storedProcessorGraphSchema).optional().describe("Input processor graph \u2014 static or conditional"),
  outputProcessors: conditionalFieldSchema(storedProcessorGraphSchema).optional().describe("Output processor graph \u2014 static or conditional"),
  memory: conditionalFieldSchema(serializedMemoryConfigSchema).optional().describe("Memory configuration \u2014 static or conditional"),
  scorers: conditionalFieldSchema(z2.record(z2.string(), scorerConfigSchema)).optional().describe("Scorer keys with optional sampling config \u2014 static or conditional"),
  skills: conditionalFieldSchema(skillsConfigSchema).optional().describe("Skill IDs mapped to per-skill config \u2014 static or conditional"),
  workspace: conditionalFieldSchema(workspaceRefSchema).optional().describe("Workspace reference (stored ID or inline config) \u2014 static or conditional"),
  requestContextSchema: z2.record(z2.string(), z2.unknown()).optional().describe("JSON Schema defining valid request context variables for conditional rule evaluation")
});
var agentMetadataSchema = z2.object({
  authorId: z2.string().optional().describe("Author identifier for multi-tenant filtering"),
  metadata: z2.record(z2.string(), z2.unknown()).optional().describe("Additional metadata for the agent")
});
var createStoredAgentBodySchema = z2.object({
  id: z2.string().optional().describe("Unique identifier for the agent. If not provided, derived from name."),
  authorId: z2.string().optional().describe("Author identifier for multi-tenant filtering"),
  metadata: z2.record(z2.string(), z2.unknown()).optional().describe("Additional metadata for the agent")
}).merge(snapshotConfigSchema2);
var snapshotConfigUpdateSchema = snapshotConfigSchema2.extend({
  memory: z2.union([conditionalFieldSchema(serializedMemoryConfigSchema), z2.null()]).optional().describe("Memory configuration \u2014 static, conditional, or null to disable memory")
});
var updateStoredAgentBodySchema = agentMetadataSchema.partial().merge(snapshotConfigUpdateSchema.partial());
var storedAgentSchema = z2.object({
  // Thin agent record fields
  id: z2.string(),
  status: z2.string().describe("Agent status: draft or published"),
  activeVersionId: z2.string().optional(),
  authorId: z2.string().optional(),
  metadata: z2.record(z2.string(), z2.unknown()).optional(),
  createdAt: z2.coerce.date(),
  updatedAt: z2.coerce.date(),
  // Version snapshot config fields (resolved from active version)
  name: z2.string().describe("Name of the agent"),
  description: z2.string().optional().describe("Description of the agent"),
  instructions: instructionsSchema,
  model: conditionalFieldSchema(modelConfigSchema).describe(
    "Model configuration \u2014 static value or array of conditional variants"
  ),
  tools: conditionalFieldSchema(toolsConfigSchema).optional().describe("Tool keys mapped to per-tool config \u2014 static or conditional"),
  defaultOptions: conditionalFieldSchema(defaultOptionsSchema).optional().describe("Default options for generate/stream calls \u2014 static or conditional"),
  workflows: conditionalFieldSchema(z2.record(z2.string(), toolConfigSchema)).optional().describe("Workflow keys with optional per-workflow config \u2014 static or conditional"),
  agents: conditionalFieldSchema(z2.record(z2.string(), toolConfigSchema)).optional().describe("Agent keys with optional per-agent config \u2014 static or conditional"),
  integrationTools: conditionalFieldSchema(z2.record(z2.string(), mcpClientToolsConfigSchema)).optional().describe("Map of tool provider IDs to their tool configurations \u2014 static or conditional"),
  mcpClients: conditionalFieldSchema(z2.record(z2.string(), mcpClientToolsConfigSchema)).optional().describe("Map of stored MCP client IDs to their tool configurations \u2014 static or conditional"),
  inputProcessors: conditionalFieldSchema(storedProcessorGraphSchema).optional().describe("Input processor graph \u2014 static or conditional"),
  outputProcessors: conditionalFieldSchema(storedProcessorGraphSchema).optional().describe("Output processor graph \u2014 static or conditional"),
  memory: conditionalFieldSchema(serializedMemoryConfigSchema).optional().describe("Memory configuration \u2014 static or conditional"),
  scorers: conditionalFieldSchema(z2.record(z2.string(), scorerConfigSchema)).optional().describe("Scorer keys with optional sampling config \u2014 static or conditional"),
  skills: conditionalFieldSchema(skillsConfigSchema).optional().describe("Skill IDs mapped to per-skill config \u2014 static or conditional"),
  workspace: conditionalFieldSchema(workspaceRefSchema).optional().describe("Workspace reference (stored ID or inline config) \u2014 static or conditional"),
  requestContextSchema: z2.record(z2.string(), z2.unknown()).optional().describe("JSON Schema defining valid request context variables")
});
var listStoredAgentsResponseSchema = paginationInfoSchema.extend({
  agents: z2.array(storedAgentSchema)
});
var getStoredAgentResponseSchema = storedAgentSchema;
var createStoredAgentResponseSchema = storedAgentSchema;
var updateStoredAgentResponseSchema = z2.union([
  // Thin agent record (no version config)
  z2.object({
    id: z2.string(),
    status: z2.string(),
    activeVersionId: z2.string().optional(),
    authorId: z2.string().optional(),
    metadata: z2.record(z2.string(), z2.unknown()).optional(),
    createdAt: z2.coerce.date(),
    updatedAt: z2.coerce.date()
  }),
  // Resolved agent (thin record + version config)
  storedAgentSchema
]);
var deleteStoredAgentResponseSchema = z2.object({
  success: z2.boolean(),
  message: z2.string()
});
var previewInstructionsBodySchema = z2.object({
  blocks: z2.array(agentInstructionBlockSchema).describe("Array of instruction blocks to resolve"),
  context: z2.record(z2.string(), z2.unknown()).optional().default({}).describe("Request context for variable interpolation and rule evaluation")
});
var previewInstructionsResponseSchema = z2.object({
  result: z2.string().describe("The resolved instructions string")
});

export { conditionalFieldSchema, createStoredAgentBodySchema, createStoredAgentResponseSchema, deleteStoredAgentResponseSchema, getStoredAgentResponseSchema, instructionsSchema, listStoredAgentsQuerySchema, listStoredAgentsResponseSchema, modelConfigSchema, previewInstructionsBodySchema, previewInstructionsResponseSchema, scorerConfigSchema, serializedMemoryConfigSchema, storedAgentIdPathParams, storedProcessorGraphSchema, toolConfigSchema, toolsConfigSchema, updateStoredAgentBodySchema, updateStoredAgentResponseSchema };
//# sourceMappingURL=chunk-EBOYKPNI.js.map
//# sourceMappingURL=chunk-EBOYKPNI.js.map